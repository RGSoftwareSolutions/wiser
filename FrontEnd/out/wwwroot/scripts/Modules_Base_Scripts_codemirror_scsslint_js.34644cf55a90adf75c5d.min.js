/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["Modules_Base_Scripts_codemirror_scsslint_js"],{

/***/ "../../Modules/Base/Scripts/codemirror/scsslint.js":
/*!*********************************************************!*\
  !*** ../../Modules/Base/Scripts/codemirror/scsslint.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var console = __webpack_require__(/*! ../../node_modules/node-polyfill-webpack-plugin/node_modules/console-browserify/index.js */ \"../../node_modules/node-polyfill-webpack-plugin/node_modules/console-browserify/index.js\");\n/******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_175__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId])\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_175__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_175__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_175__.c = installedModules;\r\n/******/\r\n/******/ \t// identity function for calling harmony imports with the correct context\r\n/******/ \t__nested_webpack_require_175__.i = function(value) { return value; };\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_175__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_175__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, {\r\n/******/ \t\t\t\tconfigurable: false,\r\n/******/ \t\t\t\tenumerable: true,\r\n/******/ \t\t\t\tget: getter\r\n/******/ \t\t\t});\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_175__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_175__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_175__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_175__.p = \"\";\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_175__(__nested_webpack_require_175__.s = 10);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __nested_webpack_require_2674__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar gonzales = __nested_webpack_require_2674__(8);\r\n\r\nvar helpers = {};\r\n\r\nhelpers.log = function log(input) {\r\n  console.log(input);\r\n  //  console.log(util.inspect(input, false, null));\r\n};\r\n\r\nhelpers.propertySearch = function (haystack, needle, property) {\r\n  var length = haystack.length,\r\n      i;\r\n\r\n  for (i = 0; i < length; i++) {\r\n    if (haystack[i][property] === needle) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nhelpers.isEqual = function (a, b) {\r\n  var startLine = a.start.line === b.start.line ? true : false,\r\n      endLine = a.end.line === b.end.line ? true : false,\r\n      type = a.type === b.type ? true : false,\r\n      length = a.content.length === b.content.length ? true : false;\r\n\r\n  if (startLine && endLine && type && length) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nhelpers.isUnique = function (results, item) {\r\n  var search = this.propertySearch(results, item.line, 'line');\r\n\r\n  if (search === -1) {\r\n    return true;\r\n  } else if (results[search].column === item.column && results[search].message === item.message) {\r\n    return false;\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\nhelpers.addUnique = function (results, item) {\r\n  if (this.isUnique(results, item)) {\r\n    results.push(item);\r\n  }\r\n  return results;\r\n};\r\n\r\nhelpers.sortDetects = function (a, b) {\r\n  if (a.line < b.line) {\r\n    return -1;\r\n  }\r\n  if (a.line > b.line) {\r\n    return 1;\r\n  }\r\n  if (a.line === b.line) {\r\n    if (a.column < b.column) {\r\n      return -1;\r\n    }\r\n    if (a.column > b.column) {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n  return 0;\r\n};\r\n\r\nhelpers.isNumber = function (val) {\r\n  if (isNaN(parseInt(val, 10))) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nhelpers.isUpperCase = function (str) {\r\n  var pieces = str.split(''),\r\n      i,\r\n      result = 0;\r\n\r\n  for (i = 0; i < pieces.length; i++) {\r\n    if (!helpers.isNumber(pieces[i])) {\r\n      if (pieces[i] === pieces[i].toUpperCase() && pieces[i] !== pieces[i].toLowerCase()) {\r\n        result++;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  if (result) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nhelpers.isLowerCase = function (str) {\r\n  var pieces = str.split(''),\r\n      i,\r\n      result = 0;\r\n\r\n  for (i = 0; i < pieces.length; i++) {\r\n    if (!helpers.isNumber(pieces[i])) {\r\n      if (pieces[i] === pieces[i].toLowerCase() && pieces[i] !== pieces[i].toUpperCase()) {\r\n        result++;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  if (result) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determines if a given string adheres to camel-case format\r\n * @param   {string}  str String to test\r\n * @returns {boolean}     Whether str adheres to camel-case format\r\n */\r\nhelpers.isCamelCase = function (str) {\r\n  return (/^[a-z][a-zA-Z0-9]*$/.test(str)\r\n  );\r\n};\r\n\r\n/**\r\n * Determines if a given string adheres to pascal-case format\r\n * @param   {string}  str String to test\r\n * @returns {boolean}     Whether str adheres to pascal-case format\r\n */\r\nhelpers.isPascalCase = function (str) {\r\n  return (/^[A-Z][a-zA-Z0-9]*$/.test(str)\r\n  );\r\n};\r\n\r\n/**\r\n * Determines if a given string adheres to hyphenated-lowercase format\r\n * @param   {string}  str String to test\r\n * @returns {boolean}     Whether str adheres to hyphenated-lowercase format\r\n */\r\nhelpers.isHyphenatedLowercase = function (str) {\r\n  return !/[^\\-a-z0-9]/.test(str);\r\n};\r\n\r\n/**\r\n * Determines if a given string adheres to snake-case format\r\n * @param   {string}  str String to test\r\n * @returns {boolean}     Whether str adheres to snake-case format\r\n */\r\nhelpers.isSnakeCase = function (str) {\r\n  return !/[^_a-z0-9]/.test(str);\r\n};\r\n\r\n/**\r\n * Determines if a given string adheres to strict-BEM format\r\n * @param   {string}  str String to test\r\n * @returns {boolean}     Whether str adheres to strict-BEM format\r\n */\r\nhelpers.isStrictBEM = function (str) {\r\n  return (/^[a-z](\\-?[a-z0-9]+)*(__[a-z0-9](\\-?[a-z0-9]+)*)?((_[a-z0-9](\\-?[a-z0-9]+)*){0,2})?$/.test(str)\r\n  );\r\n};\r\n\r\n/**\r\n * Determines if a given string adheres to hyphenated-BEM format\r\n * @param   {string}  str String to test\r\n * @returns {boolean}     Whether str adheres to hyphenated-BEM format\r\n */\r\nhelpers.isHyphenatedBEM = function (str) {\r\n  return !/[A-Z]|-{3}|_{3}|[^_]_[^_]/.test(str);\r\n};\r\n\r\nhelpers.isValidHex = function (str) {\r\n  if (str.match(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Check if a node is a newline character or not\r\n *\r\n * @param {Object} node - The node to test\r\n * @returns {boolean} Whether the node is a newline or not\r\n */\r\nhelpers.isNewLine = function (node) {\r\n  // using type === instead of is just in case node happens to be a string\r\n  return !!(node && node.type === 'space' && node.content.match('\\n'));\r\n};\r\n\r\n/**\r\n * Check if a node is a non newline space character or not\r\n *\r\n * @param {Object} node - The node to test\r\n * @returns {boolean} Whether the node is a non newline space or not\r\n */\r\nhelpers.isSpace = function (node) {\r\n  return !!(node && node.type === 'space' && !node.content.match('\\n'));\r\n};\r\n\r\nhelpers.hasEOL = function (str) {\r\n  return (/\\r\\n|\\n/.test(str)\r\n  );\r\n};\r\n\r\nhelpers.isEmptyLine = function (str) {\r\n  return (/(\\r\\n|\\n){2}/.test(str)\r\n  );\r\n};\r\n\r\nhelpers.stripQuotes = function (str) {\r\n  return str.substring(1, str.length - 1);\r\n};\r\n\r\n/**\r\n * Strips vendor prefixes from a string\r\n *\r\n * @param {string} str - The string we wish to remove vendor prefixes from\r\n * @returns {string} The string without vendor prefixes\r\n */\r\nhelpers.stripPrefix = function (str) {\r\n  var modPropertyArr = str.split('-'),\r\n      modProperty = '',\r\n      prefLength = modPropertyArr[2] === 'osx' ? 2 : 1;\r\n\r\n  modPropertyArr.splice(1, prefLength);\r\n\r\n  modPropertyArr.forEach(function (item, index) {\r\n    modProperty = modProperty + item;\r\n    if (index > 0 && index < modPropertyArr.length - 1) {\r\n      modProperty = modProperty + '-';\r\n    }\r\n  });\r\n\r\n  return modProperty;\r\n};\r\n\r\n/**\r\n * Removes the trailing space from a string\r\n * @param {string} curSelector - the current selector string\r\n * @returns {string} curSelector - the current selector minus any trailing space.\r\n */\r\n\r\nhelpers.stripLastSpace = function (selector) {\r\n\r\n  if (selector.charAt(selector.length - 1) === ' ') {\r\n    return selector.substr(0, selector.length - 1);\r\n  }\r\n\r\n  return selector;\r\n};\r\n\r\n/**\r\n * Checks the current selector value against the previous selector value and assesses whether they are\r\n * a) currently an enforced selector type for nesting (user specified - all true by default)\r\n * b) whether they should be nested\r\n * @param {object} currentVal - the current node / part of our selector\r\n * @param {object} previousVal - the previous node / part of our selector\r\n * @param {array} elements - a complete array of nestable selector types\r\n * @param {array} nestable - an array of the types of selector to nest\r\n * @returns {object} Returns whether we or we should nest and the previous val\r\n */\r\nhelpers.isNestable = function (currentVal, previousVal, elements, nestable) {\r\n  // check if they are nestable by checking the previous element against one\r\n  // of the user specified selector types\r\n  if (elements.indexOf(previousVal) !== -1 && nestable.indexOf(currentVal) !== -1) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Tries to traverse the AST, following a specified path\r\n * @param   {object}  node           Starting node\r\n * @param   {array}   traversalPath  Array of Node types to traverse, starting from the first element\r\n * @returns {array}                  Nodes at the end of the path. Empty array if the traversal failed\r\n */\r\nhelpers.attemptTraversal = function (node, traversalPath) {\r\n  var i,\r\n      nextNodeList,\r\n      currentNodeList = [],\r\n      processChildNode = function processChildNode(child) {\r\n    child.forEach(traversalPath[i], function (n) {\r\n      nextNodeList.push(n);\r\n    });\r\n  };\r\n\r\n  node.forEach(traversalPath[0], function (n) {\r\n    currentNodeList.push(n);\r\n  });\r\n\r\n  for (i = 1; i < traversalPath.length; i++) {\r\n    if (currentNodeList.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    nextNodeList = [];\r\n    currentNodeList.forEach(processChildNode);\r\n    currentNodeList = nextNodeList;\r\n  }\r\n  return currentNodeList;\r\n};\r\n\r\n/**\r\n * Collects all suffix extensions for a selector\r\n * @param   {object}  ruleset      ASTNode of type ruleset, containing a selector with nested suffix extensions\r\n * @param   {string}  selectorType Node type of the selector (e.g. class, id)\r\n * @returns {array}                Array of Nodes with the content property replaced by the complete selector\r\n *                                       (without '.', '#', etc) resulting from suffix extensions\r\n */\r\nhelpers.collectSuffixExtensions = function (ruleset, selectorType) {\r\n  var parentSelectors = helpers.attemptTraversal(ruleset, ['selector', selectorType, 'ident']),\r\n      childSuffixes = helpers.attemptTraversal(ruleset, ['block', 'ruleset']),\r\n      selectorList = [];\r\n\r\n  if (parentSelectors.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Goes recursively through all nodes that look like suffix extensions. There may be multiple parents that are\r\n  // extended, so lots of looping is required.\r\n  var processChildSuffix = function processChildSuffix(child, parents) {\r\n    var currentParents = [],\r\n        selectors = helpers.attemptTraversal(child, ['selector', 'parentSelectorExtension', 'ident']),\r\n        nestedChildSuffixes = helpers.attemptTraversal(child, ['block', 'ruleset']);\r\n\r\n    selectors.forEach(function (childSuffixNode) {\r\n      // append suffix extension to all parent selectors\r\n      parents.forEach(function (parent) {\r\n        // clone so we don't modify the actual AST\r\n        var clonedChildSuffixNode = gonzales.createNode(childSuffixNode);\r\n        clonedChildSuffixNode.content = parent.content + clonedChildSuffixNode.content;\r\n\r\n        currentParents.push(clonedChildSuffixNode);\r\n      });\r\n    });\r\n\r\n    selectorList = selectorList.concat(currentParents);\r\n\r\n    nestedChildSuffixes.forEach(function (childSuffix) {\r\n      processChildSuffix(childSuffix, currentParents);\r\n    });\r\n  };\r\n\r\n  childSuffixes.forEach(function (childSuffix) {\r\n    processChildSuffix(childSuffix, parentSelectors);\r\n  });\r\n\r\n  return parentSelectors.concat(selectorList);\r\n};\r\n\r\n/**\r\n * Check for the partial match of a string in an array\r\n *\r\n * @param {string} needle - The value to match\r\n * @param {Array} haystack - The array of values to try and match to\r\n * @returns {Boolean} Whether there is a partial match or not\r\n */\r\nhelpers.isPartialStringMatch = function (needle, haystack) {\r\n  for (var i = 0; i < haystack.length; i++) {\r\n    if (haystack[i].indexOf(needle) >= 0) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n *  A copy of the the stripBom module from https://github.com/sindresorhus/strip-bom/blob/master/index.js\r\n *  The module requires node > 4 whereas we support earlier versions.\r\n *  This function strips the BOM marker from the beginning of a file\r\n *\r\n * @param {string} str - The string we wish to strip the BOM marker from\r\n * @returns {string} The string without a BOM marker\r\n */\r\nhelpers.stripBom = function (str) {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError('Expected a string, got ' + (typeof str === 'undefined' ? 'undefined' : _typeof(str)));\r\n  }\r\n\r\n  if (str.charCodeAt(0) === 0xFEFF) {\r\n    return str.slice(1);\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\nmodule.exports = helpers;\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n// ==============================================================================\r\n//  Helpers\r\n// ==============================================================================\r\n\r\nvar simpleIdents = ['ident', 'number', 'operator', 'combinator', 'string', 'parentSelector', 'delimiter', 'typeSelector', 'attributeMatch'];\r\n\r\nvar subSelectors = ['parentSelectorExtension', 'attributeName', 'attributeValue', 'dimension', 'selector', 'function'];\r\n\r\n/**\r\n * Adds grammar around our content blocks to construct selectors with\r\n * more readable formats.\r\n *\r\n * @param {object} val - The current value node\r\n * @param {string} prefix - The grammar to prefix the value with\r\n * @param {string} suffix - The grammar to add after the value\r\n * @returns {string} The correct readable format\r\n */\r\nvar addGrammar = function addGrammar(val, prefix, suffix) {\r\n  return prefix + val.content + suffix;\r\n};\r\n\r\n/**\r\n * Adds grammar around our content blocks to construct selectors with\r\n * more readable formats and loops the content as they're within sub blocks.\r\n *\r\n * @param {object} val - The current value node\r\n * @param {string} prefix - The grammar to prefix the value with\r\n * @param {string} suffix - The grammar to add after the value\r\n * @param {function} constructSelector - The callback we wish to use which means constructSelector in this instance\r\n * @returns {string} The correct readable format\r\n */\r\nvar constructSubSelector = function constructSubSelector(val, prefix, suffix, constructSelector) {\r\n  var content = prefix;\r\n  val.forEach(function (subItem) {\r\n    content += constructSelector(subItem);\r\n  });\r\n\r\n  return content + suffix;\r\n};\r\n\r\n// ==============================================================================\r\n//  Public Methods\r\n// ==============================================================================\r\n\r\n/**\r\n * Constructs a syntax complete selector for our selector matching and warning output\r\n *\r\n * @param {object} val - The current node / part of our selector\r\n * @returns {string} - Content: The current node with correct syntax e.g. class my-class = '.my-class'\r\n */\r\nvar constructSelector = function constructSelector(val) {\r\n  var content = null;\r\n\r\n  if (val.is('arguments')) {\r\n    content = constructSubSelector(val, '(', ')', constructSelector);\r\n  } else if (val.is('atkeyword')) {\r\n    content = constructSubSelector(val, '@', '', constructSelector);\r\n  } else if (val.is('attributeSelector')) {\r\n    content = constructSubSelector(val, '[', ']', constructSelector);\r\n  } else if (val.is('class')) {\r\n    content = addGrammar(val, '.', '');\r\n  } else if (val.is('id')) {\r\n    content = addGrammar(val, '#', '');\r\n  } else if (val.is('interpolation')) {\r\n    content = constructSubSelector(val, '#{', '}', constructSelector);\r\n  } else if (val.is('nth')) {\r\n    content = addGrammar(val, '(', ')');\r\n  } else if (val.is('nthSelector')) {\r\n    content = constructSubSelector(val, ':', '', constructSelector);\r\n  } else if (val.is('parentheses')) {\r\n    content = constructSubSelector(val, '(', ')', constructSelector);\r\n  } else if (val.is('placeholder')) {\r\n    content = constructSubSelector(val, '%', '', constructSelector);\r\n  } else if (val.is('pseudoClass')) {\r\n    content = constructSubSelector(val, ':', '', constructSelector);\r\n  } else if (val.is('pseudoElement')) {\r\n    content = addGrammar(val, '::', '');\r\n  } else if (val.is('space')) {\r\n    content = ' ';\r\n  } else if (val.is('variable')) {\r\n    content = constructSubSelector(val, '$', '', constructSelector);\r\n  } else if (simpleIdents.indexOf(val.type) !== -1) {\r\n    content = val.content;\r\n  } else if (subSelectors.indexOf(val.type) !== -1) {\r\n    content = constructSubSelector(val, '', '', constructSelector);\r\n  }\r\n\r\n  return content;\r\n};\r\n\r\nmodule.exports = {\r\n  constructSelector: constructSelector\r\n};\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports) {\r\n\r\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = [\r\n\t\"additive-symbols\",\r\n\t\"align-content\",\r\n\t\"align-items\",\r\n\t\"align-self\",\r\n\t\"alignment-adjust\",\r\n\t\"alignment-baseline\",\r\n\t\"all\",\r\n\t\"anchor-point\",\r\n\t\"animation\",\r\n\t\"animation-delay\",\r\n\t\"animation-direction\",\r\n\t\"animation-duration\",\r\n\t\"animation-fill-mode\",\r\n\t\"animation-iteration-count\",\r\n\t\"animation-name\",\r\n\t\"animation-play-state\",\r\n\t\"animation-timing-function\",\r\n\t\"app-region\",\r\n\t\"appearance\",\r\n\t\"aspect-ratio\",\r\n\t\"azimuth\",\r\n\t\"backface-visibility\",\r\n\t\"background\",\r\n\t\"background-attachment\",\r\n\t\"background-blend-mode\",\r\n\t\"background-clip\",\r\n\t\"background-color\",\r\n\t\"background-composite\",\r\n\t\"background-image\",\r\n\t\"background-origin\",\r\n\t\"background-position\",\r\n\t\"background-position-x\",\r\n\t\"background-position-y\",\r\n\t\"background-repeat\",\r\n\t\"background-repeat-x\",\r\n\t\"background-repeat-y\",\r\n\t\"background-size\",\r\n\t\"baseline-shift\",\r\n\t\"binding\",\r\n\t\"bleed\",\r\n\t\"block-size\",\r\n\t\"bookmark-label\",\r\n\t\"bookmark-level\",\r\n\t\"bookmark-state\",\r\n\t\"border\",\r\n\t\"border-after\",\r\n\t\"border-after-color\",\r\n\t\"border-after-style\",\r\n\t\"border-after-width\",\r\n\t\"border-before\",\r\n\t\"border-before-color\",\r\n\t\"border-before-style\",\r\n\t\"border-before-width\",\r\n\t\"border-block-end\",\r\n\t\"border-block-end-color\",\r\n\t\"border-block-end-style\",\r\n\t\"border-block-end-width\",\r\n\t\"border-block-start\",\r\n\t\"border-block-start-color\",\r\n\t\"border-block-start-style\",\r\n\t\"border-block-start-width\",\r\n\t\"border-bottom\",\r\n\t\"border-bottom-color\",\r\n\t\"border-bottom-left-radius\",\r\n\t\"border-bottom-right-radius\",\r\n\t\"border-bottom-style\",\r\n\t\"border-bottom-width\",\r\n\t\"border-collapse\",\r\n\t\"border-color\",\r\n\t\"border-end\",\r\n\t\"border-end-color\",\r\n\t\"border-end-style\",\r\n\t\"border-end-width\",\r\n\t\"border-fit\",\r\n\t\"border-horizontal-spacing\",\r\n\t\"border-image\",\r\n\t\"border-image-outset\",\r\n\t\"border-image-repeat\",\r\n\t\"border-image-slice\",\r\n\t\"border-image-source\",\r\n\t\"border-image-width\",\r\n\t\"border-inline-end\",\r\n\t\"border-inline-end-color\",\r\n\t\"border-inline-end-style\",\r\n\t\"border-inline-end-width\",\r\n\t\"border-inline-start\",\r\n\t\"border-inline-start-color\",\r\n\t\"border-inline-start-style\",\r\n\t\"border-inline-start-width\",\r\n\t\"border-left\",\r\n\t\"border-left-color\",\r\n\t\"border-left-style\",\r\n\t\"border-left-width\",\r\n\t\"border-radius\",\r\n\t\"border-right\",\r\n\t\"border-right-color\",\r\n\t\"border-right-style\",\r\n\t\"border-right-width\",\r\n\t\"border-spacing\",\r\n\t\"border-start\",\r\n\t\"border-start-color\",\r\n\t\"border-start-style\",\r\n\t\"border-start-width\",\r\n\t\"border-style\",\r\n\t\"border-top\",\r\n\t\"border-top-color\",\r\n\t\"border-top-left-radius\",\r\n\t\"border-top-right-radius\",\r\n\t\"border-top-style\",\r\n\t\"border-top-width\",\r\n\t\"border-vertical-spacing\",\r\n\t\"border-width\",\r\n\t\"bottom\",\r\n\t\"box-align\",\r\n\t\"box-decoration-break\",\r\n\t\"box-direction\",\r\n\t\"box-flex\",\r\n\t\"box-flex-group\",\r\n\t\"box-lines\",\r\n\t\"box-ordinal-group\",\r\n\t\"box-orient\",\r\n\t\"box-pack\",\r\n\t\"box-reflect\",\r\n\t\"box-shadow\",\r\n\t\"box-sizing\",\r\n\t\"box-snap\",\r\n\t\"box-suppress\",\r\n\t\"break-after\",\r\n\t\"break-before\",\r\n\t\"break-inside\",\r\n\t\"buffered-rendering\",\r\n\t\"caption-side\",\r\n\t\"chains\",\r\n\t\"clear\",\r\n\t\"clip\",\r\n\t\"clip-path\",\r\n\t\"clip-rule\",\r\n\t\"color\",\r\n\t\"color-interpolation\",\r\n\t\"color-interpolation-filters\",\r\n\t\"color-profile\",\r\n\t\"color-rendering\",\r\n\t\"column-axis\",\r\n\t\"column-break-after\",\r\n\t\"column-break-before\",\r\n\t\"column-break-inside\",\r\n\t\"column-count\",\r\n\t\"column-fill\",\r\n\t\"column-gap\",\r\n\t\"column-progression\",\r\n\t\"column-rule\",\r\n\t\"column-rule-color\",\r\n\t\"column-rule-style\",\r\n\t\"column-rule-width\",\r\n\t\"column-span\",\r\n\t\"column-width\",\r\n\t\"columns\",\r\n\t\"contain\",\r\n\t\"content\",\r\n\t\"counter-increment\",\r\n\t\"counter-reset\",\r\n\t\"counter-set\",\r\n\t\"crop\",\r\n\t\"cue\",\r\n\t\"cue-after\",\r\n\t\"cue-before\",\r\n\t\"cursor\",\r\n\t\"direction\",\r\n\t\"display\",\r\n\t\"display-inside\",\r\n\t\"display-list\",\r\n\t\"display-outside\",\r\n\t\"dominant-baseline\",\r\n\t\"drop-initial-after-adjust\",\r\n\t\"drop-initial-after-align\",\r\n\t\"drop-initial-before-adjust\",\r\n\t\"drop-initial-before-align\",\r\n\t\"drop-initial-size\",\r\n\t\"drop-initial-value\",\r\n\t\"elevation\",\r\n\t\"empty-cells\",\r\n\t\"enable-background\",\r\n\t\"fallback\",\r\n\t\"fill\",\r\n\t\"fill-opacity\",\r\n\t\"fill-rule\",\r\n\t\"filter\",\r\n\t\"fit\",\r\n\t\"fit-position\",\r\n\t\"flex\",\r\n\t\"flex-basis\",\r\n\t\"flex-direction\",\r\n\t\"flex-flow\",\r\n\t\"flex-grow\",\r\n\t\"flex-shrink\",\r\n\t\"flex-wrap\",\r\n\t\"float\",\r\n\t\"float-offset\",\r\n\t\"flood-color\",\r\n\t\"flood-opacity\",\r\n\t\"flow-from\",\r\n\t\"flow-into\",\r\n\t\"font\",\r\n\t\"font-family\",\r\n\t\"font-feature-settings\",\r\n\t\"font-kerning\",\r\n\t\"font-language-override\",\r\n\t\"font-size\",\r\n\t\"font-size-adjust\",\r\n\t\"font-size-delta\",\r\n\t\"font-smoothing\",\r\n\t\"font-stretch\",\r\n\t\"font-style\",\r\n\t\"font-synthesis\",\r\n\t\"font-variant\",\r\n\t\"font-variant-alternates\",\r\n\t\"font-variant-caps\",\r\n\t\"font-variant-east-asian\",\r\n\t\"font-variant-ligatures\",\r\n\t\"font-variant-numeric\",\r\n\t\"font-variant-position\",\r\n\t\"font-weight\",\r\n\t\"glyph-orientation-horizontal\",\r\n\t\"glyph-orientation-vertical\",\r\n\t\"grid\",\r\n\t\"grid-after\",\r\n\t\"grid-area\",\r\n\t\"grid-auto-columns\",\r\n\t\"grid-auto-flow\",\r\n\t\"grid-auto-position\",\r\n\t\"grid-auto-rows\",\r\n\t\"grid-before\",\r\n\t\"grid-column\",\r\n\t\"grid-column-start\",\r\n\t\"grid-column-end\",\r\n\t\"grid-columns\",\r\n\t\"grid-end\",\r\n\t\"grid-row\",\r\n\t\"grid-row-start\",\r\n\t\"grid-row-end\",\r\n\t\"grid-rows\",\r\n\t\"grid-start\",\r\n\t\"grid-template\",\r\n\t\"grid-template-areas\",\r\n\t\"grid-template-rows\",\r\n\t\"grid-template-columns\",\r\n\t\"hanging-punctuation\",\r\n\t\"height\",\r\n\t\"highlight\",\r\n\t\"hyphenate-after\",\r\n\t\"hyphenate-before\",\r\n\t\"hyphenate-character\",\r\n\t\"hyphenate-limit-after\",\r\n\t\"hyphenate-limit-before\",\r\n\t\"hyphenate-limit-lines\",\r\n\t\"hyphenate-lines\",\r\n\t\"hyphenate-resource\",\r\n\t\"hyphens\",\r\n\t\"icon\",\r\n\t\"image-orientation\",\r\n\t\"image-rendering\",\r\n\t\"image-resolution\",\r\n\t\"ime-mode\",\r\n\t\"initial-letters\",\r\n\t\"inline-box-align\",\r\n\t\"inline-size\",\r\n\t\"isolation\",\r\n\t\"justify-content\",\r\n\t\"justify-items\",\r\n\t\"justify-self\",\r\n\t\"kerning\",\r\n\t\"@keyframes\",\r\n\t\"keyframes\",\r\n\t\"left\",\r\n\t\"letter-spacing\",\r\n\t\"lighting-color\",\r\n\t\"line-align\",\r\n\t\"line-box-contain\",\r\n\t\"line-break\",\r\n\t\"line-clamp\",\r\n\t\"line-grid\",\r\n\t\"line-height\",\r\n\t\"line-snap\",\r\n\t\"line-stacking\",\r\n\t\"line-stacking-ruby\",\r\n\t\"line-stacking-shift\",\r\n\t\"line-stacking-strategy\",\r\n\t\"list-style\",\r\n\t\"list-style-image\",\r\n\t\"list-style-position\",\r\n\t\"list-style-type\",\r\n\t\"locale\",\r\n\t\"logical-height\",\r\n\t\"logical-width\",\r\n\t\"margin\",\r\n\t\"margin-after\",\r\n\t\"margin-after-collapse\",\r\n\t\"margin-before\",\r\n\t\"margin-before-collapse\",\r\n\t\"margin-block-end\",\r\n\t\"margin-block-start\",\r\n\t\"margin-bottom\",\r\n\t\"margin-bottom-collapse\",\r\n\t\"margin-collapse\",\r\n\t\"margin-end\",\r\n\t\"margin-inline-end\",\r\n\t\"margin-inline-start\",\r\n\t\"margin-left\",\r\n\t\"margin-right\",\r\n\t\"margin-start\",\r\n\t\"margin-top\",\r\n\t\"margin-top-collapse\",\r\n\t\"mark\",\r\n\t\"mark-after\",\r\n\t\"mark-before\",\r\n\t\"marker\",\r\n\t\"marker-end\",\r\n\t\"marker-mid\",\r\n\t\"marker-offset\",\r\n\t\"marker-side\",\r\n\t\"marker-start\",\r\n\t\"marks\",\r\n\t\"marquee\",\r\n\t\"marquee-direction\",\r\n\t\"marquee-increment\",\r\n\t\"marquee-play-count\",\r\n\t\"marquee-repetition\",\r\n\t\"marquee-speed\",\r\n\t\"marquee-style\",\r\n\t\"mask\",\r\n\t\"mask-box\",\r\n\t\"mask-box-image\",\r\n\t\"mask-box-image-outset\",\r\n\t\"mask-box-image-repeat\",\r\n\t\"mask-box-image-slice\",\r\n\t\"mask-box-image-source\",\r\n\t\"mask-box-image-width\",\r\n\t\"mask-box-outset\",\r\n\t\"mask-box-repeat\",\r\n\t\"mask-box-slice\",\r\n\t\"mask-box-source\",\r\n\t\"mask-box-width\",\r\n\t\"mask-clip\",\r\n\t\"mask-composite\",\r\n\t\"mask-image\",\r\n\t\"mask-origin\",\r\n\t\"mask-position\",\r\n\t\"mask-position-x\",\r\n\t\"mask-position-y\",\r\n\t\"mask-repeat\",\r\n\t\"mask-repeat-x\",\r\n\t\"mask-repeat-y\",\r\n\t\"mask-size\",\r\n\t\"mask-source-type\",\r\n\t\"mask-type\",\r\n\t\"max-block-size\",\r\n\t\"max-height\",\r\n\t\"max-inline-size\",\r\n\t\"max-logical-height\",\r\n\t\"max-logical-width\",\r\n\t\"max-lines\",\r\n\t\"max-width\",\r\n\t\"max-zoom\",\r\n\t\"min-block-size\",\r\n\t\"min-height\",\r\n\t\"min-inline-size\",\r\n\t\"min-logical-height\",\r\n\t\"min-logical-width\",\r\n\t\"min-width\",\r\n\t\"min-zoom\",\r\n\t\"mix-blend-mode\",\r\n\t\"move-to\",\r\n\t\"nav-down\",\r\n\t\"nav-index\",\r\n\t\"nav-left\",\r\n\t\"nav-right\",\r\n\t\"nav-up\",\r\n\t\"negative\",\r\n\t\"object-fit\",\r\n\t\"object-position\",\r\n\t\"offset-block-end\",\r\n\t\"offset-block-start\",\r\n\t\"offset-inline-end\",\r\n\t\"offset-inline-start\",\r\n\t\"opacity\",\r\n\t\"order\",\r\n\t\"orientation\",\r\n\t\"orphans\",\r\n\t\"outline\",\r\n\t\"outline-color\",\r\n\t\"outline-offset\",\r\n\t\"outline-style\",\r\n\t\"outline-width\",\r\n\t\"overflow\",\r\n\t\"overflow-style\",\r\n\t\"overflow-wrap\",\r\n\t\"overflow-x\",\r\n\t\"overflow-y\",\r\n\t\"pad\",\r\n\t\"padding\",\r\n\t\"padding-after\",\r\n\t\"padding-before\",\r\n\t\"padding-block-end\",\r\n\t\"padding-block-start\",\r\n\t\"padding-bottom\",\r\n\t\"padding-end\",\r\n\t\"padding-inline-end\",\r\n\t\"padding-inline-start\",\r\n\t\"padding-left\",\r\n\t\"padding-right\",\r\n\t\"padding-start\",\r\n\t\"padding-top\",\r\n\t\"page\",\r\n\t\"page-break-after\",\r\n\t\"page-break-before\",\r\n\t\"page-break-inside\",\r\n\t\"page-policy\",\r\n\t\"paint-order\",\r\n\t\"pause\",\r\n\t\"pause-after\",\r\n\t\"pause-before\",\r\n\t\"perspective\",\r\n\t\"perspective-origin\",\r\n\t\"perspective-origin-x\",\r\n\t\"perspective-origin-y\",\r\n\t\"pitch\",\r\n\t\"pitch-range\",\r\n\t\"phonemes\",\r\n\t\"play-during\",\r\n\t\"pointer-events\",\r\n\t\"position\",\r\n\t\"prefix\",\r\n\t\"presentation-level\",\r\n\t\"print-color-adjust\",\r\n\t\"punctuation-trim\",\r\n\t\"quotes\",\r\n\t\"range\",\r\n\t\"region-break-after\",\r\n\t\"region-break-before\",\r\n\t\"region-break-inside\",\r\n\t\"region-fragment\",\r\n\t\"region-overflow\",\r\n\t\"rendering-intent\",\r\n\t\"resize\",\r\n\t\"rest\",\r\n\t\"rest-after\",\r\n\t\"rest-before\",\r\n\t\"richness\",\r\n\t\"right\",\r\n\t\"rotation\",\r\n\t\"rotation-point\",\r\n\t\"row-gap\",\r\n\t\"rtl-ordering\",\r\n\t\"ruby-align\",\r\n\t\"ruby-merge\",\r\n\t\"ruby-overhang\",\r\n\t\"ruby-position\",\r\n\t\"ruby-span\",\r\n\t\"scroll-behavior\",\r\n\t\"scroll-snap-coordinate\",\r\n\t\"scroll-snap-destination\",\r\n\t\"scroll-snap-points-x\",\r\n\t\"scroll-snap-points-y\",\r\n\t\"scroll-snap-type\",\r\n\t\"scroll-snap-type-x\",\r\n\t\"scroll-snap-type-y\",\r\n\t\"shape-image-threshold\",\r\n\t\"shape-inside\",\r\n\t\"shape-margin\",\r\n\t\"shape-outside\",\r\n\t\"shape-padding\",\r\n\t\"shape-rendering\",\r\n\t\"size\",\r\n\t\"speak\",\r\n\t\"speak-as\",\r\n\t\"speak-header\",\r\n\t\"speak-numeral\",\r\n\t\"speak-punctuation\",\r\n\t\"speech-rate\",\r\n\t\"src\",\r\n\t\"stop-color\",\r\n\t\"stop-opacity\",\r\n\t\"stress\",\r\n\t\"string-set\",\r\n\t\"stroke\",\r\n\t\"stroke-dasharray\",\r\n\t\"stroke-dashoffset\",\r\n\t\"stroke-linecap\",\r\n\t\"stroke-linejoin\",\r\n\t\"stroke-miterlimit\",\r\n\t\"stroke-opacity\",\r\n\t\"stroke-width\",\r\n\t\"suffix\",\r\n\t\"symbols\",\r\n\t\"system\",\r\n\t\"svg-shadow\",\r\n\t\"table-layout\",\r\n\t\"tab-size\",\r\n\t\"tap-highlight-color\",\r\n\t\"target\",\r\n\t\"target-name\",\r\n\t\"target-new\",\r\n\t\"target-position\",\r\n\t\"text-align\",\r\n\t\"text-align-last\",\r\n\t\"text-anchor\",\r\n\t\"text-combine\",\r\n\t\"text-combine-upright\",\r\n\t\"text-decoration\",\r\n\t\"text-decoration-color\",\r\n\t\"text-decoration-line\",\r\n\t\"text-decoration-skip\",\r\n\t\"text-decoration-style\",\r\n\t\"text-decorations-in-effect\",\r\n\t\"text-emphasis\",\r\n\t\"text-emphasis-color\",\r\n\t\"text-emphasis-position\",\r\n\t\"text-emphasis-style\",\r\n\t\"text-fill-color\",\r\n\t\"text-height\",\r\n\t\"text-indent\",\r\n\t\"text-justify\",\r\n\t\"text-line-through-color\",\r\n\t\"text-line-through-mode\",\r\n\t\"text-line-through-style\",\r\n\t\"text-line-through-width\",\r\n\t\"text-orientation\",\r\n\t\"text-outline\",\r\n\t\"text-overflow\",\r\n\t\"text-overline-color\",\r\n\t\"text-overline-mode\",\r\n\t\"text-overline-style\",\r\n\t\"text-overline-width\",\r\n\t\"text-rendering\",\r\n\t\"text-rendering\",\r\n\t\"text-security\",\r\n\t\"text-shadow\",\r\n\t\"text-size-adjust\",\r\n\t\"text-shadow\",\r\n\t\"text-space-collapse\",\r\n\t\"text-stroke\",\r\n\t\"text-stroke-color\",\r\n\t\"text-stroke-width\",\r\n\t\"text-transform\",\r\n\t\"text-underline-color\",\r\n\t\"text-underline-mode\",\r\n\t\"text-underline-position\",\r\n\t\"text-underline-style\",\r\n\t\"text-underline-width\",\r\n\t\"text-wrap\",\r\n\t\"top\",\r\n\t\"touch-action\",\r\n\t\"touch-action-delay\",\r\n\t\"transform\",\r\n\t\"transform-box\",\r\n\t\"transform-origin\",\r\n\t\"transform-origin-x\",\r\n\t\"transform-origin-y\",\r\n\t\"transform-origin-z\",\r\n\t\"transform-style\",\r\n\t\"transition\",\r\n\t\"transition-delay\",\r\n\t\"transition-duration\",\r\n\t\"transition-property\",\r\n\t\"transition-timing-function\",\r\n\t\"unicode-bidi\",\r\n\t\"unicode-range\",\r\n\t\"user-drag\",\r\n\t\"user-modify\",\r\n\t\"user-select\",\r\n\t\"user-zoom\",\r\n\t\"vector-effect\",\r\n\t\"vertical-align\",\r\n\t\"visibility\",\r\n\t\"voice-balance\",\r\n\t\"voice-duration\",\r\n\t\"voice-family\",\r\n\t\"voice-pitch\",\r\n\t\"voice-pitch-range\",\r\n\t\"voice-range\",\r\n\t\"voice-rate\",\r\n\t\"voice-stress\",\r\n\t\"voice-volume\",\r\n\t\"volume\",\r\n\t\"white-space\",\r\n\t\"widows\",\r\n\t\"width\",\r\n\t\"will-change\",\r\n\t\"word-break\",\r\n\t\"word-spacing\",\r\n\t\"word-wrap\",\r\n\t\"wrap-flow\",\r\n\t\"wrap-through\",\r\n\t\"writing-mode\",\r\n\t\"z-index\",\r\n\t\"zoom\"\r\n];\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __nested_webpack_require_30909__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * lodash (Custom Build) <https://lodash.com/>\r\n * Build: `lodash modularize exports=\"npm\" -o ./`\r\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\r\n * Released under MIT license <https://lodash.com/license>\r\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\r\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n */\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar INFINITY = 1 / 0;\r\n\r\n/** `Object#toString` result references. */\r\nvar symbolTag = '[object Symbol]';\r\n\r\n/** Used to compose unicode character classes. */\r\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\r\n    rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\r\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\r\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\r\n\r\n/** Used to compose unicode capture groups. */\r\nvar rsAstral = '[' + rsAstralRange + ']',\r\n    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\r\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\r\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\r\n    rsNonAstral = '[^' + rsAstralRange + ']',\r\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\r\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\r\n    rsZWJ = '\\\\u200d';\r\n\r\n/** Used to compose unicode regexes. */\r\nvar reOptMod = rsModifier + '?',\r\n    rsOptVar = '[' + rsVarRange + ']?',\r\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\r\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\r\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\r\n\r\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\r\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\r\n\r\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\r\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\r\n\r\n/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\r\n\r\n/** Detect free variable `self`. */\r\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\r\n\r\n/** Used as a reference to the global object. */\r\nvar root = freeGlobal || freeSelf || Function('return this')();\r\n\r\n/**\r\n * Converts an ASCII `string` to an array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the converted array.\r\n */\r\nfunction asciiToArray(string) {\r\n  return string.split('');\r\n}\r\n\r\n/**\r\n * Checks if `string` contains Unicode symbols.\r\n *\r\n * @private\r\n * @param {string} string The string to inspect.\r\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\r\n */\r\nfunction hasUnicode(string) {\r\n  return reHasUnicode.test(string);\r\n}\r\n\r\n/**\r\n * Converts `string` to an array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the converted array.\r\n */\r\nfunction stringToArray(string) {\r\n  return hasUnicode(string)\r\n    ? unicodeToArray(string)\r\n    : asciiToArray(string);\r\n}\r\n\r\n/**\r\n * Converts a Unicode `string` to an array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the converted array.\r\n */\r\nfunction unicodeToArray(string) {\r\n  return string.match(reUnicode) || [];\r\n}\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\nvar objectToString = objectProto.toString;\r\n\r\n/** Built-in value references. */\r\nvar Symbol = root.Symbol;\r\n\r\n/** Used to convert symbols to primitives and strings. */\r\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\r\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\r\n\r\n/**\r\n * The base implementation of `_.slice` without an iteratee call guard.\r\n *\r\n * @private\r\n * @param {Array} array The array to slice.\r\n * @param {number} [start=0] The start position.\r\n * @param {number} [end=array.length] The end position.\r\n * @returns {Array} Returns the slice of `array`.\r\n */\r\nfunction baseSlice(array, start, end) {\r\n  var index = -1,\r\n      length = array.length;\r\n\r\n  if (start < 0) {\r\n    start = -start > length ? 0 : (length + start);\r\n  }\r\n  end = end > length ? length : end;\r\n  if (end < 0) {\r\n    end += length;\r\n  }\r\n  length = start > end ? 0 : ((end - start) >>> 0);\r\n  start >>>= 0;\r\n\r\n  var result = Array(length);\r\n  while (++index < length) {\r\n    result[index] = array[index + start];\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * The base implementation of `_.toString` which doesn't convert nullish\r\n * values to empty strings.\r\n *\r\n * @private\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n */\r\nfunction baseToString(value) {\r\n  // Exit early for strings to avoid a performance hit in some environments.\r\n  if (typeof value == 'string') {\r\n    return value;\r\n  }\r\n  if (isSymbol(value)) {\r\n    return symbolToString ? symbolToString.call(value) : '';\r\n  }\r\n  var result = (value + '');\r\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\r\n}\r\n\r\n/**\r\n * Casts `array` to a slice if it's needed.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {number} start The start position.\r\n * @param {number} [end=array.length] The end position.\r\n * @returns {Array} Returns the cast slice.\r\n */\r\nfunction castSlice(array, start, end) {\r\n  var length = array.length;\r\n  end = end === undefined ? length : end;\r\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\r\n}\r\n\r\n/**\r\n * Creates a function like `_.lowerFirst`.\r\n *\r\n * @private\r\n * @param {string} methodName The name of the `String` case method to use.\r\n * @returns {Function} Returns the new case function.\r\n */\r\nfunction createCaseFirst(methodName) {\r\n  return function(string) {\r\n    string = toString(string);\r\n\r\n    var strSymbols = hasUnicode(string)\r\n      ? stringToArray(string)\r\n      : undefined;\r\n\r\n    var chr = strSymbols\r\n      ? strSymbols[0]\r\n      : string.charAt(0);\r\n\r\n    var trailing = strSymbols\r\n      ? castSlice(strSymbols, 1).join('')\r\n      : string.slice(1);\r\n\r\n    return chr[methodName]() + trailing;\r\n  };\r\n}\r\n\r\n/**\r\n * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n * and has a `typeof` result of \"object\".\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n * @example\r\n *\r\n * _.isObjectLike({});\r\n * // => true\r\n *\r\n * _.isObjectLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObjectLike(_.noop);\r\n * // => false\r\n *\r\n * _.isObjectLike(null);\r\n * // => false\r\n */\r\nfunction isObjectLike(value) {\r\n  return !!value && typeof value == 'object';\r\n}\r\n\r\n/**\r\n * Checks if `value` is classified as a `Symbol` primitive or object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n *\r\n * _.isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * _.isSymbol('abc');\r\n * // => false\r\n */\r\nfunction isSymbol(value) {\r\n  return typeof value == 'symbol' ||\r\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\r\n}\r\n\r\n/**\r\n * Converts `value` to a string. An empty string is returned for `null`\r\n * and `undefined` values. The sign of `-0` is preserved.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n * @example\r\n *\r\n * _.toString(null);\r\n * // => ''\r\n *\r\n * _.toString(-0);\r\n * // => '-0'\r\n *\r\n * _.toString([1, 2, 3]);\r\n * // => '1,2,3'\r\n */\r\nfunction toString(value) {\r\n  return value == null ? '' : baseToString(value);\r\n}\r\n\r\n/**\r\n * Converts the first character of `string` to upper case and the remaining\r\n * to lower case.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category String\r\n * @param {string} [string=''] The string to capitalize.\r\n * @returns {string} Returns the capitalized string.\r\n * @example\r\n *\r\n * _.capitalize('FRED');\r\n * // => 'Fred'\r\n */\r\nfunction capitalize(string) {\r\n  return upperFirst(toString(string).toLowerCase());\r\n}\r\n\r\n/**\r\n * Converts the first character of `string` to upper case.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category String\r\n * @param {string} [string=''] The string to convert.\r\n * @returns {string} Returns the converted string.\r\n * @example\r\n *\r\n * _.upperFirst('fred');\r\n * // => 'Fred'\r\n *\r\n * _.upperFirst('FRED');\r\n * // => 'FRED'\r\n */\r\nvar upperFirst = createCaseFirst('toUpperCase');\r\n\r\nmodule.exports = capitalize;\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_30909__(2)))\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_40110__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * lodash (Custom Build) <https://lodash.com/>\r\n * Build: `lodash modularize exports=\"npm\" -o ./`\r\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\r\n * Released under MIT license <https://lodash.com/license>\r\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\r\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n */\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar INFINITY = 1 / 0;\r\n\r\n/** `Object#toString` result references. */\r\nvar symbolTag = '[object Symbol]';\r\n\r\n/** Used to match words composed of alphanumeric characters. */\r\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\r\n\r\n/** Used to match Latin Unicode letters (excluding mathematical operators). */\r\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\r\n\r\n/** Used to compose unicode character classes. */\r\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\r\n    rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\r\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\r\n    rsDingbatRange = '\\\\u2700-\\\\u27bf',\r\n    rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\r\n    rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\r\n    rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\r\n    rsPunctuationRange = '\\\\u2000-\\\\u206f',\r\n    rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\r\n    rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\r\n    rsVarRange = '\\\\ufe0e\\\\ufe0f',\r\n    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\r\n\r\n/** Used to compose unicode capture groups. */\r\nvar rsApos = \"['\\u2019]\",\r\n    rsBreak = '[' + rsBreakRange + ']',\r\n    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\r\n    rsDigits = '\\\\d+',\r\n    rsDingbat = '[' + rsDingbatRange + ']',\r\n    rsLower = '[' + rsLowerRange + ']',\r\n    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\r\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\r\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\r\n    rsNonAstral = '[^' + rsAstralRange + ']',\r\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\r\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\r\n    rsUpper = '[' + rsUpperRange + ']',\r\n    rsZWJ = '\\\\u200d';\r\n\r\n/** Used to compose unicode regexes. */\r\nvar rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',\r\n    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',\r\n    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\r\n    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\r\n    reOptMod = rsModifier + '?',\r\n    rsOptVar = '[' + rsVarRange + ']?',\r\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\r\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\r\n    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;\r\n\r\n/** Used to match apostrophes. */\r\nvar reApos = RegExp(rsApos, 'g');\r\n\r\n/**\r\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\r\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\r\n */\r\nvar reComboMark = RegExp(rsCombo, 'g');\r\n\r\n/** Used to match complex or compound words. */\r\nvar reUnicodeWord = RegExp([\r\n  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\r\n  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',\r\n  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,\r\n  rsUpper + '+' + rsOptUpperContr,\r\n  rsDigits,\r\n  rsEmoji\r\n].join('|'), 'g');\r\n\r\n/** Used to detect strings that need a more robust regexp to match words. */\r\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\r\n\r\n/** Used to map Latin Unicode letters to basic Latin letters. */\r\nvar deburredLetters = {\r\n  // Latin-1 Supplement block.\r\n  '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\r\n  '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\r\n  '\\xc7': 'C',  '\\xe7': 'c',\r\n  '\\xd0': 'D',  '\\xf0': 'd',\r\n  '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\r\n  '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\r\n  '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\r\n  '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\r\n  '\\xd1': 'N',  '\\xf1': 'n',\r\n  '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\r\n  '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\r\n  '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\r\n  '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\r\n  '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\r\n  '\\xc6': 'Ae', '\\xe6': 'ae',\r\n  '\\xde': 'Th', '\\xfe': 'th',\r\n  '\\xdf': 'ss',\r\n  // Latin Extended-A block.\r\n  '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\r\n  '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\r\n  '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\r\n  '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\r\n  '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\r\n  '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\r\n  '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\r\n  '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\r\n  '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\r\n  '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\r\n  '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\r\n  '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\r\n  '\\u0134': 'J',  '\\u0135': 'j',\r\n  '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\r\n  '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\r\n  '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\r\n  '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\r\n  '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\r\n  '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\r\n  '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\r\n  '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\r\n  '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\r\n  '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\r\n  '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\r\n  '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\r\n  '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\r\n  '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\r\n  '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\r\n  '\\u0174': 'W',  '\\u0175': 'w',\r\n  '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\r\n  '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\r\n  '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\r\n  '\\u0132': 'IJ', '\\u0133': 'ij',\r\n  '\\u0152': 'Oe', '\\u0153': 'oe',\r\n  '\\u0149': \"'n\", '\\u017f': 'ss'\r\n};\r\n\r\n/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\r\n\r\n/** Detect free variable `self`. */\r\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\r\n\r\n/** Used as a reference to the global object. */\r\nvar root = freeGlobal || freeSelf || Function('return this')();\r\n\r\n/**\r\n * A specialized version of `_.reduce` for arrays without support for\r\n * iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @param {*} [accumulator] The initial value.\r\n * @param {boolean} [initAccum] Specify using the first element of `array` as\r\n *  the initial value.\r\n * @returns {*} Returns the accumulated value.\r\n */\r\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\r\n  var index = -1,\r\n      length = array ? array.length : 0;\r\n\r\n  if (initAccum && length) {\r\n    accumulator = array[++index];\r\n  }\r\n  while (++index < length) {\r\n    accumulator = iteratee(accumulator, array[index], index, array);\r\n  }\r\n  return accumulator;\r\n}\r\n\r\n/**\r\n * Splits an ASCII `string` into an array of its words.\r\n *\r\n * @private\r\n * @param {string} The string to inspect.\r\n * @returns {Array} Returns the words of `string`.\r\n */\r\nfunction asciiWords(string) {\r\n  return string.match(reAsciiWord) || [];\r\n}\r\n\r\n/**\r\n * The base implementation of `_.propertyOf` without support for deep paths.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Function} Returns the new accessor function.\r\n */\r\nfunction basePropertyOf(object) {\r\n  return function(key) {\r\n    return object == null ? undefined : object[key];\r\n  };\r\n}\r\n\r\n/**\r\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\r\n * letters to basic Latin letters.\r\n *\r\n * @private\r\n * @param {string} letter The matched letter to deburr.\r\n * @returns {string} Returns the deburred letter.\r\n */\r\nvar deburrLetter = basePropertyOf(deburredLetters);\r\n\r\n/**\r\n * Checks if `string` contains a word composed of Unicode symbols.\r\n *\r\n * @private\r\n * @param {string} string The string to inspect.\r\n * @returns {boolean} Returns `true` if a word is found, else `false`.\r\n */\r\nfunction hasUnicodeWord(string) {\r\n  return reHasUnicodeWord.test(string);\r\n}\r\n\r\n/**\r\n * Splits a Unicode `string` into an array of its words.\r\n *\r\n * @private\r\n * @param {string} The string to inspect.\r\n * @returns {Array} Returns the words of `string`.\r\n */\r\nfunction unicodeWords(string) {\r\n  return string.match(reUnicodeWord) || [];\r\n}\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\nvar objectToString = objectProto.toString;\r\n\r\n/** Built-in value references. */\r\nvar Symbol = root.Symbol;\r\n\r\n/** Used to convert symbols to primitives and strings. */\r\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\r\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\r\n\r\n/**\r\n * The base implementation of `_.toString` which doesn't convert nullish\r\n * values to empty strings.\r\n *\r\n * @private\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n */\r\nfunction baseToString(value) {\r\n  // Exit early for strings to avoid a performance hit in some environments.\r\n  if (typeof value == 'string') {\r\n    return value;\r\n  }\r\n  if (isSymbol(value)) {\r\n    return symbolToString ? symbolToString.call(value) : '';\r\n  }\r\n  var result = (value + '');\r\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\r\n}\r\n\r\n/**\r\n * Creates a function like `_.camelCase`.\r\n *\r\n * @private\r\n * @param {Function} callback The function to combine each word.\r\n * @returns {Function} Returns the new compounder function.\r\n */\r\nfunction createCompounder(callback) {\r\n  return function(string) {\r\n    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\r\n  };\r\n}\r\n\r\n/**\r\n * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n * and has a `typeof` result of \"object\".\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n * @example\r\n *\r\n * _.isObjectLike({});\r\n * // => true\r\n *\r\n * _.isObjectLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObjectLike(_.noop);\r\n * // => false\r\n *\r\n * _.isObjectLike(null);\r\n * // => false\r\n */\r\nfunction isObjectLike(value) {\r\n  return !!value && typeof value == 'object';\r\n}\r\n\r\n/**\r\n * Checks if `value` is classified as a `Symbol` primitive or object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n *\r\n * _.isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * _.isSymbol('abc');\r\n * // => false\r\n */\r\nfunction isSymbol(value) {\r\n  return typeof value == 'symbol' ||\r\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\r\n}\r\n\r\n/**\r\n * Converts `value` to a string. An empty string is returned for `null`\r\n * and `undefined` values. The sign of `-0` is preserved.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n * @example\r\n *\r\n * _.toString(null);\r\n * // => ''\r\n *\r\n * _.toString(-0);\r\n * // => '-0'\r\n *\r\n * _.toString([1, 2, 3]);\r\n * // => '1,2,3'\r\n */\r\nfunction toString(value) {\r\n  return value == null ? '' : baseToString(value);\r\n}\r\n\r\n/**\r\n * Deburrs `string` by converting\r\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\r\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\r\n * letters to basic Latin letters and removing\r\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category String\r\n * @param {string} [string=''] The string to deburr.\r\n * @returns {string} Returns the deburred string.\r\n * @example\r\n *\r\n * _.deburr('dj vu');\r\n * // => 'deja vu'\r\n */\r\nfunction deburr(string) {\r\n  string = toString(string);\r\n  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\r\n}\r\n\r\n/**\r\n * Converts `string` to\r\n * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category String\r\n * @param {string} [string=''] The string to convert.\r\n * @returns {string} Returns the kebab cased string.\r\n * @example\r\n *\r\n * _.kebabCase('Foo Bar');\r\n * // => 'foo-bar'\r\n *\r\n * _.kebabCase('fooBar');\r\n * // => 'foo-bar'\r\n *\r\n * _.kebabCase('__FOO_BAR__');\r\n * // => 'foo-bar'\r\n */\r\nvar kebabCase = createCompounder(function(result, word, index) {\r\n  return result + (index ? '-' : '') + word.toLowerCase();\r\n});\r\n\r\n/**\r\n * Splits `string` into an array of its words.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category String\r\n * @param {string} [string=''] The string to inspect.\r\n * @param {RegExp|string} [pattern] The pattern to match words.\r\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n * @returns {Array} Returns the words of `string`.\r\n * @example\r\n *\r\n * _.words('fred, barney, & pebbles');\r\n * // => ['fred', 'barney', 'pebbles']\r\n *\r\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\r\n * // => ['fred', 'barney', '&', 'pebbles']\r\n */\r\nfunction words(string, pattern, guard) {\r\n  string = toString(string);\r\n  pattern = guard ? undefined : pattern;\r\n\r\n  if (pattern === undefined) {\r\n    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\r\n  }\r\n  return string.match(pattern) || [];\r\n}\r\n\r\nmodule.exports = kebabCase;\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_40110__(2)))\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = [\r\n\t\"aliceblue\",\r\n\t\"f0f8ff\",\r\n\t\"antiquewhite\",\r\n\t\"faebd7\",\r\n\t\"aqua\",\r\n\t\"00ffff\",\r\n\t\"aquamarine\",\r\n\t\"7fffd4\",\r\n\t\"azure\",\r\n\t\"f0ffff\",\r\n\t\"beige\",\r\n\t\"f5f5dc\",\r\n\t\"bisque\",\r\n\t\"ffe4c4\",\r\n\t\"black\",\r\n\t\"000000\",\r\n\t\"blanchedalmond\",\r\n\t\"ffebcd\",\r\n\t\"blue\",\r\n\t\"0000ff\",\r\n\t\"blueviolet\",\r\n\t\"8a2be2\",\r\n\t\"brown\",\r\n\t\"a52a2a\",\r\n\t\"burlywood\",\r\n\t\"deb887\",\r\n\t\"cadetblue\",\r\n\t\"5f9ea0\",\r\n\t\"chartreuse\",\r\n\t\"7fff00\",\r\n\t\"chocolate\",\r\n\t\"d2691e\",\r\n\t\"coral\",\r\n\t\"ff7f50\",\r\n\t\"cornflowerblue\",\r\n\t\"6495ed\",\r\n\t\"cornsilk\",\r\n\t\"fff8dc\",\r\n\t\"crimson\",\r\n\t\"dc143c\",\r\n\t\"cyan\",\r\n\t\"00ffff\",\r\n\t\"darkblue\",\r\n\t\"00008b\",\r\n\t\"darkcyan\",\r\n\t\"008b8b\",\r\n\t\"darkgoldenrod\",\r\n\t\"b8860b\",\r\n\t\"darkgray\",\r\n\t\"a9a9a9\",\r\n\t\"darkgrey\",\r\n\t\"a9a9a9\",\r\n\t\"darkgreen\",\r\n\t\"006400\",\r\n\t\"darkkhaki\",\r\n\t\"bdb76b\",\r\n\t\"darkmagenta\",\r\n\t\"8b008b\",\r\n\t\"darkolivegreen\",\r\n\t\"556b2f\",\r\n\t\"darkorange\",\r\n\t\"ff8c00\",\r\n\t\"darkorchid\",\r\n\t\"9932cc\",\r\n\t\"darkred\",\r\n\t\"8b0000\",\r\n\t\"darksalmon\",\r\n\t\"e9967a\",\r\n\t\"darkseagreen\",\r\n\t\"8fbc8f\",\r\n\t\"darkslateblue\",\r\n\t\"483d8b\",\r\n\t\"darkslategray\",\r\n\t\"2f4f4f\",\r\n\t\"darkslategrey\",\r\n\t\"2f4f4f\",\r\n\t\"darkturquoise\",\r\n\t\"00ced1\",\r\n\t\"darkviolet\",\r\n\t\"9400d3\",\r\n\t\"deeppink\",\r\n\t\"ff1493\",\r\n\t\"deepskyblue\",\r\n\t\"00bfff\",\r\n\t\"dimgray\",\r\n\t\"696969\",\r\n\t\"dimgrey\",\r\n\t\"696969\",\r\n\t\"dodgerblue\",\r\n\t\"1e90ff\",\r\n\t\"firebrick\",\r\n\t\"b22222\",\r\n\t\"floralwhite\",\r\n\t\"fffaf0\",\r\n\t\"forestgreen\",\r\n\t\"228b22\",\r\n\t\"fuchsia\",\r\n\t\"ff00ff\",\r\n\t\"gainsboro\",\r\n\t\"dcdcdc\",\r\n\t\"ghostwhite\",\r\n\t\"f8f8ff\",\r\n\t\"gold\",\r\n\t\"ffd700\",\r\n\t\"goldenrod\",\r\n\t\"daa520\",\r\n\t\"gray\",\r\n\t\"808080\",\r\n\t\"grey\",\r\n\t\"808080\",\r\n\t\"green\",\r\n\t\"008000\",\r\n\t\"greenyellow\",\r\n\t\"adff2f\",\r\n\t\"honeydew\",\r\n\t\"f0fff0\",\r\n\t\"hotpink\",\r\n\t\"ff69b4\",\r\n\t\"indianred\",\r\n\t\"cd5c5c\",\r\n\t\"indigo\",\r\n\t\"4b0082\",\r\n\t\"ivory\",\r\n\t\"fffff0\",\r\n\t\"khaki\",\r\n\t\"f0e68c\",\r\n\t\"lavender\",\r\n\t\"e6e6fa\",\r\n\t\"lavenderblush\",\r\n\t\"fff0f5\",\r\n\t\"lawngreen\",\r\n\t\"7cfc00\",\r\n\t\"lemonchiffon\",\r\n\t\"fffacd\",\r\n\t\"lightblue\",\r\n\t\"add8e6\",\r\n\t\"lightcoral\",\r\n\t\"f08080\",\r\n\t\"lightcyan\",\r\n\t\"e0ffff\",\r\n\t\"lightgoldenrodyellow\",\r\n\t\"fafad2\",\r\n\t\"lightgray\",\r\n\t\"d3d3d3\",\r\n\t\"lightgrey\",\r\n\t\"d3d3d3\",\r\n\t\"lightgreen\",\r\n\t\"90ee90\",\r\n\t\"lightpink\",\r\n\t\"ffb6c1\",\r\n\t\"lightsalmon\",\r\n\t\"ffa07a\",\r\n\t\"lightseagreen\",\r\n\t\"20b2aa\",\r\n\t\"lightskyblue\",\r\n\t\"87cefa\",\r\n\t\"lightslategray\",\r\n\t\"778899\",\r\n\t\"lightslategrey\",\r\n\t\"778899\",\r\n\t\"lightsteelblue\",\r\n\t\"b0c4de\",\r\n\t\"lightyellow\",\r\n\t\"ffffe0\",\r\n\t\"lime\",\r\n\t\"00ff00\",\r\n\t\"limegreen\",\r\n\t\"32cd32\",\r\n\t\"linen\",\r\n\t\"faf0e6\",\r\n\t\"magenta\",\r\n\t\"ff00ff\",\r\n\t\"maroon\",\r\n\t\"800000\",\r\n\t\"mediumaquamarine\",\r\n\t\"66cdaa\",\r\n\t\"mediumblue\",\r\n\t\"0000cd\",\r\n\t\"mediumorchid\",\r\n\t\"ba55d3\",\r\n\t\"mediumpurple\",\r\n\t\"9370d8\",\r\n\t\"mediumseagreen\",\r\n\t\"3cb371\",\r\n\t\"mediumslateblue\",\r\n\t\"7b68ee\",\r\n\t\"mediumspringgreen\",\r\n\t\"00fa9a\",\r\n\t\"mediumturquoise\",\r\n\t\"48d1cc\",\r\n\t\"mediumvioletred\",\r\n\t\"c71585\",\r\n\t\"midnightblue\",\r\n\t\"191970\",\r\n\t\"mintcream\",\r\n\t\"f5fffa\",\r\n\t\"mistyrose\",\r\n\t\"ffe4e1\",\r\n\t\"moccasin\",\r\n\t\"ffe4b5\",\r\n\t\"navajowhite\",\r\n\t\"ffdead\",\r\n\t\"navy\",\r\n\t\"000080\",\r\n\t\"oldlace\",\r\n\t\"fdf5e6\",\r\n\t\"olive\",\r\n\t\"808000\",\r\n\t\"olivedrab\",\r\n\t\"6b8e23\",\r\n\t\"orange\",\r\n\t\"ffa500\",\r\n\t\"orangered\",\r\n\t\"ff4500\",\r\n\t\"orchid\",\r\n\t\"da70d6\",\r\n\t\"palegoldenrod\",\r\n\t\"eee8aa\",\r\n\t\"palegreen\",\r\n\t\"98fb98\",\r\n\t\"paleturquoise\",\r\n\t\"afeeee\",\r\n\t\"palevioletred\",\r\n\t\"d87093\",\r\n\t\"papayawhip\",\r\n\t\"ffefd5\",\r\n\t\"peachpuff\",\r\n\t\"ffdab9\",\r\n\t\"peru\",\r\n\t\"cd853f\",\r\n\t\"pink\",\r\n\t\"ffc0cb\",\r\n\t\"plum\",\r\n\t\"dda0dd\",\r\n\t\"powderblue\",\r\n\t\"b0e0e6\",\r\n\t\"purple\",\r\n\t\"800080\",\r\n\t\"rebeccapurple\",\r\n\t\"663399\",\r\n\t\"red\",\r\n\t\"ff0000\",\r\n\t\"rosybrown\",\r\n\t\"bc8f8f\",\r\n\t\"royalblue\",\r\n\t\"4169e1\",\r\n\t\"saddlebrown\",\r\n\t\"8b4513\",\r\n\t\"salmon\",\r\n\t\"fa8072\",\r\n\t\"sandybrown\",\r\n\t\"f4a460\",\r\n\t\"seagreen\",\r\n\t\"2e8b57\",\r\n\t\"seashell\",\r\n\t\"fff5ee\",\r\n\t\"sienna\",\r\n\t\"a0522d\",\r\n\t\"silver\",\r\n\t\"c0c0c0\",\r\n\t\"skyblue\",\r\n\t\"87ceeb\",\r\n\t\"slateblue\",\r\n\t\"6a5acd\",\r\n\t\"slategray\",\r\n\t\"708090\",\r\n\t\"slategrey\",\r\n\t\"708090\",\r\n\t\"snow\",\r\n\t\"fffafa\",\r\n\t\"springgreen\",\r\n\t\"00ff7f\",\r\n\t\"steelblue\",\r\n\t\"4682b4\",\r\n\t\"tan\",\r\n\t\"d2b48c\",\r\n\t\"teal\",\r\n\t\"008080\",\r\n\t\"thistle\",\r\n\t\"d8bfd8\",\r\n\t\"tomato\",\r\n\t\"ff6347\",\r\n\t\"turquoise\",\r\n\t\"40e0d0\",\r\n\t\"violet\",\r\n\t\"ee82ee\",\r\n\t\"wheat\",\r\n\t\"f5deb3\",\r\n\t\"white\",\r\n\t\"ffffff\",\r\n\t\"whitesmoke\",\r\n\t\"f5f5f5\",\r\n\t\"yellow\",\r\n\t\"ffff00\",\r\n\t\"yellowgreen\",\r\n\t\"9acd32\"\r\n];\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(this, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_60477__(moduleId) {\r\n\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId])\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\texports: {},\r\n/******/ \t\t\tid: moduleId,\r\n/******/ \t\t\tloaded: false\r\n/******/ \t\t};\r\n\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_60477__);\r\n\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.loaded = true;\r\n\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n\r\n\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_60477__.m = modules;\r\n\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_60477__.c = installedModules;\r\n\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_60477__.p = \"\";\r\n\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_60477__(0);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ function(module, exports, __nested_webpack_require_61716__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar Node = __nested_webpack_require_61716__(1);\r\n\tvar parse = __nested_webpack_require_61716__(7);\r\n\r\n\tmodule.exports = {\r\n\t  createNode: function (options) {\r\n\t    return new Node(options);\r\n\t  },\r\n\t  parse: parse\r\n\t};\r\n\r\n/***/ },\r\n/* 1 */\r\n/***/ function(module, exports, __nested_webpack_require_62009__) {\r\n\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * @param {string} type\r\n\t * @param {array|string} content\r\n\t * @param {number} line\r\n\t * @param {number} column\r\n\t * @constructor\r\n\t */\r\n\r\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\r\n\r\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\r\n\r\n\tvar Node = (function () {\r\n\t  function Node(options) {\r\n\t    _classCallCheck(this, Node);\r\n\r\n\t    this.type = options.type;\r\n\t    this.content = options.content;\r\n\t    this.syntax = options.syntax;\r\n\r\n\t    if (options.start) this.start = options.start;\r\n\t    if (options.end) this.end = options.end;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param {String} type Node type\r\n\t   * @return {Boolean} Whether there is a child node of given type\r\n\t   */\r\n\r\n\t  Node.prototype.contains = function contains(type) {\r\n\t    return this.content.some(function (node) {\r\n\t      return node.type === type;\r\n\t    });\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {String} type Node type\r\n\t   * @param {Function} callback Function to call for every found node\r\n\t   */\r\n\r\n\t  Node.prototype.eachFor = function eachFor(type, callback) {\r\n\t    if (!Array.isArray(this.content)) return;\r\n\r\n\t    if (typeof type !== 'string') {\r\n\t      callback = type;\r\n\t      type = null;\r\n\t    }\r\n\r\n\t    var l = this.content.length;\r\n\t    var breakLoop;\r\n\r\n\t    for (var i = l; i--;) {\r\n\t      if (breakLoop === null) break;\r\n\r\n\t      if (!type || this.content[i] && this.content[i].type === type) breakLoop = callback(this.content[i], i, this);\r\n\t    }\r\n\r\n\t    if (breakLoop === null) return null;\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {String} type\r\n\t   * @return {?Node} First child node or `null` if nothing's been found.\r\n\t   */\r\n\r\n\t  Node.prototype.first = function first(type) {\r\n\t    if (!Array.isArray(this.content)) return null;\r\n\r\n\t    if (!type) return this.content[0];\r\n\r\n\t    var i = 0;\r\n\t    var l = this.content.length;\r\n\r\n\t    for (; i < l; i++) {\r\n\t      if (this.content[i].type === type) return this.content[i];\r\n\t    }\r\n\r\n\t    return null;\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {String} type Node type\r\n\t   * @param {Function} callback Function to call for every found node\r\n\t   */\r\n\r\n\t  Node.prototype.forEach = function forEach(type, callback) {\r\n\t    if (!Array.isArray(this.content)) return;\r\n\r\n\t    if (typeof type !== 'string') {\r\n\t      callback = type;\r\n\t      type = null;\r\n\t    }\r\n\r\n\t    var i = 0;\r\n\t    var l = this.content.length;\r\n\t    var breakLoop;\r\n\r\n\t    for (; i < l; i++) {\r\n\t      if (breakLoop === null) break;\r\n\r\n\t      if (!type || this.content[i] && this.content[i].type === type) breakLoop = callback(this.content[i], i, this);\r\n\t    }\r\n\r\n\t    if (breakLoop === null) return null;\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {Number} index\r\n\t   * @return {?Node}\r\n\t   */\r\n\r\n\t  Node.prototype.get = function get(index) {\r\n\t    if (!Array.isArray(this.content)) return null;\r\n\r\n\t    var node = this.content[index];\r\n\t    return node ? node : null;\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {Number} index\r\n\t   * @param {Node} node\r\n\t   */\r\n\r\n\t  Node.prototype.insert = function insert(index, node) {\r\n\t    if (!Array.isArray(this.content)) return;\r\n\r\n\t    this.content.splice(index, 0, node);\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {String} type\r\n\t   * @return {Boolean} Whether the node is of given type\r\n\t   */\r\n\r\n\t  Node.prototype.is = function is(type) {\r\n\t    return this.type === type;\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {String} type\r\n\t   * @return {?Node} Last child node or `null` if nothing's been found.\r\n\t   */\r\n\r\n\t  Node.prototype.last = function last(type) {\r\n\t    if (!Array.isArray(this.content)) return null;\r\n\r\n\t    var i = this.content.length;\r\n\t    if (!type) return this.content[i - 1];\r\n\r\n\t    for (; i--;) {\r\n\t      if (this.content[i].type === type) return this.content[i];\r\n\t    }\r\n\r\n\t    return null;\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Number of child nodes.\r\n\t   * @type {number}\r\n\t   */\r\n\r\n\t  /**\r\n\t   * @param {Number} index\r\n\t   * @return {Node}\r\n\t   */\r\n\r\n\t  Node.prototype.removeChild = function removeChild(index) {\r\n\t    if (!Array.isArray(this.content)) return;\r\n\r\n\t    var removedChild = this.content.splice(index, 1);\r\n\r\n\t    return removedChild;\r\n\t  };\r\n\r\n\t  Node.prototype.toJson = function toJson() {\r\n\t    return JSON.stringify(this, false, 2);\r\n\t  };\r\n\r\n\t  Node.prototype.toString = function toString() {\r\n\t    var stringify = undefined;\r\n\r\n\t    try {\r\n\t      stringify = __nested_webpack_require_62009__(2)(\"./\" + this.syntax + '/stringify');\r\n\t    } catch (e) {\r\n\t      var message = 'Syntax \"' + this.syntax + '\" is not supported yet, sorry';\r\n\t      return console.error(message);\r\n\t    }\r\n\r\n\t    return stringify(this);\r\n\t  };\r\n\r\n\t  /**\r\n\t   * @param {Function} callback\r\n\t   */\r\n\r\n\t  Node.prototype.traverse = function traverse(callback, index) {\r\n\t    var level = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\r\n\t    var parent = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];\r\n\r\n\t    var breakLoop;\r\n\t    var x;\r\n\r\n\t    level++;\r\n\r\n\t    callback(this, index, parent, level);\r\n\r\n\t    if (!Array.isArray(this.content)) return;\r\n\r\n\t    for (var i = 0, l = this.content.length; i < l; i++) {\r\n\t      breakLoop = this.content[i].traverse(callback, i, level, this);\r\n\t      if (breakLoop === null) break;\r\n\r\n\t      // If some nodes were removed or added:\r\n\t      if (x = this.content.length - l) {\r\n\t        l += x;\r\n\t        i += x;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (breakLoop === null) return null;\r\n\t  };\r\n\r\n\t  Node.prototype.traverseByType = function traverseByType(type, callback) {\r\n\t    this.traverse(function (node) {\r\n\t      if (node.type === type) callback.apply(node, arguments);\r\n\t    });\r\n\t  };\r\n\r\n\t  Node.prototype.traverseByTypes = function traverseByTypes(types, callback) {\r\n\t    this.traverse(function (node) {\r\n\t      if (types.indexOf(node.type) !== -1) callback.apply(node, arguments);\r\n\t    });\r\n\t  };\r\n\r\n\t  _createClass(Node, [{\r\n\t    key: 'length',\r\n\t    get: function () {\r\n\t      if (!Array.isArray(this.content)) return 0;\r\n\t      return this.content.length;\r\n\t    }\r\n\t  }]);\r\n\r\n\t  return Node;\r\n\t})();\r\n\r\n\tmodule.exports = Node;\r\n\r\n/***/ },\r\n/* 2 */\r\n/***/ function(module, exports, __nested_webpack_require_68735__) {\r\n\r\n\tvar map = {\r\n\t\t\"./css/stringify\": 3,\r\n\t\t\"./less/stringify\": 4,\r\n\t\t\"./sass/stringify\": 5,\r\n\t\t\"./scss/stringify\": 6\r\n\t};\r\n\tfunction webpackContext(req) {\r\n\t\treturn __nested_webpack_require_68735__(webpackContextResolve(req));\r\n\t};\r\n\tfunction webpackContextResolve(req) {\r\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\r\n\t};\r\n\twebpackContext.keys = function webpackContextKeys() {\r\n\t\treturn Object.keys(map);\r\n\t};\r\n\twebpackContext.resolve = webpackContextResolve;\r\n\tmodule.exports = webpackContext;\r\n\twebpackContext.id = 2;\r\n\r\n\r\n/***/ },\r\n/* 3 */\r\n/***/ function(module, exports) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function stringify(tree) {\r\n\t  // TODO: Better error message\r\n\t  if (!tree) throw new Error('We need tree to translate');\r\n\r\n\t  function _t(tree) {\r\n\t    var type = tree.type;\r\n\t    if (_unique[type]) return _unique[type](tree);\r\n\t    if (typeof tree.content === 'string') return tree.content;\r\n\t    if (Array.isArray(tree.content)) return _composite(tree.content);\r\n\t    return '';\r\n\t  }\r\n\r\n\t  function _composite(t, i) {\r\n\t    if (!t) return '';\r\n\r\n\t    var s = '';\r\n\t    i = i || 0;\r\n\t    for (; i < t.length; i++) s += _t(t[i]);\r\n\t    return s;\r\n\t  }\r\n\r\n\t  var _unique = {\r\n\t    'arguments': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'atkeyword': function (t) {\r\n\t      return '@' + _composite(t.content);\r\n\t    },\r\n\t    'attributeSelector': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'block': function (t) {\r\n\t      return '{' + _composite(t.content) + '}';\r\n\t    },\r\n\t    'brackets': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'class': function (t) {\r\n\t      return '.' + _composite(t.content);\r\n\t    },\r\n\t    'color': function (t) {\r\n\t      return '#' + t.content;\r\n\t    },\r\n\t    'expression': function (t) {\r\n\t      return 'expression(' + t.content + ')';\r\n\t    },\r\n\t    'id': function (t) {\r\n\t      return '#' + _composite(t.content);\r\n\t    },\r\n\t    'multilineComment': function (t) {\r\n\t      return '/*' + t.content + '*/';\r\n\t    },\r\n\t    'nthSelector': function (t) {\r\n\t      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';\r\n\t    },\r\n\t    'parentheses': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'percentage': function (t) {\r\n\t      return _composite(t.content) + '%';\r\n\t    },\r\n\t    'pseudoClass': function (t) {\r\n\t      return ':' + _composite(t.content);\r\n\t    },\r\n\t    'pseudoElement': function (t) {\r\n\t      return '::' + _composite(t.content);\r\n\t    },\r\n\t    'uri': function (t) {\r\n\t      return 'url(' + _composite(t.content) + ')';\r\n\t    }\r\n\t  };\r\n\r\n\t  return _t(tree);\r\n\t};\r\n\r\n/***/ },\r\n/* 4 */\r\n/***/ function(module, exports) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function stringify(tree) {\r\n\t  // TODO: Better error message\r\n\t  if (!tree) throw new Error('We need tree to translate');\r\n\r\n\t  function _t(tree) {\r\n\t    var type = tree.type;\r\n\t    if (_unique[type]) return _unique[type](tree);\r\n\t    if (typeof tree.content === 'string') return tree.content;\r\n\t    if (Array.isArray(tree.content)) return _composite(tree.content);\r\n\t    return '';\r\n\t  }\r\n\r\n\t  function _composite(t, i) {\r\n\t    if (!t) return '';\r\n\r\n\t    var s = '';\r\n\t    i = i || 0;\r\n\t    for (; i < t.length; i++) s += _t(t[i]);\r\n\t    return s;\r\n\t  }\r\n\r\n\t  var _unique = {\r\n\t    'arguments': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'atkeyword': function (t) {\r\n\t      return '@' + _composite(t.content);\r\n\t    },\r\n\t    'attributeSelector': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'block': function (t) {\r\n\t      return '{' + _composite(t.content) + '}';\r\n\t    },\r\n\t    'brackets': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'class': function (t) {\r\n\t      return '.' + _composite(t.content);\r\n\t    },\r\n\t    'color': function (t) {\r\n\t      return '#' + t.content;\r\n\t    },\r\n\t    'escapedString': function (t) {\r\n\t      return '~' + t.content;\r\n\t    },\r\n\t    'expression': function (t) {\r\n\t      return 'expression(' + t.content + ')';\r\n\t    },\r\n\t    'id': function (t) {\r\n\t      return '#' + _composite(t.content);\r\n\t    },\r\n\t    'interpolatedVariable': function (t) {\r\n\t      return '@{' + _composite(t.content) + '}';\r\n\t    },\r\n\t    'multilineComment': function (t) {\r\n\t      return '/*' + t.content + '*/';\r\n\t    },\r\n\t    'nthSelector': function (t) {\r\n\t      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';\r\n\t    },\r\n\t    'parentheses': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'percentage': function (t) {\r\n\t      return _composite(t.content) + '%';\r\n\t    },\r\n\t    'pseudoClass': function (t) {\r\n\t      return ':' + _composite(t.content);\r\n\t    },\r\n\t    'pseudoElement': function (t) {\r\n\t      return '::' + _composite(t.content);\r\n\t    },\r\n\t    'singlelineComment': function (t) {\r\n\t      return '/' + '/' + t.content;\r\n\t    },\r\n\t    'uri': function (t) {\r\n\t      return 'url(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'variable': function (t) {\r\n\t      return '@' + _composite(t.content);\r\n\t    },\r\n\t    'variablesList': function (t) {\r\n\t      return _composite(t.content) + '...';\r\n\t    }\r\n\t  };\r\n\r\n\t  return _t(tree);\r\n\t};\r\n\r\n/***/ },\r\n/* 5 */\r\n/***/ function(module, exports) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function stringify(tree) {\r\n\t  // TODO: Better error message\r\n\t  if (!tree) throw new Error('We need tree to translate');\r\n\r\n\t  function _t(tree) {\r\n\t    var type = tree.type;\r\n\t    if (_unique[type]) return _unique[type](tree);\r\n\t    if (typeof tree.content === 'string') return tree.content;\r\n\t    if (Array.isArray(tree.content)) return _composite(tree.content);\r\n\t    return '';\r\n\t  }\r\n\r\n\t  function _composite(t, i) {\r\n\t    if (!t) return '';\r\n\r\n\t    var s = '';\r\n\t    i = i || 0;\r\n\t    for (; i < t.length; i++) s += _t(t[i]);\r\n\t    return s;\r\n\t  }\r\n\r\n\t  var _unique = {\r\n\t    'arguments': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'atkeyword': function (t) {\r\n\t      return '@' + _composite(t.content);\r\n\t    },\r\n\t    'attributeSelector': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'block': function (t) {\r\n\t      return _composite(t.content);\r\n\t    },\r\n\t    'brackets': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'class': function (t) {\r\n\t      return '.' + _composite(t.content);\r\n\t    },\r\n\t    'color': function (t) {\r\n\t      return '#' + t.content;\r\n\t    },\r\n\t    'expression': function (t) {\r\n\t      return 'expression(' + t.content + ')';\r\n\t    },\r\n\t    'id': function (t) {\r\n\t      return '#' + _composite(t.content);\r\n\t    },\r\n\t    'interpolation': function (t) {\r\n\t      return '#{' + _composite(t.content) + '}';\r\n\t    },\r\n\t    'multilineComment': function (t) {\r\n\t      return '/*' + t.content;\r\n\t    },\r\n\t    'nthSelector': function (t) {\r\n\t      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';\r\n\t    },\r\n\t    'parentheses': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'percentage': function (t) {\r\n\t      return _composite(t.content) + '%';\r\n\t    },\r\n\t    'placeholder': function (t) {\r\n\t      return '%' + _composite(t.content);\r\n\t    },\r\n\t    'pseudoClass': function (t) {\r\n\t      return ':' + _composite(t.content);\r\n\t    },\r\n\t    'pseudoElement': function (t) {\r\n\t      return '::' + _composite(t.content);\r\n\t    },\r\n\t    'singlelineComment': function (t) {\r\n\t      return '/' + '/' + t.content;\r\n\t    },\r\n\t    'uri': function (t) {\r\n\t      return 'url(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'variable': function (t) {\r\n\t      return '$' + _composite(t.content);\r\n\t    },\r\n\t    'variablesList': function (t) {\r\n\t      return _composite(t.content) + '...';\r\n\t    }\r\n\t  };\r\n\r\n\t  return _t(tree);\r\n\t};\r\n\r\n/***/ },\r\n/* 6 */\r\n/***/ function(module, exports) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function stringify(tree) {\r\n\t  // TODO: Better error message\r\n\t  if (!tree) throw new Error('We need tree to translate');\r\n\r\n\t  function _t(tree) {\r\n\t    var type = tree.type;\r\n\t    if (_unique[type]) return _unique[type](tree);\r\n\t    if (typeof tree.content === 'string') return tree.content;\r\n\t    if (Array.isArray(tree.content)) return _composite(tree.content);\r\n\t    return '';\r\n\t  }\r\n\r\n\t  function _composite(t, i) {\r\n\t    if (!t) return '';\r\n\r\n\t    var s = '';\r\n\t    i = i || 0;\r\n\t    for (; i < t.length; i++) s += _t(t[i]);\r\n\t    return s;\r\n\t  }\r\n\r\n\t  var _unique = {\r\n\t    'arguments': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'atkeyword': function (t) {\r\n\t      return '@' + _composite(t.content);\r\n\t    },\r\n\t    'attributeSelector': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'block': function (t) {\r\n\t      return '{' + _composite(t.content) + '}';\r\n\t    },\r\n\t    'brackets': function (t) {\r\n\t      return '[' + _composite(t.content) + ']';\r\n\t    },\r\n\t    'class': function (t) {\r\n\t      return '.' + _composite(t.content);\r\n\t    },\r\n\t    'color': function (t) {\r\n\t      return '#' + t.content;\r\n\t    },\r\n\t    'expression': function (t) {\r\n\t      return 'expression(' + t.content + ')';\r\n\t    },\r\n\t    'id': function (t) {\r\n\t      return '#' + _composite(t.content);\r\n\t    },\r\n\t    'interpolation': function (t) {\r\n\t      return '#{' + _composite(t.content) + '}';\r\n\t    },\r\n\t    'multilineComment': function (t) {\r\n\t      return '/*' + t.content + '*/';\r\n\t    },\r\n\t    'nthSelector': function (t) {\r\n\t      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';\r\n\t    },\r\n\t    'parentheses': function (t) {\r\n\t      return '(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'percentage': function (t) {\r\n\t      return _composite(t.content) + '%';\r\n\t    },\r\n\t    'placeholder': function (t) {\r\n\t      return '%' + _composite(t.content);\r\n\t    },\r\n\t    'pseudoClass': function (t) {\r\n\t      return ':' + _composite(t.content);\r\n\t    },\r\n\t    'pseudoElement': function (t) {\r\n\t      return '::' + _composite(t.content);\r\n\t    },\r\n\t    'singlelineComment': function (t) {\r\n\t      return '/' + '/' + t.content;\r\n\t    },\r\n\t    'uri': function (t) {\r\n\t      return 'url(' + _composite(t.content) + ')';\r\n\t    },\r\n\t    'variable': function (t) {\r\n\t      return '$' + _composite(t.content);\r\n\t    },\r\n\t    'variablesList': function (t) {\r\n\t      return _composite(t.content) + '...';\r\n\t    }\r\n\t  };\r\n\r\n\t  return _t(tree);\r\n\t};\r\n\r\n/***/ },\r\n/* 7 */\r\n/***/ function(module, exports, __nested_webpack_require_79384__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar ParsingError = __nested_webpack_require_79384__(8);\r\n\tvar syntaxes = __nested_webpack_require_79384__(10);\r\n\r\n\tvar isInteger = Number.isInteger || function (value) {\r\n\t  return typeof value === 'number' && Math.floor(value) === value;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {String} css\r\n\t * @param {Object} options\r\n\t * @return {Object} AST\r\n\t */\r\n\tfunction parser(css, options) {\r\n\t  if (typeof css !== 'string') throw new Error('Please, pass a string to parse');else if (!css) return __nested_webpack_require_79384__(29)();\r\n\r\n\t  var syntax = options && options.syntax || 'css';\r\n\t  var context = options && options.context || 'stylesheet';\r\n\t  var tabSize = options && options.tabSize;\r\n\t  if (!isInteger(tabSize) || tabSize < 1) tabSize = 1;\r\n\r\n\t  var syntaxParser = syntaxes[syntax];\r\n\r\n\t  if (!syntaxParser) {\r\n\t    var message = 'Syntax \"' + syntax + '\" is not supported yet, sorry';\r\n\t    return console.error(message);\r\n\t  }\r\n\r\n\t  var getTokens = syntaxParser.tokenizer;\r\n\t  var mark = syntaxParser.mark;\r\n\t  var parse = syntaxParser.parse;\r\n\r\n\t  var tokens = getTokens(css, tabSize);\r\n\t  mark(tokens);\r\n\r\n\t  var ast;\r\n\t  try {\r\n\t    ast = parse(tokens, context);\r\n\t  } catch (e) {\r\n\t    if (!e.syntax) throw e;\r\n\t    throw new ParsingError(e, css);\r\n\t  }\r\n\r\n\t  return ast;\r\n\t}\r\n\r\n\tmodule.exports = parser;\r\n\r\n/***/ },\r\n/* 8 */\r\n/***/ function(module, exports, __nested_webpack_require_80751__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar parserPackage = __nested_webpack_require_80751__(9);\r\n\r\n\t/**\r\n\t * @param {Error} e\r\n\t * @param {String} css\r\n\t */\r\n\tfunction ParsingError(e, css) {\r\n\t  this.line = e.line;\r\n\t  this.syntax = e.syntax;\r\n\t  this.css_ = css;\r\n\t}\r\n\r\n\tParsingError.prototype = Object.defineProperties({\r\n\t  /**\r\n\t   * @type {String}\r\n\t   * @private\r\n\t   */\r\n\t  customMessage_: '',\r\n\r\n\t  /**\r\n\t   * @type {Number}\r\n\t   */\r\n\t  line: null,\r\n\r\n\t  /**\r\n\t   * @type {String}\r\n\t   */\r\n\t  name: 'Parsing error',\r\n\r\n\t  /**\r\n\t   * @type {String}\r\n\t   */\r\n\t  syntax: null,\r\n\r\n\t  /**\r\n\t   * @type {String}\r\n\t   */\r\n\t  version: parserPackage.version,\r\n\r\n\t  /**\r\n\t   * @return {String}\r\n\t   */\r\n\t  toString: function () {\r\n\t    return [this.name + ': ' + this.message, '', this.context, '', 'Syntax: ' + this.syntax, 'Gonzales PE version: ' + this.version].join('\\n');\r\n\t  }\r\n\t}, {\r\n\t  context: { /**\r\n\t              * @type {String}\r\n\t              */\r\n\r\n\t    get: function () {\r\n\t      var LINES_AROUND = 2;\r\n\r\n\t      var result = [];\r\n\t      var currentLineNumber = this.line;\r\n\t      var start = currentLineNumber - 1 - LINES_AROUND;\r\n\t      var end = currentLineNumber + LINES_AROUND;\r\n\t      var lines = this.css_.split(/\\r\\n|\\r|\\n/);\r\n\r\n\t      for (var i = start; i < end; i++) {\r\n\t        var line = lines[i];\r\n\t        if (!line) continue;\r\n\t        var ln = i + 1;\r\n\t        var mark = ln === currentLineNumber ? '*' : ' ';\r\n\t        result.push(ln + mark + '| ' + line);\r\n\t      }\r\n\r\n\t      return result.join('\\n');\r\n\t    },\r\n\t    configurable: true,\r\n\t    enumerable: true\r\n\t  },\r\n\t  message: {\r\n\r\n\t    /**\r\n\t     * @type {String}\r\n\t     */\r\n\r\n\t    get: function () {\r\n\t      if (this.customMessage_) {\r\n\t        return this.customMessage_;\r\n\t      } else {\r\n\t        var message = 'Please check validity of the block';\r\n\t        if (typeof this.line === 'number') message += ' starting from line #' + this.line;\r\n\t        return message;\r\n\t      }\r\n\t    },\r\n\t    set: function (message) {\r\n\t      this.customMessage_ = message;\r\n\t    },\r\n\t    configurable: true,\r\n\t    enumerable: true\r\n\t  }\r\n\t});\r\n\r\n\tmodule.exports = ParsingError;\r\n\r\n/***/ },\r\n/* 9 */\r\n/***/ function(module, exports) {\r\n\r\n\tmodule.exports = {\r\n\t\t\"name\": \"gonzales-pe\",\r\n\t\t\"description\": \"Gonzales Preprocessor Edition (fast CSS parser)\",\r\n\t\t\"version\": \"3.4.7\",\r\n\t\t\"homepage\": \"http://github.com/tonyganch/gonzales-pe\",\r\n\t\t\"bugs\": \"http://github.com/tonyganch/gonzales-pe/issues\",\r\n\t\t\"license\": \"MIT\",\r\n\t\t\"author\": {\r\n\t\t\t\"name\": \"Tony Ganch\",\r\n\t\t\t\"email\": \"tonyganch+github@gmail.com\",\r\n\t\t\t\"url\": \"http://tonyganch.com\"\r\n\t\t},\r\n\t\t\"main\": \"./lib/gonzales\",\r\n\t\t\"repository\": {\r\n\t\t\t\"type\": \"git\",\r\n\t\t\t\"url\": \"http://github.com/tonyganch/gonzales-pe.git\"\r\n\t\t},\r\n\t\t\"scripts\": {\r\n\t\t\t\"autofix-tests\": \"bash ./scripts/build.sh && bash ./scripts/autofix-tests.sh\",\r\n\t\t\t\"build\": \"bash ./scripts/build.sh\",\r\n\t\t\t\"init\": \"bash ./scripts/init.sh\",\r\n\t\t\t\"lint\": \"bash ./scripts/lint.sh\",\r\n\t\t\t\"log\": \"bash ./scripts/log.sh\",\r\n\t\t\t\"prepublish\": \"bash ./scripts/prepublish.sh\",\r\n\t\t\t\"postpublish\": \"bash ./scripts/postpublish.sh\",\r\n\t\t\t\"test\": \"bash ./scripts/test.sh\",\r\n\t\t\t\"watch\": \"bash ./scripts/watch.sh\"\r\n\t\t},\r\n\t\t\"bin\": {\r\n\t\t\t\"gonzales\": \"./bin/gonzales.js\"\r\n\t\t},\r\n\t\t\"dependencies\": {\r\n\t\t\t\"minimist\": \"1.1.x\"\r\n\t\t},\r\n\t\t\"devDependencies\": {\r\n\t\t\t\"babel-loader\": \"^5.3.2\",\r\n\t\t\t\"coffee-script\": \"~1.7.1\",\r\n\t\t\t\"eslint\": \"^3.0.0\",\r\n\t\t\t\"jscs\": \"2.1.0\",\r\n\t\t\t\"jshint\": \"2.8.0\",\r\n\t\t\t\"json-loader\": \"^0.5.3\",\r\n\t\t\t\"mocha\": \"2.2.x\",\r\n\t\t\t\"webpack\": \"^1.12.2\",\r\n\t\t\t\"webpack-closure-compiler\": \"^2.0.2\"\r\n\t\t},\r\n\t\t\"engines\": {\r\n\t\t\t\"node\": \">=0.6.0\"\r\n\t\t}\r\n\t};\r\n\r\n/***/ },\r\n/* 10 */\r\n/***/ function(module, exports, __nested_webpack_require_84409__) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = {\r\n\t  css: __nested_webpack_require_84409__(11),\r\n\t  less: __nested_webpack_require_84409__(17),\r\n\t  sass: __nested_webpack_require_84409__(21),\r\n\t  scss: __nested_webpack_require_84409__(25)\r\n\t};\r\n\r\n/***/ },\r\n/* 11 */\r\n/***/ function(module, exports, __nested_webpack_require_84671__) {\r\n\r\n\t'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports['default'] = {\r\n\t  mark: __nested_webpack_require_84671__(12),\r\n\t  parse: __nested_webpack_require_84671__(14),\r\n\t  stringify: __nested_webpack_require_84671__(3),\r\n\t  tokenizer: __nested_webpack_require_84671__(16)\r\n\t};\r\n\tmodule.exports = exports['default'];\r\n\r\n/***/ },\r\n/* 12 */\r\n/***/ function(module, exports, __nested_webpack_require_85016__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar TokenType = __nested_webpack_require_85016__(13);\r\n\r\n\t/**\r\n\t * Mark whitespaces and comments\r\n\t * @param {Array} tokens\r\n\t */\r\n\tfunction markSpacesAndComments(tokens) {\r\n\t  var tokensLength = tokens.length;\r\n\t  var spaces = [-1, -1];\r\n\t  var type; // Current token's type\r\n\r\n\t  // For every token in the token list, mark spaces and line breaks\r\n\t  // as spaces (set both `ws` and `sc` flags). Mark multiline comments\r\n\t  // with `sc` flag.\r\n\t  // If there are several spaces or tabs or line breaks or multiline\r\n\t  // comments in a row, group them: take the last one's index number\r\n\t  // and save it to the first token in the group as a reference:\r\n\t  // e.g., `ws_last = 7` for a group of whitespaces or `sc_last = 9`\r\n\t  // for a group of whitespaces and comments.\r\n\t  for (var i = 0; i < tokensLength; i++) {\r\n\t    type = tokens[i].type;\r\n\r\n\t    if (type === TokenType.Space || type === TokenType.Tab || type === TokenType.Newline) {\r\n\t      markSpace(tokens, i, spaces);\r\n\t    } else if (type === TokenType.CommentML) {\r\n\t      markComment(tokens, i, spaces);\r\n\t    } else {\r\n\t      markEndOfSpacesAndComments(tokens, i, spaces);\r\n\t    }\r\n\t  }\r\n\r\n\t  markEndOfSpacesAndComments(tokens, i, spaces);\r\n\t}\r\n\r\n\tfunction markSpace(tokens, i, spaces) {\r\n\t  var token = tokens[i];\r\n\t  token.ws = true;\r\n\t  token.sc = true;\r\n\r\n\t  if (spaces[0] === -1) spaces[0] = i;\r\n\t  if (spaces[1] === -1) spaces[1] = i;\r\n\t}\r\n\r\n\tfunction markComment(tokens, i, spaces) {\r\n\t  var ws = spaces[0];\r\n\t  tokens[i].sc = true;\r\n\r\n\t  if (ws !== -1) {\r\n\t    tokens[ws].ws_last = i - 1;\r\n\t    spaces[0] = -1;\r\n\t  }\r\n\t}\r\n\r\n\tfunction markEndOfSpacesAndComments(tokens, i, spaces) {\r\n\t  var ws = spaces[0];\r\n\t  var sc = spaces[1];\r\n\t  if (ws !== -1) {\r\n\t    tokens[ws].ws_last = i - 1;\r\n\t    spaces[0] = -1;\r\n\t  }\r\n\t  if (sc !== -1) {\r\n\t    tokens[sc].sc_last = i - 1;\r\n\t    spaces[1] = -1;\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Pair brackets\r\n\t * @param {Array} tokens\r\n\t */\r\n\tfunction markBrackets(tokens) {\r\n\t  var tokensLength = tokens.length;\r\n\t  var ps = []; // Parentheses\r\n\t  var sbs = []; // Square brackets\r\n\t  var cbs = []; // Curly brackets\r\n\t  var t = undefined; // Current token\r\n\r\n\t  // For every token in the token list, if we meet an opening (left)\r\n\t  // bracket, push its index number to a corresponding array.\r\n\t  // If we then meet a closing (right) bracket, look at the corresponding\r\n\t  // array. If there are any elements (records about previously met\r\n\t  // left brackets), take a token of the last left bracket (take\r\n\t  // the last index number from the array and find a token with\r\n\t  // this index number) and save right bracket's index as a reference:\r\n\t  for (var i = 0; i < tokensLength; i++) {\r\n\t    t = tokens[i];\r\n\t    var type = t.type;\r\n\r\n\t    if (type === TokenType.LeftParenthesis) {\r\n\t      ps.push(i);\r\n\t    } else if (type === TokenType.RightParenthesis) {\r\n\t      if (ps.length) {\r\n\t        t.left = ps.pop();\r\n\t        tokens[t.left].right = i;\r\n\t      }\r\n\t    } else if (type === TokenType.LeftSquareBracket) {\r\n\t      sbs.push(i);\r\n\t    } else if (type === TokenType.RightSquareBracket) {\r\n\t      if (sbs.length) {\r\n\t        t.left = sbs.pop();\r\n\t        tokens[t.left].right = i;\r\n\t      }\r\n\t    } else if (type === TokenType.LeftCurlyBracket) {\r\n\t      cbs.push(i);\r\n\t    } else if (type === TokenType.RightCurlyBracket) {\r\n\t      if (cbs.length) {\r\n\t        t.left = cbs.pop();\r\n\t        tokens[t.left].right = i;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Array} tokens\r\n\t */\r\n\tfunction markTokens(tokens) {\r\n\t  // Mark paired brackets:\r\n\t  markBrackets(tokens);\r\n\t  // Mark whitespaces and comments:\r\n\t  markSpacesAndComments(tokens);\r\n\t}\r\n\r\n\tmodule.exports = markTokens;\r\n\r\n/***/ },\r\n/* 13 */\r\n/***/ function(module, exports) {\r\n\r\n\t// jscs:disable\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = {\r\n\t    StringSQ: 'StringSQ',\r\n\t    StringDQ: 'StringDQ',\r\n\t    CommentML: 'CommentML',\r\n\t    CommentSL: 'CommentSL',\r\n\r\n\t    Newline: 'Newline',\r\n\t    Space: 'Space',\r\n\t    Tab: 'Tab',\r\n\r\n\t    ExclamationMark: 'ExclamationMark', // !\r\n\t    QuotationMark: 'QuotationMark', // \"\r\n\t    NumberSign: 'NumberSign', // #\r\n\t    DollarSign: 'DollarSign', // $\r\n\t    PercentSign: 'PercentSign', // %\r\n\t    Ampersand: 'Ampersand', // &\r\n\t    Apostrophe: 'Apostrophe', // '\r\n\t    LeftParenthesis: 'LeftParenthesis', // (\r\n\t    RightParenthesis: 'RightParenthesis', // )\r\n\t    Asterisk: 'Asterisk', // *\r\n\t    PlusSign: 'PlusSign', // +\r\n\t    Comma: 'Comma', // ,\r\n\t    HyphenMinus: 'HyphenMinus', // -\r\n\t    FullStop: 'FullStop', // .\r\n\t    Solidus: 'Solidus', // /\r\n\t    Colon: 'Colon', // :\r\n\t    Semicolon: 'Semicolon', // ;\r\n\t    LessThanSign: 'LessThanSign', // <\r\n\t    EqualsSign: 'EqualsSign', // =\r\n\t    EqualitySign: 'EqualitySign', // ==\r\n\t    InequalitySign: 'InequalitySign', // !=\r\n\t    GreaterThanSign: 'GreaterThanSign', // >\r\n\t    QuestionMark: 'QuestionMark', // ?\r\n\t    CommercialAt: 'CommercialAt', // @\r\n\t    LeftSquareBracket: 'LeftSquareBracket', // [\r\n\t    ReverseSolidus: 'ReverseSolidus', // \\\r\n\t    RightSquareBracket: 'RightSquareBracket', // ]\r\n\t    CircumflexAccent: 'CircumflexAccent', // ^\r\n\t    LowLine: 'LowLine', // _\r\n\t    LeftCurlyBracket: 'LeftCurlyBracket', // {\r\n\t    VerticalLine: 'VerticalLine', // |\r\n\t    RightCurlyBracket: 'RightCurlyBracket', // }\r\n\t    Tilde: 'Tilde', // ~\r\n\r\n\t    Identifier: 'Identifier',\r\n\t    DecimalNumber: 'DecimalNumber'\r\n\t};\r\n\r\n/***/ },\r\n/* 14 */\r\n/***/ function(module, exports, __nested_webpack_require_90491__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar Node = __nested_webpack_require_90491__(1);\r\n\tvar NodeType = __nested_webpack_require_90491__(15);\r\n\tvar TokenType = __nested_webpack_require_90491__(13);\r\n\r\n\t/**\r\n\t * @type {Array}\r\n\t */\r\n\tvar tokens;\r\n\r\n\t/**\r\n\t * @type {Number}\r\n\t */\r\n\tvar tokensLength;\r\n\r\n\t/**\r\n\t * @type {Number}\r\n\t */\r\n\tvar pos;\r\n\r\n\tvar contexts = {\r\n\t  'atkeyword': function () {\r\n\t    return checkAtkeyword(pos) && getAtkeyword();\r\n\t  },\r\n\t  'atrule': function () {\r\n\t    return checkAtrule(pos) && getAtrule();\r\n\t  },\r\n\t  'block': function () {\r\n\t    return checkBlock(pos) && getBlock();\r\n\t  },\r\n\t  'brackets': function () {\r\n\t    return checkBrackets(pos) && getBrackets();\r\n\t  },\r\n\t  'class': function () {\r\n\t    return checkClass(pos) && getClass();\r\n\t  },\r\n\t  'combinator': function () {\r\n\t    return checkCombinator(pos) && getCombinator();\r\n\t  },\r\n\t  'commentML': function () {\r\n\t    return checkCommentML(pos) && getCommentML();\r\n\t  },\r\n\t  'declaration': function () {\r\n\t    return checkDeclaration(pos) && getDeclaration();\r\n\t  },\r\n\t  'declDelim': function () {\r\n\t    return checkDeclDelim(pos) && getDeclDelim();\r\n\t  },\r\n\t  'delim': function () {\r\n\t    return checkDelim(pos) && getDelim();\r\n\t  },\r\n\t  'dimension': function () {\r\n\t    return checkDimension(pos) && getDimension();\r\n\t  },\r\n\t  'expression': function () {\r\n\t    return checkExpression(pos) && getExpression();\r\n\t  },\r\n\t  'function': function () {\r\n\t    return checkFunction(pos) && getFunction();\r\n\t  },\r\n\t  'ident': function () {\r\n\t    return checkIdent(pos) && getIdent();\r\n\t  },\r\n\t  'important': function () {\r\n\t    return checkImportant(pos) && getImportant();\r\n\t  },\r\n\t  'namespace': function () {\r\n\t    return checkNamespace(pos) && getNamespace();\r\n\t  },\r\n\t  'number': function () {\r\n\t    return checkNumber(pos) && getNumber();\r\n\t  },\r\n\t  'operator': function () {\r\n\t    return checkOperator(pos) && getOperator();\r\n\t  },\r\n\t  'parentheses': function () {\r\n\t    return checkParentheses(pos) && getParentheses();\r\n\t  },\r\n\t  'percentage': function () {\r\n\t    return checkPercentage(pos) && getPercentage();\r\n\t  },\r\n\t  'progid': function () {\r\n\t    return checkProgid(pos) && getProgid();\r\n\t  },\r\n\t  'property': function () {\r\n\t    return checkProperty(pos) && getProperty();\r\n\t  },\r\n\t  'propertyDelim': function () {\r\n\t    return checkPropertyDelim(pos) && getPropertyDelim();\r\n\t  },\r\n\t  'pseudoc': function () {\r\n\t    return checkPseudoc(pos) && getPseudoc();\r\n\t  },\r\n\t  'pseudoe': function () {\r\n\t    return checkPseudoe(pos) && getPseudoe();\r\n\t  },\r\n\t  'ruleset': function () {\r\n\t    return checkRuleset(pos) && getRuleset();\r\n\t  },\r\n\t  's': function () {\r\n\t    return checkS(pos) && getS();\r\n\t  },\r\n\t  'selector': function () {\r\n\t    return checkSelector(pos) && getSelector();\r\n\t  },\r\n\t  'shash': function () {\r\n\t    return checkShash(pos) && getShash();\r\n\t  },\r\n\t  'string': function () {\r\n\t    return checkString(pos) && getString();\r\n\t  },\r\n\t  'stylesheet': function () {\r\n\t    return checkStylesheet(pos) && getStylesheet();\r\n\t  },\r\n\t  'unary': function () {\r\n\t    return checkUnary(pos) && getUnary();\r\n\t  },\r\n\t  'unicodeRange': function () {\r\n\t    return checkUnicodeRange(pos) && getUnicodeRange();\r\n\t  },\r\n\t  'urange': function () {\r\n\t    return checkUrange(pos) && getUrange();\r\n\t  },\r\n\t  'uri': function () {\r\n\t    return checkUri(pos) && getUri();\r\n\t  },\r\n\t  'value': function () {\r\n\t    return checkValue(pos) && getValue();\r\n\t  },\r\n\t  'vhash': function () {\r\n\t    return checkVhash(pos) && getVhash();\r\n\t  }\r\n\t};\r\n\r\n\t/**\r\n\t * Stop parsing and display error.\r\n\t * @param {Number=} i Token's index number\r\n\t */\r\n\tfunction throwError(i) {\r\n\t  var ln = tokens[i].ln;\r\n\r\n\t  throw { line: ln, syntax: 'css' };\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Object} exclude\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkExcluding(exclude, i) {\r\n\t  var start = i;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (exclude[tokens[i++].type]) break;\r\n\t  }\r\n\r\n\t  return i - start - 2;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} start\r\n\t * @param {Number} finish\r\n\t * @return {String}\r\n\t */\r\n\tfunction joinValues(start, finish) {\r\n\t  var s = '';\r\n\r\n\t  for (var i = start; i < finish + 1; i++) {\r\n\t    s += tokens[i].value;\r\n\t  }\r\n\r\n\t  return s;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} start\r\n\t * @param {Number} num\r\n\t * @return {String}\r\n\t */\r\n\tfunction joinValues2(start, num) {\r\n\t  if (start + num - 1 >= tokensLength) return;\r\n\r\n\t  var s = '';\r\n\r\n\t  for (var i = 0; i < num; i++) {\r\n\t    s += tokens[start + i].value;\r\n\t  }\r\n\r\n\t  return s;\r\n\t}\r\n\r\n\tfunction getLastPosition(content, line, column, colOffset) {\r\n\t  return typeof content === 'string' ? getLastPositionForString(content, line, column, colOffset) : getLastPositionForArray(content, line, column, colOffset);\r\n\t}\r\n\r\n\tfunction getLastPositionForString(content, line, column, colOffset) {\r\n\t  var position = [];\r\n\r\n\t  if (!content) {\r\n\t    position = [line, column];\r\n\t    if (colOffset) position[1] += colOffset - 1;\r\n\t    return position;\r\n\t  }\r\n\r\n\t  var lastLinebreak = content.lastIndexOf('\\n');\r\n\t  var endsWithLinebreak = lastLinebreak === content.length - 1;\r\n\t  var splitContent = content.split('\\n');\r\n\t  var linebreaksCount = splitContent.length - 1;\r\n\t  var prevLinebreak = linebreaksCount === 0 || linebreaksCount === 1 ? -1 : content.length - splitContent[linebreaksCount - 1].length - 2;\r\n\r\n\t  // Line:\r\n\t  var offset = endsWithLinebreak ? linebreaksCount - 1 : linebreaksCount;\r\n\t  position[0] = line + offset;\r\n\r\n\t  // Column:\r\n\t  if (endsWithLinebreak) {\r\n\t    offset = prevLinebreak !== -1 ? content.length - prevLinebreak : content.length - 1;\r\n\t  } else {\r\n\t    offset = linebreaksCount !== 0 ? content.length - lastLinebreak - column - 1 : content.length - 1;\r\n\t  }\r\n\t  position[1] = column + offset;\r\n\r\n\t  if (!colOffset) return position;\r\n\r\n\t  if (endsWithLinebreak) {\r\n\t    position[0]++;\r\n\t    position[1] = colOffset;\r\n\t  } else {\r\n\t    position[1] += colOffset;\r\n\t  }\r\n\r\n\t  return position;\r\n\t}\r\n\r\n\tfunction getLastPositionForArray(content, line, column, colOffset) {\r\n\t  var position;\r\n\r\n\t  if (content.length === 0) {\r\n\t    position = [line, column];\r\n\t  } else {\r\n\t    var c = content[content.length - 1];\r\n\t    if (c.hasOwnProperty('end')) {\r\n\t      position = [c.end.line, c.end.column];\r\n\t    } else {\r\n\t      position = getLastPosition(c.content, line, column);\r\n\t    }\r\n\t  }\r\n\r\n\t  if (!colOffset) return position;\r\n\r\n\t  if (tokens[pos - 1].type !== 'Newline') {\r\n\t    position[1] += colOffset;\r\n\t  } else {\r\n\t    position[0]++;\r\n\t    position[1] = 1;\r\n\t  }\r\n\r\n\t  return position;\r\n\t}\r\n\r\n\tfunction newNode(type, content, line, column, end) {\r\n\t  if (!end) end = getLastPosition(content, line, column);\r\n\t  return new Node({\r\n\t    type: type,\r\n\t    content: content,\r\n\t    start: {\r\n\t      line: line,\r\n\t      column: column\r\n\t    },\r\n\t    end: {\r\n\t      line: end[0],\r\n\t      column: end[1]\r\n\t    },\r\n\t    syntax: 'css'\r\n\t  });\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkAny(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkBrackets(i)) tokens[i].any_child = 1;else if (l = checkParentheses(i)) tokens[i].any_child = 2;else if (l = checkString(i)) tokens[i].any_child = 3;else if (l = checkPercentage(i)) tokens[i].any_child = 4;else if (l = checkDimension(i)) tokens[i].any_child = 5;else if (l = checkUnicodeRange(i)) tokens[i].any_child = 13;else if (l = checkNumber(i)) tokens[i].any_child = 6;else if (l = checkUri(i)) tokens[i].any_child = 7;else if (l = checkExpression(i)) tokens[i].any_child = 8;else if (l = checkFunction(i)) tokens[i].any_child = 9;else if (l = checkIdent(i)) tokens[i].any_child = 10;else if (l = checkClass(i)) tokens[i].any_child = 11;else if (l = checkUnary(i)) tokens[i].any_child = 12;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getAny() {\r\n\t  var childType = tokens[pos].any_child;\r\n\r\n\t  if (childType === 1) return getBrackets();else if (childType === 2) return getParentheses();else if (childType === 3) return getString();else if (childType === 4) return getPercentage();else if (childType === 5) return getDimension();else if (childType === 13) return getUnicodeRange();else if (childType === 6) return getNumber();else if (childType === 7) return getUri();else if (childType === 8) return getExpression();else if (childType === 9) return getFunction();else if (childType === 10) return getIdent();else if (childType === 11) return getClass();else if (childType === 12) return getUnary();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an @-word (e.g. `@import`, `@include`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkAtkeyword(i) {\r\n\t  var l;\r\n\r\n\t  // Check that token is `@`:\r\n\t  if (i >= tokensLength || tokens[i++].type !== TokenType.CommercialAt) return 0;\r\n\r\n\t  return (l = checkIdent(i)) ? l + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with @-word\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getAtkeyword() {\r\n\t  var type = NodeType.AtkeywordType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  pos++;\r\n\r\n\t  content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a part of an @-rule\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of @-rule\r\n\t */\r\n\tfunction checkAtrule(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  // If token already has a record of being part of an @-rule,\r\n\t  // return the @-rule's length:\r\n\t  if (tokens[i].atrule_l !== undefined) return tokens[i].atrule_l;\r\n\r\n\t  // If token is part of an @-rule, save the rule's type to token.\r\n\t  // @keyframes:\r\n\t  if (l = checkKeyframesRule(i)) tokens[i].atrule_type = 4;\r\n\t  // @-rule with ruleset:\r\n\t  else if (l = checkAtruler(i)) tokens[i].atrule_type = 1;\r\n\t    // Block @-rule:\r\n\t    else if (l = checkAtruleb(i)) tokens[i].atrule_type = 2;\r\n\t      // Single-line @-rule:\r\n\t      else if (l = checkAtrules(i)) tokens[i].atrule_type = 3;else return 0;\r\n\r\n\t  // If token is part of an @-rule, save the rule's length to token:\r\n\t  tokens[i].atrule_l = l;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with @-rule\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getAtrule() {\r\n\t  switch (tokens[pos].atrule_type) {\r\n\t    case 1:\r\n\t      return getAtruler(); // @-rule with ruleset\r\n\t    case 2:\r\n\t      return getAtruleb(); // Block @-rule\r\n\t    case 3:\r\n\t      return getAtrules(); // Single-line @-rule\r\n\t    case 4:\r\n\t      return getKeyframesRule();\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a block @-rule\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the @-rule\r\n\t */\r\n\tfunction checkAtruleb(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkTsets(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a block @-rule\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getAtruleb() {\r\n\t  var type = NodeType.AtruleType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getAtkeyword()].concat(getTsets()).concat([getBlock()]);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an @-rule with ruleset\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the @-rule\r\n\t */\r\n\tfunction checkAtruler(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkTsets(i)) i += l;\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket) i++;else return 0;\r\n\r\n\t  if (l = checkAtrulers(i)) i += l;\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an @-rule with ruleset\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getAtruler() {\r\n\t  var type = NodeType.AtruleType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getAtkeyword()];\r\n\r\n\t  content = content.concat(getTsets());\r\n\r\n\t  content.push(getAtrulers());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkAtrulers(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkSC(i)) tokens[i].atrulers_child = 1;else if (l = checkAtrule(i)) tokens[i].atrulers_child = 2;else if (l = checkRuleset(i)) tokens[i].atrulers_child = 3;else break;\r\n\t    i += l;\r\n\t  }\r\n\r\n\t  tokens[i].atrulers_end = 1;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getAtrulers() {\r\n\t  var type = NodeType.BlockType;\r\n\t  var token = tokens[pos++];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = getSC();\r\n\r\n\t  while (!tokens[pos].atrulers_end) {\r\n\t    var childType = tokens[pos].atrulers_child;\r\n\t    if (childType === 1) content = content.concat(getSC());else if (childType === 2) content.push(getAtrule());else if (childType === 3) content.push(getRuleset());\r\n\t  }\r\n\r\n\t  content = content.concat(getSC());\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkAtrules(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkTsets(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getAtrules() {\r\n\t  var type = NodeType.AtruleType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getAtkeyword()].concat(getTsets());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a block (e.g. `{...}`).\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the block\r\n\t */\r\n\tfunction checkBlock(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket ? tokens[i].right - i + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a block\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getBlock() {\r\n\t  var type = NodeType.BlockType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var end = tokens[pos++].right;\r\n\t  var content = [];\r\n\r\n\t  while (pos < end) {\r\n\t    if (checkBlockdecl(pos)) content = content.concat(getBlockdecl());else throwError(pos);\r\n\t  }\r\n\r\n\t  var end_ = getLastPosition(content, line, column, 1);\r\n\t  pos = end + 1;\r\n\r\n\t  return newNode(type, content, line, column, end_);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the declaration\r\n\t */\r\n\tfunction checkBlockdecl(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkBlockdecl1(i)) tokens[i].bd_type = 1;else if (l = checkBlockdecl2(i)) tokens[i].bd_type = 2;else if (l = checkBlockdecl3(i)) tokens[i].bd_type = 3;else if (l = checkBlockdecl4(i)) tokens[i].bd_type = 4;else return 0;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getBlockdecl() {\r\n\t  switch (tokens[pos].bd_type) {\r\n\t    case 1:\r\n\t      return getBlockdecl1();\r\n\t    case 2:\r\n\t      return getBlockdecl2();\r\n\t    case 3:\r\n\t      return getBlockdecl3();\r\n\t    case 4:\r\n\t      return getBlockdecl4();\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkBlockdecl1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkDeclaration(i)) tokens[i].bd_kind = 1;else if (l = checkAtrule(i)) tokens[i].bd_kind = 2;else return 0;\r\n\r\n\t  i += l;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i < tokensLength && (l = checkDeclDelim(i))) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getBlockdecl1() {\r\n\t  var sc = getSC();\r\n\t  var x = undefined;\r\n\r\n\t  switch (tokens[pos].bd_kind) {\r\n\t    case 1:\r\n\t      x = getDeclaration();\r\n\t      break;\r\n\t    case 2:\r\n\t      x = getAtrule();\r\n\t      break;\r\n\t  }\r\n\r\n\t  return sc.concat([x]).concat(getSC()).concat([getDeclDelim()]).concat(getSC());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkBlockdecl2(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkDeclaration(i)) tokens[i].bd_kind = 1;else if (l = checkAtrule(i)) tokens[i].bd_kind = 2;else return 0;\r\n\r\n\t  i += l;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getBlockdecl2() {\r\n\t  var sc = getSC();\r\n\t  var x = undefined;\r\n\r\n\t  switch (tokens[pos].bd_kind) {\r\n\t    case 1:\r\n\t      x = getDeclaration();\r\n\t      break;\r\n\t    case 2:\r\n\t      x = getAtrule();\r\n\t      break;\r\n\t  }\r\n\r\n\t  return sc.concat([x]).concat(getSC());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkBlockdecl3(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkDeclDelim(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getBlockdecl3() {\r\n\t  return getSC().concat([getDeclDelim()]).concat(getSC());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkBlockdecl4(i) {\r\n\t  return checkSC(i);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getBlockdecl4() {\r\n\t  return getSC();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of text inside square brackets, e.g. `[1]`\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkBrackets(i) {\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftSquareBracket) return 0;\r\n\r\n\t  return tokens[i].right - i + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with text inside square brackets, e.g. `[1]`\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getBrackets() {\r\n\t  var type = NodeType.BracketsType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  pos++;\r\n\r\n\t  var tsets = getTsets();\r\n\t  var end = getLastPosition(tsets, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(type, tsets, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a class selector (e.g. `.abc`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the class selector\r\n\t */\r\n\tfunction checkClass(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].class_l) return tokens[i].class_l;\r\n\r\n\t  if (tokens[i++].type === TokenType.FullStop && (l = checkIdent(i))) {\r\n\t    tokens[i].class_l = l + 1;\r\n\t    return l + 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a class selector\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getClass() {\r\n\t  var type = NodeType.ClassType;\r\n\t  var token = tokens[pos++];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getIdent()];\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkCombinator(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkCombinator1(i)) tokens[i].combinatorType = 1;else if (l = checkCombinator2(i)) tokens[i].combinatorType = 2;else if (l = checkCombinator3(i)) tokens[i].combinatorType = 3;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getCombinator() {\r\n\t  var type = tokens[pos].combinatorType;\r\n\t  if (type === 1) return getCombinator1();\r\n\t  if (type === 2) return getCombinator2();\r\n\t  if (type === 3) return getCombinator3();\r\n\t}\r\n\t/**\r\n\t * (1) `||`\r\n\t */\r\n\tfunction checkCombinator1(i) {\r\n\t  if (tokens[i].type === TokenType.VerticalLine && tokens[i + 1].type === TokenType.VerticalLine) return 2;else return 0;\r\n\t}\r\n\r\n\tfunction getCombinator1() {\r\n\t  var type = NodeType.CombinatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '||';\r\n\r\n\t  pos += 2;\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `>`\r\n\t * (2) `+`\r\n\t * (3) `~`\r\n\t */\r\n\tfunction checkCombinator2(i) {\r\n\t  var type = tokens[i].type;\r\n\t  if (type === TokenType.PlusSign || type === TokenType.GreaterThanSign || type === TokenType.Tilde) return 1;else return 0;\r\n\t}\r\n\r\n\tfunction getCombinator2() {\r\n\t  var type = NodeType.CombinatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = tokens[pos++].value;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `/panda/`\r\n\t */\r\n\tfunction checkCombinator3(i) {\r\n\t  var start = i;\r\n\r\n\t  if (tokens[i].type === TokenType.Solidus) i++;else return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.Solidus) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getCombinator3() {\r\n\t  var type = NodeType.CombinatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  // Skip `/`.\r\n\t  pos++;\r\n\t  var ident = getIdent();\r\n\r\n\t  // Skip `/`.\r\n\t  pos++;\r\n\r\n\t  var content = '/' + ident.content + '/';\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a multiline comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is a multiline comment, otherwise `0`\r\n\t */\r\n\tfunction checkCommentML(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.CommentML ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a multiline comment\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getCommentML() {\r\n\t  var type = NodeType.CommentMLType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = tokens[pos].value.substring(2);\r\n\t  var l = content.length;\r\n\r\n\t  if (content.charAt(l - 2) === '*' && content.charAt(l - 1) === '/') content = content.substring(0, l - 2);\r\n\r\n\t  var end = getLastPosition(content, line, column, 2);\r\n\t  if (end[0] === line) end[1] += 2;\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the declaration\r\n\t */\r\n\tfunction checkDeclaration(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkProperty(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkPropertyDelim(i)) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkValue(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a declaration\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getDeclaration() {\r\n\t  var type = NodeType.DeclarationType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  var content = [getProperty()].concat(getSC()).concat([getPropertyDelim()]).concat(getSC()).concat([getValue()]);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a semicolon\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is a semicolon, otherwise `0`\r\n\t */\r\n\tfunction checkDeclDelim(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Semicolon ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a semicolon\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getDeclDelim() {\r\n\t  var type = NodeType.DeclDelimType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = ';';\r\n\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a comma\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is a comma, otherwise `0`\r\n\t */\r\n\tfunction checkDelim(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Comma ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a comma\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getDelim() {\r\n\t  var type = NodeType.DelimType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = ',';\r\n\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a number with dimension unit (e.g. `10px`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkDimension(i) {\r\n\t  var ln = checkNumber(i);\r\n\t  var li = undefined;\r\n\r\n\t  if (i >= tokensLength || !ln || i + ln >= tokensLength) return 0;\r\n\r\n\t  return (li = checkUnit(i + ln)) ? ln + li : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node of a number with dimension unit\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getDimension() {\r\n\t  var type = NodeType.DimensionType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getNumber(), getUnit()];\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is unit\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkUnit(i) {\r\n\t  var units = ['em', 'ex', 'ch', 'rem', 'vh', 'vw', 'vmin', 'vmax', 'px', 'mm', 'q', 'cm', 'in', 'pt', 'pc', 'deg', 'grad', 'rad', 'turn', 's', 'ms', 'Hz', 'kHz', 'dpi', 'dpcm', 'dppx'];\r\n\r\n\t  return units.indexOf(tokens[i].value) !== -1 ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get unit node of type ident\r\n\t * @return {Node} An ident node containing the unit value\r\n\t */\r\n\tfunction getUnit() {\r\n\t  var type = NodeType.IdentType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = token.value;\r\n\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkExpression(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].value !== 'expression' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  return tokens[i].right - start + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getExpression() {\r\n\t  var type = NodeType.ExpressionType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  pos++;\r\n\r\n\t  var content = joinValues(pos + 1, tokens[pos].right - 1);\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  if (end[0] === line) end[1] += 11;\r\n\t  pos = tokens[pos].right + 1;\r\n\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkFunction(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i < tokensLength && tokens[i].type === TokenType.LeftParenthesis ? tokens[i].right - start + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getFunction() {\r\n\t  var type = NodeType.FunctionType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var ident = getIdent();\r\n\t  var content = [ident];\r\n\r\n\t  content.push(getArguments());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getArguments() {\r\n\t  var type = NodeType.ArgumentsType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\t  var body = undefined;\r\n\r\n\t  pos++;\r\n\r\n\t  while (pos < tokensLength && tokens[pos].type !== TokenType.RightParenthesis) {\r\n\t    if (checkDeclaration(pos)) content.push(getDeclaration());else if (checkArgument(pos)) {\r\n\t      body = getArgument();\r\n\t      if (typeof body.content === 'string') content.push(body);else content = content.concat(body);\r\n\t    } else if (checkClass(pos)) content.push(getClass());else throwError(pos);\r\n\t  }\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkArgument(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkVhash(i)) tokens[i].argument_child = 1;else if (l = checkAny(i)) tokens[i].argument_child = 2;else if (l = checkSC(i)) tokens[i].argument_child = 3;else if (l = checkOperator(i)) tokens[i].argument_child = 4;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getArgument() {\r\n\t  var childType = tokens[pos].argument_child;\r\n\t  if (childType === 1) return getVhash();else if (childType === 2) return getAny();else if (childType === 3) return getSC();else if (childType === 4) return getOperator();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an identifier\r\n\t * Grammar from CSS spec:\r\n\t *   h         [0-9a-f]\r\n\t *   nonascii  [\\240-\\377]\r\n\t *   unicode   \\\\{h}{1,6}(\\r\\n|[ \\t\\r\\n\\f])?\r\n\t *   escape    {unicode}|\\\\[^\\r\\n\\f0-9a-f]\r\n\t *   nmstart   [_a-z]|{nonascii}|{escape}\r\n\t *   nmchar    [_a-z0-9-]|{nonascii}|{escape}\r\n\t *   ident     -?{nmstart}{nmchar}*\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the identifier\r\n\t */\r\n\tfunction checkIdent(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.HyphenMinus) i++;\r\n\r\n\t  if (tokens[i].type === TokenType.LowLine || tokens[i].type === TokenType.Identifier) i++;else return 0;\r\n\r\n\t  for (; i < tokensLength; i++) {\r\n\t    if (tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier && tokens[i].type !== TokenType.DecimalNumber) break;\r\n\t  }\r\n\r\n\t  tokens[start].ident_last = i - 1;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an identifier\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getIdent() {\r\n\t  var type = NodeType.IdentType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = joinValues(pos, tokens[pos].ident_last);\r\n\r\n\t  pos = tokens[pos].ident_last + 1;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of `!important` word\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkImportant(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].value === 'important') {\r\n\t    tokens[start].importantEnd = i;\r\n\t    return i - start + 1;\r\n\t  } else {\r\n\t    return 0;\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with `!important` word\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getImportant() {\r\n\t  var type = NodeType.ImportantType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = joinValues(pos, token.importantEnd);\r\n\r\n\t  pos = token.importantEnd + 1;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check a single keyframe block - `5% {}`\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkKeyframesBlock(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkKeyframesSelectorsGroup(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a single keyframe block - `5% {}`\r\n\t * @returns {Node}\r\n\t */\r\n\tfunction getKeyframesBlock() {\r\n\t  var type = NodeType.RulesetType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [].concat(getKeyframesSelectorsGroup(), getSC(), [getBlock()]);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check all keyframe blocks - `5% {} 100% {}`\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkKeyframesBlocks(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkKeyframesBlock(i)) i += l;else return 0;\r\n\r\n\t  while (tokens[i].type !== TokenType.RightCurlyBracket) {\r\n\t    if (l = checkSC(i)) i += l;else if (l = checkKeyframesBlock(i)) i += l;else break;\r\n\t  }\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get all keyframe blocks - `5% {} 100% {}`\r\n\t * @returns {Node}\r\n\t */\r\n\tfunction getKeyframesBlocks() {\r\n\t  var type = NodeType.BlockType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\t  var keyframesBlocksEnd = token.right;\r\n\r\n\t  // Skip `{`.\r\n\t  pos++;\r\n\r\n\t  while (pos < keyframesBlocksEnd) {\r\n\t    if (checkSC(pos)) content = content.concat(getSC());else if (checkKeyframesBlock(pos)) content.push(getKeyframesBlock());\r\n\t  }\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\r\n\t  // Skip `}`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a @keyframes rule.\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the @keyframes rule\r\n\t */\r\n\tfunction checkKeyframesRule(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  var atruleName = joinValues2(i - l, l);\r\n\t  if (atruleName.indexOf('keyframes') === -1) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkKeyframesBlocks(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getKeyframesRule() {\r\n\t  var type = NodeType.AtruleType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [].concat([getAtkeyword()], getSC(), [getIdent()], getSC(), [getKeyframesBlocks()]);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check a single keyframe selector - `5%`, `from` etc\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkKeyframesSelector(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) {\r\n\t    // Valid selectors are only `from` and `to`.\r\n\t    var selector = joinValues2(i, l);\r\n\t    if (selector !== 'from' && selector !== 'to') return 0;\r\n\r\n\t    i += l;\r\n\t    tokens[start].keyframesSelectorType = 1;\r\n\t  } else if (l = checkPercentage(i)) {\r\n\t    i += l;\r\n\t    tokens[start].keyframesSelectorType = 2;\r\n\t  } else {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a single keyframe selector\r\n\t * @returns {Node}\r\n\t */\r\n\tfunction getKeyframesSelector() {\r\n\t  var keyframesSelectorType = NodeType.KeyframesSelectorType;\r\n\t  var selectorType = NodeType.SelectorType;\r\n\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (token.keyframesSelectorType === 1) {\r\n\t    content.push(getIdent());\r\n\t  } else {\r\n\t    content.push(getPercentage());\r\n\t  }\r\n\r\n\t  var keyframesSelector = newNode(keyframesSelectorType, content, line, column);\r\n\t  return newNode(selectorType, [keyframesSelector], line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check the keyframe's selector groups\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkKeyframesSelectorsGroup(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkKeyframesSelector(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var sb = checkSC(i);\r\n\t    var c = checkDelim(i + sb);\r\n\t    if (!c) break;\r\n\t    var sa = checkSC(i + sb + c);\r\n\t    if (l = checkKeyframesSelector(i + sb + c + sa)) i += sb + c + sa + l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].selectorsGroupEnd = i;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the keyframe's selector groups\r\n\t * @returns {Array} An array of keyframe selectors\r\n\t */\r\n\tfunction getKeyframesSelectorsGroup() {\r\n\t  var selectorsGroup = [];\r\n\t  var selectorsGroupEnd = tokens[pos].selectorsGroupEnd;\r\n\r\n\t  selectorsGroup.push(getKeyframesSelector());\r\n\r\n\t  while (pos < selectorsGroupEnd) {\r\n\t    selectorsGroup = selectorsGroup.concat(getSC());\r\n\t    selectorsGroup.push(getDelim());\r\n\t    selectorsGroup = selectorsGroup.concat(getSC());\r\n\t    selectorsGroup.push(getKeyframesSelector());\r\n\t  }\r\n\r\n\t  return selectorsGroup;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a namespace sign (`|`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is `|`, `0` if not\r\n\t */\r\n\tfunction checkNamespace(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.VerticalLine ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a namespace sign\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getNamespace() {\r\n\t  var type = NodeType.NamespaceType;\r\n\t  var token = tokens[pos++];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '|';\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkNmName2(i) {\r\n\t  if (tokens[i].type === TokenType.Identifier) return 1;else if (tokens[i].type !== TokenType.DecimalNumber) return 0;\r\n\r\n\t  i++;\r\n\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Identifier ? 2 : 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {String}\r\n\t */\r\n\tfunction getNmName2() {\r\n\t  var s = tokens[pos].value;\r\n\r\n\t  if (tokens[pos++].type === TokenType.DecimalNumber && pos < tokensLength && tokens[pos].type === TokenType.Identifier) s += tokens[pos++].value;\r\n\r\n\t  return s;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a number\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of number\r\n\t */\r\n\tfunction checkNumber(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].number_l) return tokens[i].number_l;\r\n\r\n\t  // `10`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.DecimalNumber && (!tokens[i + 1] || tokens[i + 1] && tokens[i + 1].type !== TokenType.FullStop)) {\r\n\t    tokens[i].number_l = 1;\r\n\t    return 1;\r\n\t  }\r\n\r\n\t  // `10.`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && (!tokens[i + 2] || tokens[i + 2].type !== TokenType.DecimalNumber)) {\r\n\t    tokens[i].number_l = 2;\r\n\t    return 2;\r\n\t  }\r\n\r\n\t  // `.10`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.FullStop && tokens[i + 1].type === TokenType.DecimalNumber) {\r\n\t    tokens[i].number_l = 2;\r\n\t    return 2;\r\n\t  }\r\n\r\n\t  // `10.10`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && tokens[i + 2] && tokens[i + 2].type === TokenType.DecimalNumber) {\r\n\t    tokens[i].number_l = 3;\r\n\t    return 3;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with number\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getNumber() {\r\n\t  var type = NodeType.NumberType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '';\r\n\t  var l = tokens[pos].number_l;\r\n\r\n\t  for (var j = 0; j < l; j++) {\r\n\t    content += tokens[pos + j].value;\r\n\t  }\r\n\r\n\t  pos += l;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is an operator (`/`, `,`, `:` or `=`).\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is an operator, otherwise `0`\r\n\t */\r\n\tfunction checkOperator(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  switch (tokens[i].type) {\r\n\t    case TokenType.Solidus:\r\n\t    case TokenType.Comma:\r\n\t    case TokenType.Colon:\r\n\t    case TokenType.EqualsSign:\r\n\t      return 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an operator\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getOperator() {\r\n\t  var type = NodeType.OperatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = token.value;\r\n\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of text inside parentheses, e.g. `(1)`\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkParentheses(i) {\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  return tokens[i].right - i + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with text inside parentheses, e.g. `(1)`\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getParentheses() {\r\n\t  var type = NodeType.ParenthesesType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  pos++;\r\n\r\n\t  var tsets = getTsets();\r\n\t  var end = getLastPosition(tsets, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(type, tsets, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a number with percent sign (e.g. `10%`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkPercentage(i) {\r\n\t  var x;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  x = checkNumber(i);\r\n\r\n\t  if (!x || i + x >= tokensLength) return 0;\r\n\r\n\t  return tokens[i + x].type === TokenType.PercentSign ? x + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node of number with percent sign\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getPercentage() {\r\n\t  var type = NodeType.PercentageType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getNumber()];\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkProgid(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (joinValues2(i, 6) === 'progid:DXImageTransform.Microsoft.') i += 6;else return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.LeftParenthesis) {\r\n\t    tokens[start].progid_end = tokens[i].right;\r\n\t    i = tokens[i].right + 1;\r\n\t  } else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getProgid() {\r\n\t  var type = NodeType.ProgidType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var progid_end = token.progid_end;\r\n\t  var content = joinValues(pos, progid_end);\r\n\r\n\t  pos = progid_end + 1;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a property\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the property\r\n\t */\r\n\tfunction checkProperty(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a property\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getProperty() {\r\n\t  var type = NodeType.PropertyType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getIdent()];\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a colon\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is a colon, otherwise `0`\r\n\t */\r\n\tfunction checkPropertyDelim(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Colon ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a colon\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getPropertyDelim() {\r\n\t  var type = NodeType.PropertyDelimType;\r\n\t  var token = tokens[pos++];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = ':';\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkPseudo(i) {\r\n\t  return checkPseudoe(i) || checkPseudoc(i);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getPseudo() {\r\n\t  if (checkPseudoe(pos)) return getPseudoe();\r\n\t  if (checkPseudoc(pos)) return getPseudoc();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkPseudoe(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].type !== TokenType.Colon || i >= tokensLength || tokens[i++].type !== TokenType.Colon) return 0;\r\n\r\n\t  return (l = checkIdent(i)) ? l + 2 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getPseudoe() {\r\n\t  var type = NodeType.PseudoeType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  pos += 2;\r\n\r\n\t  content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkPseudoc(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.Colon) return 0;\r\n\r\n\t  if (l = checkPseudoClass1(i)) tokens[i].pseudoClassType = 1;else if (l = checkPseudoClass2(i)) tokens[i].pseudoClassType = 2;else if (l = checkPseudoClass3(i)) tokens[i].pseudoClassType = 3;else if (l = checkPseudoClass4(i)) tokens[i].pseudoClassType = 4;else if (l = checkPseudoClass5(i)) tokens[i].pseudoClassType = 5;else if (l = checkPseudoClass6(i)) tokens[i].pseudoClassType = 6;else return 0;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getPseudoc() {\r\n\t  var childType = tokens[pos].pseudoClassType;\r\n\t  if (childType === 1) return getPseudoClass1();\r\n\t  if (childType === 2) return getPseudoClass2();\r\n\t  if (childType === 3) return getPseudoClass3();\r\n\t  if (childType === 4) return getPseudoClass4();\r\n\t  if (childType === 5) return getPseudoClass5();\r\n\t  if (childType === 6) return getPseudoClass6();\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `:panda(selector)`\r\n\t * (2) `:panda(selector, selector)`\r\n\t */\r\n\tfunction checkPseudoClass1(i) {\r\n\t  var start = i;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSelectorsGroup(i)) i += l;else return 0;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:not(panda)`\r\n\t */\r\n\tfunction getPseudoClass1() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  content.push(getIdent());\r\n\r\n\t  {\r\n\t    var _type = NodeType.ArgumentsType;\r\n\t    var _token = tokens[pos];\r\n\t    var _line = _token.ln;\r\n\t    var _column = _token.col;\r\n\r\n\t    // Skip `(`.\r\n\t    pos++;\r\n\r\n\t    var selectors = getSelectorsGroup();\r\n\t    var end = getLastPosition(selectors, _line, _column, 1);\r\n\t    var args = newNode(_type, selectors, _line, _column, end);\r\n\t    content.push(args);\r\n\r\n\t    // Skip `)`.\r\n\t    pos++;\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `:nth-child(odd)`\r\n\t * (2) `:nth-child(even)`\r\n\t * (3) `:lang(de-DE)`\r\n\t */\r\n\tfunction checkPseudoClass2(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass2() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  // Skip `(`.\r\n\t  pos++;\r\n\r\n\t  var l = tokens[pos].ln;\r\n\t  var c = tokens[pos].col;\r\n\t  var value = [];\r\n\r\n\t  value = value.concat(getSC());\r\n\t  value.push(getIdent());\r\n\t  value = value.concat(getSC());\r\n\r\n\t  var end = getLastPosition(value, l, c, 1);\r\n\t  var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t  content.push(args);\r\n\r\n\t  // Skip `)`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:nth-child(-3n + 2)`\r\n\t */\r\n\tfunction checkPseudoClass3(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkUnary(i)) i += l;\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].value === 'n') i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].value === '+' || tokens[i].value === '-') i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass3() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  var l = tokens[pos].ln;\r\n\t  var c = tokens[pos].col;\r\n\t  var value = [];\r\n\r\n\t  // Skip `(`.\r\n\t  pos++;\r\n\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\r\n\t  {\r\n\t    var _l = tokens[pos].ln;\r\n\t    var _c = tokens[pos].col;\r\n\t    var _content = tokens[pos].value;\r\n\t    var _ident = newNode(NodeType.IdentType, _content, _l, _c);\r\n\t    value.push(_ident);\r\n\t    pos++;\r\n\t  }\r\n\r\n\t  value = value.concat(getSC());\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  value = value.concat(getSC());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\t  value = value.concat(getSC());\r\n\r\n\t  var end = getLastPosition(value, l, c, 1);\r\n\t  var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t  content.push(args);\r\n\r\n\t  // Skip `)`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:nth-child(-3n)`\r\n\t */\r\n\tfunction checkPseudoClass4(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkUnary(i)) i += l;\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;\r\n\r\n\t  if (tokens[i].value === 'n') i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass4() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  // Skip `(`.\r\n\t  pos++;\r\n\r\n\t  var l = tokens[pos].ln;\r\n\t  var c = tokens[pos].col;\r\n\t  var value = [];\r\n\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\t  if (checkIdent(pos)) value.push(getIdent());\r\n\t  value = value.concat(getSC());\r\n\r\n\t  var end = getLastPosition(value, l, c, 1);\r\n\t  var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t  content.push(args);\r\n\r\n\t  // Skip `)`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:nth-child(+8)`\r\n\t */\r\n\tfunction checkPseudoClass5(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkUnary(i)) i += l;\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass5() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  // Skip `(`.\r\n\t  pos++;\r\n\r\n\t  var l = tokens[pos].ln;\r\n\t  var c = tokens[pos].col;\r\n\t  var value = [];\r\n\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\t  value = value.concat(getSC());\r\n\r\n\t  var end = getLastPosition(value, l, c, 1);\r\n\t  var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t  content.push(args);\r\n\r\n\t  // Skip `)`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:checked`\r\n\t */\r\n\tfunction checkPseudoClass6(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getPseudoClass6() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkRuleset(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkSelectorsGroup(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getRuleset() {\r\n\t  var type = NodeType.RulesetType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  content = content.concat(getSelectorsGroup());\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getBlock());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is marked as a space (if it's a space or a tab\r\n\t *      or a line break).\r\n\t * @param {Number} i\r\n\t * @return {Number} Number of spaces in a row starting with the given token.\r\n\t */\r\n\tfunction checkS(i) {\r\n\t  return i < tokensLength && tokens[i].ws ? tokens[i].ws_last - i + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with spaces\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getS() {\r\n\t  var type = NodeType.SType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = joinValues(pos, tokens[pos].ws_last);\r\n\r\n\t  pos = tokens[pos].ws_last + 1;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a space or a comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Number of similar (space or comment) tokens\r\n\t *      in a row starting with the given token.\r\n\t */\r\n\tfunction checkSC(i) {\r\n\t  var l = undefined;\r\n\t  var lsc = 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkS(i)) tokens[i].sc_child = 1;else if (l = checkCommentML(i)) tokens[i].sc_child = 2;else break;\r\n\t    i += l;\r\n\t    lsc += l;\r\n\t  }\r\n\r\n\t  return lsc || 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with spaces and comments\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getSC() {\r\n\t  var sc = [];\r\n\r\n\t  if (pos >= tokensLength) return sc;\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    var childType = tokens[pos].sc_child;\r\n\t    if (childType === 1) sc.push(getS());else if (childType === 2) sc.push(getCommentML());else break;\r\n\t  }\r\n\r\n\t  return sc;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      a simple selector\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkShash(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.NumberSign) return 0;\r\n\r\n\t  return (l = checkIdent(i + 1)) ? l + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside a simple\r\n\t *      selector\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getShash() {\r\n\t  var type = NodeType.ShashType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a string (text wrapped in quotes)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is part of a string, `0` if not\r\n\t */\r\n\tfunction checkString(i) {\r\n\t  if (i >= tokensLength) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  if (tokens[i].type === TokenType.StringSQ || tokens[i].type === TokenType.StringDQ) {\r\n\t    return 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get string's node\r\n\t * @return {Array} `['string', x]` where `x` is a string (including\r\n\t *      quotes).\r\n\t */\r\n\tfunction getString() {\r\n\t  var type = NodeType.StringType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = token.value;\r\n\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Validate stylesheet: it should consist of any number (0 or more) of\r\n\t * rulesets (sets of rules with selectors), @-rules, whitespaces or\r\n\t * comments.\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkStylesheet(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  // Check every token:\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkSC(i)) tokens[i].stylesheet_child = 1;else if (l = checkRuleset(i)) tokens[i].stylesheet_child = 2;else if (l = checkAtrule(i)) tokens[i].stylesheet_child = 3;else if (l = checkDeclDelim(i)) tokens[i].stylesheet_child = 4;else throwError(i);\r\n\r\n\t    i += l;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array} `['stylesheet', x]` where `x` is all stylesheet's\r\n\t *      nodes.\r\n\t */\r\n\tfunction getStylesheet() {\r\n\t  var type = NodeType.StylesheetType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\t  var childType = undefined;\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    childType = tokens[pos].stylesheet_child;\r\n\t    if (childType === 1) content = content.concat(getSC());else if (childType === 2) content.push(getRuleset());else if (childType === 3) content.push(getAtrule());else if (childType === 4) content.push(getDeclDelim());\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkTset(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkVhash(i)) tokens[i].tset_child = 1;else if (l = checkAny(i)) tokens[i].tset_child = 2;else if (l = checkSC(i)) tokens[i].tset_child = 3;else if (l = checkOperator(i)) tokens[i].tset_child = 4;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getTset() {\r\n\t  var childType = tokens[pos].tset_child;\r\n\t  if (childType === 1) return getVhash();else if (childType === 2) return getAny();else if (childType === 3) return getSC();else if (childType === 4) return getOperator();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkTsets(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  while (l = checkTset(i)) {\r\n\t    i += l;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getTsets() {\r\n\t  var x = [];\r\n\t  var t = undefined;\r\n\r\n\t  while (checkTset(pos)) {\r\n\t    t = getTset();\r\n\t    if (typeof t.content === 'string') x.push(t);else x = x.concat(t);\r\n\t  }\r\n\r\n\t  return x;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is an unary (arithmetical) sign (`+` or `-`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} `1` if token is an unary sign, `0` if not\r\n\t */\r\n\tfunction checkUnary(i) {\r\n\t  if (i >= tokensLength) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  if (tokens[i].type === TokenType.HyphenMinus || tokens[i].type === TokenType.PlusSign) {\r\n\t    return 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an unary (arithmetical) sign (`+` or `-`)\r\n\t * @return {Array} `['unary', x]` where `x` is an unary sign\r\n\t *      converted to string.\r\n\t */\r\n\tfunction getUnary() {\r\n\t  var type = NodeType.OperatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = token.value;\r\n\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a unicode range (single or multiple <urange> nodes)\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Unicode range node's length\r\n\t */\r\n\tfunction checkUnicodeRange(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkUrange(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var spaceBefore = checkSC(i);\r\n\t    var comma = checkDelim(i + spaceBefore);\r\n\t    if (!comma) break;\r\n\r\n\t    var spaceAfter = checkSC(i + spaceBefore + comma);\r\n\t    if (l = checkUrange(i + spaceBefore + comma + spaceAfter)) {\r\n\t      i += spaceBefore + comma + spaceAfter + l;\r\n\t    } else break;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a unicode range node\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getUnicodeRange() {\r\n\t  var type = NodeType.UnicodeRangeType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    if (checkSC(pos)) content = content.concat(getSC());else if (checkDelim(pos)) content.push(getDelim());else if (checkUrange(pos)) content.push(getUrange());else break;\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a u-range (part of a unicode-range)\r\n\t * (1) `U+416`\r\n\t * (2) `U+400-4ff`\r\n\t * (3) `U+4??`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Urange node's length\r\n\t */\r\n\tfunction checkUrange(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  // Check for unicode prefix (u+ or U+)\r\n\t  if (tokens[i].value === 'U' || tokens[i].value === 'u') i += 1;else return 0;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].value === '+') i += 1;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkIdent(i)) i += l;else if (l = checkNumber(i)) i += l;else if (l = checkUnary(i)) i += l;else if (l = _checkUnicodeWildcard(i)) i += l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].urangeEnd = i - 1;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a u-range node (part of a unicode-range)\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getUrange() {\r\n\t  var startPos = pos;\r\n\t  var type = NodeType.UrangeType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  content = joinValues(startPos, tokens[startPos].urangeEnd);\r\n\t  pos = tokens[startPos].urangeEnd + 1;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check for unicode wildcard characters `?`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Wildcard length\r\n\t */\r\n\tfunction _checkUnicodeWildcard(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (tokens[i].type === TokenType.QuestionMark) i += 1;else break;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of URI (e.g. `url('/css/styles.css')`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of URI\r\n\t */\r\n\tfunction checkUri(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength || tokens[i].value !== 'url') return 0;\r\n\t  i += 1;\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  return tokens[i].right - start + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with URI\r\n\t * @return {Array} `['uri', x]` where `x` is URI's nodes (without `url`\r\n\t *      and braces, e.g. `['string', ''/css/styles.css'']`).\r\n\t */\r\n\tfunction getUri() {\r\n\t  var startPos = pos;\r\n\t  var uriExcluding = {};\r\n\t  var uri = undefined;\r\n\t  var l = undefined;\r\n\t  var raw = undefined;\r\n\r\n\t  var rawContent = undefined;\r\n\t  var t = undefined;\r\n\r\n\t  pos += 2;\r\n\r\n\t  uriExcluding[TokenType.Space] = 1;\r\n\t  uriExcluding[TokenType.Tab] = 1;\r\n\t  uriExcluding[TokenType.Newline] = 1;\r\n\t  uriExcluding[TokenType.LeftParenthesis] = 1;\r\n\t  uriExcluding[TokenType.RightParenthesis] = 1;\r\n\r\n\t  if (checkUri1(pos)) {\r\n\t    uri = [].concat(getSC()).concat([getString()]).concat(getSC());\r\n\t  } else {\r\n\t    uri = checkSC(pos) ? getSC() : [];\r\n\t    l = checkExcluding(uriExcluding, pos);\r\n\t    rawContent = joinValues(pos, pos + l);\r\n\t    t = tokens[pos];\r\n\t    raw = newNode(NodeType.RawType, rawContent, t.ln, t.col);\r\n\r\n\t    uri.push(raw);\r\n\r\n\t    pos += l + 1;\r\n\r\n\t    if (checkSC(pos)) uri = uri.concat(getSC());\r\n\t  }\r\n\r\n\t  t = tokens[startPos];\r\n\t  var line = t.ln;\r\n\t  var column = t.col;\r\n\t  var end = getLastPosition(uri, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(NodeType.UriType, uri, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkUri1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type !== TokenType.StringDQ && tokens[i].type !== TokenType.StringSQ) return 0;\r\n\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a value\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the value\r\n\t */\r\n\tfunction checkValue(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\t  var s = undefined;\r\n\t  var _i = undefined;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    s = checkSC(i);\r\n\t    _i = i + s;\r\n\r\n\t    if (l = _checkValue(_i)) i += l + s;else break;\r\n\t  }\r\n\r\n\t  tokens[start].value_end = i;\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getValue() {\r\n\t  var startPos = pos;\r\n\t  var end = tokens[pos].value_end;\r\n\t  var x = [];\r\n\r\n\t  while (pos < end) {\r\n\t    if (tokens[pos].value_child) x.push(_getValue());else x = x.concat(getSC());\r\n\t  }\r\n\r\n\t  var t = tokens[startPos];\r\n\t  return newNode(NodeType.ValueType, x, t.ln, t.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction _checkValue(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkProgid(i)) tokens[i].value_child = 1;else if (l = checkVhash(i)) tokens[i].value_child = 2;else if (l = checkAny(i)) tokens[i].value_child = 3;else if (l = checkOperator(i)) tokens[i].value_child = 4;else if (l = checkImportant(i)) tokens[i].value_child = 5;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Array}\r\n\t */\r\n\tfunction _getValue() {\r\n\t  var childType = tokens[pos].value_child;\r\n\t  if (childType === 1) return getProgid();else if (childType === 2) return getVhash();else if (childType === 3) return getAny();else if (childType === 4) return getOperator();else if (childType === 5) return getImportant();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      some value\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkVhash(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.NumberSign) return 0;\r\n\r\n\t  return (l = checkNmName2(i + 1)) ? l + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside some value\r\n\t * @return {Array} `['vhash', x]` where `x` is a hexadecimal number\r\n\t *      converted to string (without `#`, e.g. `'fff'`).\r\n\t */\r\n\tfunction getVhash() {\r\n\t  var type = NodeType.VhashType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = undefined;\r\n\r\n\t  pos++;\r\n\r\n\t  content = getNmName2();\r\n\t  var end = getLastPosition(content, line, column + 1);\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\tmodule.exports = function (_tokens, context) {\r\n\t  tokens = _tokens;\r\n\t  tokensLength = tokens.length;\r\n\t  pos = 0;\r\n\r\n\t  return contexts[context]();\r\n\t};\r\n\r\n\tfunction checkSelectorsGroup(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSelector(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var sb = checkSC(i);\r\n\t    var c = checkDelim(i + sb);\r\n\t    if (!c) break;\r\n\t    var sa = checkSC(i + sb + c);\r\n\t    if (l = checkSelector(i + sb + c + sa)) i += sb + c + sa + l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].selectorsGroupEnd = i;\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getSelectorsGroup() {\r\n\t  var selectorsGroup = [];\r\n\t  var selectorsGroupEnd = tokens[pos].selectorsGroupEnd;\r\n\r\n\t  selectorsGroup.push(getSelector());\r\n\r\n\t  while (pos < selectorsGroupEnd) {\r\n\t    selectorsGroup = selectorsGroup.concat(getSC());\r\n\t    selectorsGroup.push(getDelim());\r\n\t    selectorsGroup = selectorsGroup.concat(getSC());\r\n\t    selectorsGroup.push(getSelector());\r\n\t  }\r\n\r\n\t  return selectorsGroup;\r\n\t}\r\n\r\n\tfunction checkSelector(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkCompoundSelector(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var sb = checkSC(i);\r\n\t    var c = checkCombinator(i + sb);\r\n\t    if (!sb && !c) break;\r\n\t    var sa = checkSC(i + sb + c);\r\n\t    if (l = checkCompoundSelector(i + sb + c + sa)) i += sb + c + sa + l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].selectorEnd = i;\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getSelector() {\r\n\t  var type = NodeType.SelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var selectorEnd = token.selectorEnd;\r\n\t  var content = undefined;\r\n\r\n\t  content = getCompoundSelector();\r\n\r\n\t  while (pos < selectorEnd) {\r\n\t    content = content.concat(getSC());\r\n\t    if (checkCombinator(pos)) content.push(getCombinator());\r\n\t    content = content.concat(getSC());\r\n\t    content = content.concat(getCompoundSelector());\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkCompoundSelector(i) {\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkCompoundSelector1(i)) {\r\n\t    tokens[i].compoundSelectorType = 1;\r\n\t  } else if (l = checkCompoundSelector2(i)) {\r\n\t    tokens[i].compoundSelectorType = 2;\r\n\t  }\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getCompoundSelector() {\r\n\t  var type = tokens[pos].compoundSelectorType;\r\n\t  if (type === 1) return getCompoundSelector1();\r\n\t  if (type === 2) return getCompoundSelector2();\r\n\t}\r\n\r\n\tfunction checkCompoundSelector1(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkTypeSelector(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var _l2 = checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i);\r\n\t    if (_l2) i += _l2;else break;\r\n\t  }\r\n\r\n\t  tokens[start].compoundSelectorEnd = i;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getCompoundSelector1() {\r\n\t  var sequence = [];\r\n\t  var compoundSelectorEnd = tokens[pos].compoundSelectorEnd;\r\n\r\n\t  sequence.push(getTypeSelector());\r\n\r\n\t  while (pos < compoundSelectorEnd) {\r\n\t    if (checkShash(pos)) sequence.push(getShash());else if (checkClass(pos)) sequence.push(getClass());else if (checkAttributeSelector(pos)) sequence.push(getAttributeSelector());else if (checkPseudo(pos)) sequence.push(getPseudo());\r\n\t  }\r\n\r\n\t  return sequence;\r\n\t}\r\n\r\n\tfunction checkCompoundSelector2(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var l = checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i);\r\n\t    if (l) i += l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].compoundSelectorEnd = i;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getCompoundSelector2() {\r\n\t  var sequence = [];\r\n\t  var compoundSelectorEnd = tokens[pos].compoundSelectorEnd;\r\n\r\n\t  while (pos < compoundSelectorEnd) {\r\n\t    if (checkShash(pos)) sequence.push(getShash());else if (checkClass(pos)) sequence.push(getClass());else if (checkAttributeSelector(pos)) sequence.push(getAttributeSelector());else if (checkPseudo(pos)) sequence.push(getPseudo());\r\n\t  }\r\n\r\n\t  return sequence;\r\n\t}\r\n\r\n\tfunction checkTypeSelector(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkNamePrefix(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.Asterisk) i++;else if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getTypeSelector() {\r\n\t  var type = NodeType.TypeSelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (checkNamePrefix(pos)) content.push(getNamePrefix());\r\n\r\n\t  token = tokens[pos];\r\n\t  if (token.type === TokenType.Asterisk) {\r\n\t    var asteriskNode = newNode(NodeType.IdentType, '*', token.ln, token.col);\r\n\t    content.push(asteriskNode);\r\n\t    pos++;\r\n\t  } else if (checkIdent(pos)) content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeSelector(i) {\r\n\t  var l = undefined;\r\n\t  if (l = checkAttributeSelector1(i)) tokens[i].attributeSelectorType = 1;else if (l = checkAttributeSelector2(i)) tokens[i].attributeSelectorType = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getAttributeSelector() {\r\n\t  var type = tokens[pos].attributeSelectorType;\r\n\t  if (type === 1) return getAttributeSelector1();else return getAttributeSelector2();\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `[panda=nani]`\r\n\t * (2) `[panda='nani']`\r\n\t * (3) `[panda='nani' i]`\r\n\t *\r\n\t */\r\n\tfunction checkAttributeSelector1(i) {\r\n\t  var start = i;\r\n\r\n\t  if (tokens[i].type === TokenType.LeftSquareBracket) i++;else return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeName(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeMatch(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeValue(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeFlags(i)) {\r\n\t    i += l;\r\n\t    if (l = checkSC(i)) i += l;\r\n\t  }\r\n\r\n\t  if (tokens[i].type === TokenType.RightSquareBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeSelector1() {\r\n\t  var type = NodeType.AttributeSelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `[`.\r\n\t  pos++;\r\n\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeName());\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeMatch());\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeValue());\r\n\t  content = content.concat(getSC());\r\n\r\n\t  if (checkAttributeFlags(pos)) {\r\n\t    content.push(getAttributeFlags());\r\n\t    content = content.concat(getSC());\r\n\t  }\r\n\r\n\t  // Skip `]`.\r\n\t  pos++;\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `[panda]`\r\n\t */\r\n\tfunction checkAttributeSelector2(i) {\r\n\t  var start = i;\r\n\r\n\t  if (tokens[i].type === TokenType.LeftSquareBracket) i++;else return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeName(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.RightSquareBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeSelector2() {\r\n\t  var type = NodeType.AttributeSelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `[`.\r\n\t  pos++;\r\n\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeName());\r\n\t  content = content.concat(getSC());\r\n\r\n\t  // Skip `]`.\r\n\t  pos++;\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\tfunction checkAttributeName(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkNamePrefix(i)) i += l;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeName() {\r\n\t  var type = NodeType.AttributeNameType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (checkNamePrefix(pos)) content.push(getNamePrefix());\r\n\t  content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeMatch(i) {\r\n\t  var l = undefined;\r\n\t  if (l = checkAttributeMatch1(i)) tokens[i].attributeMatchType = 1;else if (l = checkAttributeMatch2(i)) tokens[i].attributeMatchType = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getAttributeMatch() {\r\n\t  var type = tokens[pos].attributeMatchType;\r\n\t  if (type === 1) return getAttributeMatch1();else return getAttributeMatch2();\r\n\t}\r\n\r\n\tfunction checkAttributeMatch1(i) {\r\n\t  var start = i;\r\n\r\n\t  var type = tokens[i].type;\r\n\t  if (type === TokenType.Tilde || type === TokenType.VerticalLine || type === TokenType.CircumflexAccent || type === TokenType.DollarSign || type === TokenType.Asterisk) i++;else return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.EqualsSign) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeMatch1() {\r\n\t  var type = NodeType.AttributeMatchType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = tokens[pos].value + tokens[pos + 1].value;\r\n\t  pos += 2;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeMatch2(i) {\r\n\t  if (tokens[i].type === TokenType.EqualsSign) return 1;else return 0;\r\n\t}\r\n\r\n\tfunction getAttributeMatch2() {\r\n\t  var type = NodeType.AttributeMatchType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '=';\r\n\r\n\t  pos++;\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeValue(i) {\r\n\t  return checkString(i) || checkIdent(i);\r\n\t}\r\n\r\n\tfunction getAttributeValue() {\r\n\t  var type = NodeType.AttributeValueType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (checkString(pos)) content.push(getString());else content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeFlags(i) {\r\n\t  return checkIdent(i);\r\n\t}\r\n\r\n\tfunction getAttributeFlags() {\r\n\t  var type = NodeType.AttributeFlagsType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getIdent()];\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkNamePrefix(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkNamePrefix1(i)) tokens[i].namePrefixType = 1;else if (l = checkNamePrefix2(i)) tokens[i].namePrefixType = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getNamePrefix() {\r\n\t  var type = tokens[pos].namePrefixType;\r\n\t  if (type === 1) return getNamePrefix1();else return getNamePrefix2();\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `panda|`\r\n\t * (2) `panda<comment>|`\r\n\t */\r\n\tfunction checkNamePrefix1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkNamespacePrefix(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkCommentML(i)) i += l;\r\n\r\n\t  if (l = checkNamespaceSeparator(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getNamePrefix1() {\r\n\t  var type = NodeType.NamePrefixType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  content.push(getNamespacePrefix());\r\n\r\n\t  if (checkCommentML(pos)) content.push(getCommentML());\r\n\r\n\t  content.push(getNamespaceSeparator());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `|`\r\n\t */\r\n\tfunction checkNamePrefix2(i) {\r\n\t  return checkNamespaceSeparator(i);\r\n\t}\r\n\r\n\tfunction getNamePrefix2() {\r\n\t  var type = NodeType.NamePrefixType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getNamespaceSeparator()];\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `*`\r\n\t * (2) `panda`\r\n\t */\r\n\tfunction checkNamespacePrefix(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l = undefined;\r\n\r\n\t  if (tokens[i].type === TokenType.Asterisk) return 1;else if (l = checkIdent(i)) return l;else return 0;\r\n\t}\r\n\r\n\tfunction getNamespacePrefix() {\r\n\t  var type = NodeType.NamespacePrefixType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (tokens[pos].type === TokenType.Asterisk) {\r\n\t    var asteriskNode = newNode(NodeType.IdentType, '*', line, column);\r\n\t    content.push(asteriskNode);\r\n\t    pos++;\r\n\t  } else if (checkIdent(pos)) content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `|`\r\n\t */\r\n\tfunction checkNamespaceSeparator(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].type !== TokenType.VerticalLine) return 0;\r\n\r\n\t  // Return false if `|=` - [attr|=value]\r\n\t  if (tokens[i + 1] && tokens[i + 1].type === TokenType.EqualsSign) return 0;\r\n\r\n\t  return 1;\r\n\t}\r\n\r\n\tfunction getNamespaceSeparator() {\r\n\t  var type = NodeType.NamespaceSeparatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '|';\r\n\r\n\t  pos++;\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n/***/ },\r\n/* 15 */\r\n/***/ function(module, exports) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = {\r\n\t  ArgumentsType: 'arguments',\r\n\t  AtkeywordType: 'atkeyword',\r\n\t  AtruleType: 'atrule',\r\n\t  AttributeSelectorType: 'attributeSelector',\r\n\t  AttributeNameType: 'attributeName',\r\n\t  AttributeFlagsType: 'attributeFlags',\r\n\t  AttributeMatchType: 'attributeMatch',\r\n\t  AttributeValueType: 'attributeValue',\r\n\t  BlockType: 'block',\r\n\t  BracketsType: 'brackets',\r\n\t  ClassType: 'class',\r\n\t  CombinatorType: 'combinator',\r\n\t  CommentMLType: 'multilineComment',\r\n\t  CommentSLType: 'singlelineComment',\r\n\t  ConditionType: 'condition',\r\n\t  ConditionalStatementType: 'conditionalStatement',\r\n\t  DeclarationType: 'declaration',\r\n\t  DeclDelimType: 'declarationDelimiter',\r\n\t  DefaultType: 'default',\r\n\t  DelimType: 'delimiter',\r\n\t  DimensionType: 'dimension',\r\n\t  EscapedStringType: 'escapedString',\r\n\t  ExtendType: 'extend',\r\n\t  ExpressionType: 'expression',\r\n\t  FunctionType: 'function',\r\n\t  GlobalType: 'global',\r\n\t  IdentType: 'ident',\r\n\t  ImportantType: 'important',\r\n\t  IncludeType: 'include',\r\n\t  InterpolationType: 'interpolation',\r\n\t  InterpolatedVariableType: 'interpolatedVariable',\r\n\t  KeyframesSelectorType: 'keyframesSelector',\r\n\t  LoopType: 'loop',\r\n\t  MixinType: 'mixin',\r\n\t  NamePrefixType: 'namePrefix',\r\n\t  NamespacePrefixType: 'namespacePrefix',\r\n\t  NamespaceSeparatorType: 'namespaceSeparator',\r\n\t  NumberType: 'number',\r\n\t  OperatorType: 'operator',\r\n\t  OptionalType: 'optional',\r\n\t  ParenthesesType: 'parentheses',\r\n\t  ParentSelectorType: 'parentSelector',\r\n\t  ParentSelectorExtensionType: 'parentSelectorExtension',\r\n\t  PercentageType: 'percentage',\r\n\t  PlaceholderType: 'placeholder',\r\n\t  ProgidType: 'progid',\r\n\t  PropertyType: 'property',\r\n\t  PropertyDelimType: 'propertyDelimiter',\r\n\t  PseudocType: 'pseudoClass',\r\n\t  PseudoeType: 'pseudoElement',\r\n\t  RawType: 'raw',\r\n\t  RulesetType: 'ruleset',\r\n\t  SType: 'space',\r\n\t  SelectorType: 'selector',\r\n\t  ShashType: 'id',\r\n\t  StringType: 'string',\r\n\t  StylesheetType: 'stylesheet',\r\n\t  TypeSelectorType: 'typeSelector',\r\n\t  UnicodeRangeType: 'unicodeRange',\r\n\t  UriType: 'uri',\r\n\t  UrangeType: 'urange',\r\n\t  ValueType: 'value',\r\n\t  VariableType: 'variable',\r\n\t  VariablesListType: 'variablesList',\r\n\t  VhashType: 'color'\r\n\t};\r\n\r\n/***/ },\r\n/* 16 */\r\n/***/ function(module, exports, __nested_webpack_require_174303__) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function (css, tabSize) {\r\n\t  var TokenType = __nested_webpack_require_174303__(13);\r\n\r\n\t  var tokens = [];\r\n\t  var urlMode = false;\r\n\t  var blockMode = 0;\r\n\t  var pos = 0;\r\n\t  var tn = 0;\r\n\t  var ln = 1;\r\n\t  var col = 1;\r\n\t  var cssLength = 0;\r\n\r\n\t  var Punctuation = {\r\n\t    ' ': TokenType.Space,\r\n\t    '\\n': TokenType.Newline,\r\n\t    '\\r': TokenType.Newline,\r\n\t    '\\t': TokenType.Tab,\r\n\t    '!': TokenType.ExclamationMark,\r\n\t    '\"': TokenType.QuotationMark,\r\n\t    '#': TokenType.NumberSign,\r\n\t    '$': TokenType.DollarSign,\r\n\t    '%': TokenType.PercentSign,\r\n\t    '&': TokenType.Ampersand,\r\n\t    '\\'': TokenType.Apostrophe,\r\n\t    '(': TokenType.LeftParenthesis,\r\n\t    ')': TokenType.RightParenthesis,\r\n\t    '*': TokenType.Asterisk,\r\n\t    '+': TokenType.PlusSign,\r\n\t    ',': TokenType.Comma,\r\n\t    '-': TokenType.HyphenMinus,\r\n\t    '.': TokenType.FullStop,\r\n\t    '/': TokenType.Solidus,\r\n\t    ':': TokenType.Colon,\r\n\t    ';': TokenType.Semicolon,\r\n\t    '<': TokenType.LessThanSign,\r\n\t    '=': TokenType.EqualsSign,\r\n\t    '>': TokenType.GreaterThanSign,\r\n\t    '?': TokenType.QuestionMark,\r\n\t    '@': TokenType.CommercialAt,\r\n\t    '[': TokenType.LeftSquareBracket,\r\n\t    ']': TokenType.RightSquareBracket,\r\n\t    '^': TokenType.CircumflexAccent,\r\n\t    '_': TokenType.LowLine,\r\n\t    '{': TokenType.LeftCurlyBracket,\r\n\t    '|': TokenType.VerticalLine,\r\n\t    '}': TokenType.RightCurlyBracket,\r\n\t    '~': TokenType.Tilde\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Add a token to the token list\r\n\t   * @param {string} type\r\n\t   * @param {string} value\r\n\t   */\r\n\t  function pushToken(type, value, column) {\r\n\t    tokens.push({\r\n\t      tn: tn++,\r\n\t      ln: ln,\r\n\t      col: column,\r\n\t      type: type,\r\n\t      value: value\r\n\t    });\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Check if a character is a decimal digit\r\n\t   * @param {string} c Character\r\n\t   * @returns {boolean}\r\n\t   */\r\n\t  function isDecimalDigit(c) {\r\n\t    return '0123456789'.indexOf(c) >= 0;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse spaces\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseSpaces(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a non-space character:\r\n\t    for (; pos < cssLength; pos++) {\r\n\t      if (css.charAt(pos) !== ' ') break;\r\n\t    }\r\n\r\n\t    // Add a substring containing only spaces to tokens:\r\n\t    pushToken(TokenType.Space, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse a string within quotes\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   * @param {string} q Quote (either `'` or `\"`)\r\n\t   */\r\n\t  function parseString(css, q) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a matching quote:\r\n\t    for (pos++; pos < cssLength; pos++) {\r\n\t      // Skip escaped quotes:\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (css.charAt(pos) === q) break;\r\n\t    }\r\n\r\n\t    // Add the string (including quotes) to tokens:\r\n\t    pushToken(q === '\"' ? TokenType.StringDQ : TokenType.StringSQ, css.substring(start, pos + 1), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse numbers\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseDecimalNumber(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a character that's not a digit:\r\n\t    for (; pos < cssLength; pos++) {\r\n\t      if (!isDecimalDigit(css.charAt(pos))) break;\r\n\t    }\r\n\r\n\t    // Add the number to tokens:\r\n\t    pushToken(TokenType.DecimalNumber, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse identifier\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseIdentifier(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Skip all opening slashes:\r\n\t    while (css.charAt(pos) === '/') pos++;\r\n\r\n\t    // Read the string until we meet a punctuation mark:\r\n\t    for (; pos < cssLength; pos++) {\r\n\t      // Skip all '\\':\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (Punctuation[css.charAt(pos)]) break;\r\n\t    }\r\n\r\n\t    var ident = css.substring(start, pos--);\r\n\r\n\t    // Enter url mode if parsed substring is `url`:\r\n\t    urlMode = urlMode || ident === 'url';\r\n\r\n\t    // Add identifier to tokens:\r\n\t    pushToken(TokenType.Identifier, ident, col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Parse a multiline comment\r\n\t  * @param {string} css Unparsed part of CSS string\r\n\t  */\r\n\t  function parseMLComment(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet `*/`.\r\n\t    // Since we already know first 2 characters (`/*`), start reading\r\n\t    // from `pos + 2`:\r\n\t    for (pos = pos + 2; pos < cssLength; pos++) {\r\n\t      if (css.charAt(pos) === '*' && css.charAt(pos + 1) === '/') {\r\n\t        pos++;\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Add full comment (including `/*` and `*/`) to the list of tokens:\r\n\t    var comment = css.substring(start, pos + 1);\r\n\t    pushToken(TokenType.CommentML, comment, col);\r\n\r\n\t    var newlines = comment.split('\\n');\r\n\t    if (newlines.length > 1) {\r\n\t      ln += newlines.length - 1;\r\n\t      col = newlines[newlines.length - 1].length;\r\n\t    } else {\r\n\t      col += pos - start;\r\n\t    }\r\n\t  }\r\n\r\n\t  function parseSLComment(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet line break.\r\n\t    // Since we already know first 2 characters (`//`), start reading\r\n\t    // from `pos + 2`:\r\n\t    for (pos += 2; pos < cssLength; pos++) {\r\n\t      if (css.charAt(pos) === '\\n' || css.charAt(pos) === '\\r') {\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Add comment (including `//` and line break) to the list of tokens:\r\n\t    pushToken(TokenType.CommentSL, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Convert a CSS string to a list of tokens\r\n\t   * @param {string} css CSS string\r\n\t   * @returns {Array} List of tokens\r\n\t   * @private\r\n\t   */\r\n\t  function getTokens(css) {\r\n\t    var c; // Current character\r\n\t    var cn; // Next character\r\n\r\n\t    cssLength = css.length;\r\n\r\n\t    // Parse string, character by character:\r\n\t    for (pos = 0; pos < cssLength; col++, pos++) {\r\n\t      c = css.charAt(pos);\r\n\t      cn = css.charAt(pos + 1);\r\n\r\n\t      // If we meet `/*`, it's a start of a multiline comment.\r\n\t      // Parse following characters as a multiline comment:\r\n\t      if (c === '/' && cn === '*') {\r\n\t        parseMLComment(css);\r\n\t      }\r\n\r\n\t      // If we meet `//` and it is not a part of url:\r\n\t      else if (!urlMode && c === '/' && cn === '/') {\r\n\t          // If we're currently inside a block, treat `//` as a start\r\n\t          // of identifier. Else treat `//` as a start of a single-line\r\n\t          // comment:\r\n\t          if (blockMode > 0) parseIdentifier(css);else parseSLComment(css);\r\n\t        }\r\n\r\n\t        // If current character is a double or single quote, it's a start\r\n\t        // of a string:\r\n\t        else if (c === '\"' || c === \"'\") {\r\n\t            parseString(css, c);\r\n\t          }\r\n\r\n\t          // If current character is a space:\r\n\t          else if (c === ' ') {\r\n\t              parseSpaces(css);\r\n\t            }\r\n\r\n\t            // If current character is a punctuation mark:\r\n\t            else if (Punctuation[c]) {\r\n\t                // Add it to the list of tokens:\r\n\t                pushToken(Punctuation[c], c, col);\r\n\t                if (c === '\\n' || c === '\\r') {\r\n\t                  ln++;\r\n\t                  col = 0;\r\n\t                } // Go to next line\r\n\t                else if (c === ')') urlMode = false; // Exit url mode\r\n\t                  else if (c === '{') blockMode++; // Enter a block\r\n\t                    else if (c === '}') blockMode--; // Exit a block\r\n\t                      else if (c === '\\t' && tabSize > 1) col += tabSize - 1;\r\n\t              }\r\n\r\n\t              // If current character is a decimal digit:\r\n\t              else if (isDecimalDigit(c)) {\r\n\t                  parseDecimalNumber(css);\r\n\t                }\r\n\r\n\t                // If current character is anything else:\r\n\t                else {\r\n\t                    parseIdentifier(css);\r\n\t                  }\r\n\t    }\r\n\r\n\t    return tokens;\r\n\t  }\r\n\r\n\t  return getTokens(css);\r\n\t};\r\n\r\n/***/ },\r\n/* 17 */\r\n/***/ function(module, exports, __nested_webpack_require_182483__) {\r\n\r\n\t'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports['default'] = {\r\n\t  mark: __nested_webpack_require_182483__(18),\r\n\t  parse: __nested_webpack_require_182483__(19),\r\n\t  stringify: __nested_webpack_require_182483__(4),\r\n\t  tokenizer: __nested_webpack_require_182483__(20)\r\n\t};\r\n\tmodule.exports = exports['default'];\r\n\r\n/***/ },\r\n/* 18 */\r\n/***/ function(module, exports, __nested_webpack_require_182828__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar TokenType = __nested_webpack_require_182828__(13);\r\n\r\n\tmodule.exports = (function () {\r\n\t  /**\r\n\t  * Mark whitespaces and comments\r\n\t  */\r\n\t  function markSC(tokens) {\r\n\t    var tokensLength = tokens.length;\r\n\t    var ws = -1; // Flag for whitespaces\r\n\t    var sc = -1; // Flag for whitespaces and comments\r\n\t    var t = undefined; // Current token\r\n\r\n\t    // For every token in the token list, mark spaces and line breaks\r\n\t    // as spaces (set both `ws` and `sc` flags). Mark multiline comments\r\n\t    // with `sc` flag.\r\n\t    // If there are several spaces or tabs or line breaks or multiline\r\n\t    // comments in a row, group them: take the last one's index number\r\n\t    // and save it to the first token in the group as a reference:\r\n\t    // e.g., `ws_last = 7` for a group of whitespaces or `sc_last = 9`\r\n\t    // for a group of whitespaces and comments.\r\n\t    for (var i = 0; i < tokensLength; i++) {\r\n\t      t = tokens[i];\r\n\t      switch (t.type) {\r\n\t        case TokenType.Space:\r\n\t        case TokenType.Tab:\r\n\t        case TokenType.Newline:\r\n\t          t.ws = true;\r\n\t          t.sc = true;\r\n\r\n\t          if (ws === -1) ws = i;\r\n\t          if (sc === -1) sc = i;\r\n\r\n\t          break;\r\n\t        case TokenType.CommentML:\r\n\t        case TokenType.CommentSL:\r\n\t          if (ws !== -1) {\r\n\t            tokens[ws].ws_last = i - 1;\r\n\t            ws = -1;\r\n\t          }\r\n\r\n\t          t.sc = true;\r\n\r\n\t          break;\r\n\t        default:\r\n\t          if (ws !== -1) {\r\n\t            tokens[ws].ws_last = i - 1;\r\n\t            ws = -1;\r\n\t          }\r\n\r\n\t          if (sc !== -1) {\r\n\t            tokens[sc].sc_last = i - 1;\r\n\t            sc = -1;\r\n\t          }\r\n\t      }\r\n\t    }\r\n\r\n\t    if (ws !== -1) tokens[ws].ws_last = i - 1;\r\n\t    if (sc !== -1) tokens[sc].sc_last = i - 1;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Pair brackets\r\n\t  */\r\n\t  function markBrackets(tokens) {\r\n\t    var tokensLength = tokens.length;\r\n\t    var ps = []; // Parentheses\r\n\t    var sbs = []; // Square brackets\r\n\t    var cbs = []; // Curly brackets\r\n\t    var t = undefined; // Current token\r\n\r\n\t    // For every token in the token list, if we meet an opening (left)\r\n\t    // bracket, push its index number to a corresponding array.\r\n\t    // If we then meet a closing (right) bracket, look at the corresponding\r\n\t    // array. If there are any elements (records about previously met\r\n\t    // left brackets), take a token of the last left bracket (take\r\n\t    // the last index number from the array and find a token with\r\n\t    // this index number) and save right bracket's index as a reference:\r\n\t    for (var i = 0; i < tokensLength; i++) {\r\n\t      t = tokens[i];\r\n\t      switch (t.type) {\r\n\t        case TokenType.LeftParenthesis:\r\n\t          ps.push(i);\r\n\t          break;\r\n\t        case TokenType.RightParenthesis:\r\n\t          if (ps.length) {\r\n\t            t.left = ps.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t        case TokenType.LeftSquareBracket:\r\n\t          sbs.push(i);\r\n\t          break;\r\n\t        case TokenType.RightSquareBracket:\r\n\t          if (sbs.length) {\r\n\t            t.left = sbs.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t        case TokenType.LeftCurlyBracket:\r\n\t          cbs.push(i);\r\n\t          break;\r\n\t        case TokenType.RightCurlyBracket:\r\n\t          if (cbs.length) {\r\n\t            t.left = cbs.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  return function (tokens) {\r\n\t    markBrackets(tokens);\r\n\t    markSC(tokens);\r\n\t  };\r\n\t})();\r\n\r\n/***/ },\r\n/* 19 */\r\n/***/ function(module, exports, __nested_webpack_require_186491__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar Node = __nested_webpack_require_186491__(1);\r\n\tvar NodeType = __nested_webpack_require_186491__(15);\r\n\tvar TokenType = __nested_webpack_require_186491__(13);\r\n\r\n\tvar tokens = undefined;\r\n\tvar tokensLength = undefined;\r\n\tvar pos = undefined;\r\n\r\n\tvar contexts = {\r\n\t  'arguments': function () {\r\n\t    return checkArguments(pos) && getArguments();\r\n\t  },\r\n\t  'atkeyword': function () {\r\n\t    return checkAtkeyword(pos) && getAtkeyword();\r\n\t  },\r\n\t  'atrule': function () {\r\n\t    return checkAtrule(pos) && getAtrule();\r\n\t  },\r\n\t  'block': function () {\r\n\t    return checkBlock(pos) && getBlock();\r\n\t  },\r\n\t  'brackets': function () {\r\n\t    return checkBrackets(pos) && getBrackets();\r\n\t  },\r\n\t  'class': function () {\r\n\t    return checkClass(pos) && getClass();\r\n\t  },\r\n\t  'combinator': function () {\r\n\t    return checkCombinator(pos) && getCombinator();\r\n\t  },\r\n\t  'commentML': function () {\r\n\t    return checkCommentML(pos) && getCommentML();\r\n\t  },\r\n\t  'commentSL': function () {\r\n\t    return checkCommentSL(pos) && getCommentSL();\r\n\t  },\r\n\t  'condition': function () {\r\n\t    return checkCondition(pos) && getCondition();\r\n\t  },\r\n\t  'declaration': function () {\r\n\t    return checkDeclaration(pos) && getDeclaration();\r\n\t  },\r\n\t  'declDelim': function () {\r\n\t    return checkDeclDelim(pos) && getDeclDelim();\r\n\t  },\r\n\t  'delim': function () {\r\n\t    return checkDelim(pos) && getDelim();\r\n\t  },\r\n\t  'dimension': function () {\r\n\t    return checkDimension(pos) && getDimension();\r\n\t  },\r\n\t  'escapedString': function () {\r\n\t    return checkEscapedString(pos) && getEscapedString();\r\n\t  },\r\n\t  'expression': function () {\r\n\t    return checkExpression(pos) && getExpression();\r\n\t  },\r\n\t  'extend': function () {\r\n\t    return checkExtend(pos) && getExtend();\r\n\t  },\r\n\t  'function': function () {\r\n\t    return checkFunction(pos) && getFunction();\r\n\t  },\r\n\t  'ident': function () {\r\n\t    return checkIdent(pos) && getIdent();\r\n\t  },\r\n\t  'important': function () {\r\n\t    return checkImportant(pos) && getImportant();\r\n\t  },\r\n\t  'include': function () {\r\n\t    return checkInclude(pos) && getInclude();\r\n\t  },\r\n\t  'interpolatedVariable': function () {\r\n\t    return checkInterpolatedVariable(pos) && getInterpolatedVariable();\r\n\t  },\r\n\t  'mixin': function () {\r\n\t    return checkMixin(pos) && getMixin();\r\n\t  },\r\n\t  'namespace': function () {\r\n\t    return checkNamespace(pos) && getNamespace();\r\n\t  },\r\n\t  'number': function () {\r\n\t    return checkNumber(pos) && getNumber();\r\n\t  },\r\n\t  'operator': function () {\r\n\t    return checkOperator(pos) && getOperator();\r\n\t  },\r\n\t  'parentheses': function () {\r\n\t    return checkParentheses(pos) && getParentheses();\r\n\t  },\r\n\t  'parentselector': function () {\r\n\t    return checkParentSelector(pos) && getParentSelector();\r\n\t  },\r\n\t  'percentage': function () {\r\n\t    return checkPercentage(pos) && getPercentage();\r\n\t  },\r\n\t  'progid': function () {\r\n\t    return checkProgid(pos) && getProgid();\r\n\t  },\r\n\t  'property': function () {\r\n\t    return checkProperty(pos) && getProperty();\r\n\t  },\r\n\t  'propertyDelim': function () {\r\n\t    return checkPropertyDelim(pos) && getPropertyDelim();\r\n\t  },\r\n\t  'pseudoc': function () {\r\n\t    return checkPseudoc(pos) && getPseudoc();\r\n\t  },\r\n\t  'pseudoe': function () {\r\n\t    return checkPseudoe(pos) && getPseudoe();\r\n\t  },\r\n\t  'ruleset': function () {\r\n\t    return checkRuleset(pos) && getRuleset();\r\n\t  },\r\n\t  's': function () {\r\n\t    return checkS(pos) && getS();\r\n\t  },\r\n\t  'selector': function () {\r\n\t    return checkSelector(pos) && getSelector();\r\n\t  },\r\n\t  'shash': function () {\r\n\t    return checkShash(pos) && getShash();\r\n\t  },\r\n\t  'string': function () {\r\n\t    return checkString(pos) && getString();\r\n\t  },\r\n\t  'stylesheet': function () {\r\n\t    return checkStylesheet(pos) && getStylesheet();\r\n\t  },\r\n\t  'unary': function () {\r\n\t    return checkUnary(pos) && getUnary();\r\n\t  },\r\n\t  'unicodeRange': function () {\r\n\t    return checkUnicodeRange(pos) && getUnicodeRange();\r\n\t  },\r\n\t  'urange': function () {\r\n\t    return checkUrange(pos) && getUrange();\r\n\t  },\r\n\t  'uri': function () {\r\n\t    return checkUri(pos) && getUri();\r\n\t  },\r\n\t  'value': function () {\r\n\t    return checkValue(pos) && getValue();\r\n\t  },\r\n\t  'variable': function () {\r\n\t    return checkVariable(pos) && getVariable();\r\n\t  },\r\n\t  'variableslist': function () {\r\n\t    return checkVariablesList(pos) && getVariablesList();\r\n\t  },\r\n\t  'vhash': function () {\r\n\t    return checkVhash(pos) && getVhash();\r\n\t  }\r\n\t};\r\n\r\n\t/**\r\n\t * Stop parsing and display error\r\n\t * @param {Number=} i Token's index number\r\n\t */\r\n\tfunction throwError(i) {\r\n\t  var ln = tokens[i].ln;\r\n\r\n\t  throw { line: ln, syntax: 'less' };\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Object} exclude\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkExcluding(exclude, i) {\r\n\t  var start = i;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (exclude[tokens[i++].type]) break;\r\n\t  }\r\n\r\n\t  return i - start - 2;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} start\r\n\t * @param {Number} finish\r\n\t * @returns {String}\r\n\t */\r\n\tfunction joinValues(start, finish) {\r\n\t  var s = '';\r\n\r\n\t  for (var i = start; i < finish + 1; i++) {\r\n\t    s += tokens[i].value;\r\n\t  }\r\n\r\n\t  return s;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} start\r\n\t * @param {Number} num\r\n\t * @returns {String}\r\n\t */\r\n\tfunction joinValues2(start, num) {\r\n\t  if (start + num - 1 >= tokensLength) return;\r\n\r\n\t  var s = '';\r\n\r\n\t  for (var i = 0; i < num; i++) {\r\n\t    s += tokens[start + i].value;\r\n\t  }\r\n\r\n\t  return s;\r\n\t}\r\n\r\n\tfunction getLastPosition(content, line, column, colOffset) {\r\n\t  return typeof content === 'string' ? getLastPositionForString(content, line, column, colOffset) : getLastPositionForArray(content, line, column, colOffset);\r\n\t}\r\n\r\n\tfunction getLastPositionForString(content, line, column, colOffset) {\r\n\t  var position = [];\r\n\r\n\t  if (!content) {\r\n\t    position = [line, column];\r\n\t    if (colOffset) position[1] += colOffset - 1;\r\n\t    return position;\r\n\t  }\r\n\r\n\t  var lastLinebreak = content.lastIndexOf('\\n');\r\n\t  var endsWithLinebreak = lastLinebreak === content.length - 1;\r\n\t  var splitContent = content.split('\\n');\r\n\t  var linebreaksCount = splitContent.length - 1;\r\n\t  var prevLinebreak = linebreaksCount === 0 || linebreaksCount === 1 ? -1 : content.length - splitContent[linebreaksCount - 1].length - 2;\r\n\r\n\t  // Line:\r\n\t  var offset = endsWithLinebreak ? linebreaksCount - 1 : linebreaksCount;\r\n\t  position[0] = line + offset;\r\n\r\n\t  // Column:\r\n\t  if (endsWithLinebreak) {\r\n\t    offset = prevLinebreak !== -1 ? content.length - prevLinebreak : content.length - 1;\r\n\t  } else {\r\n\t    offset = linebreaksCount !== 0 ? content.length - lastLinebreak - column - 1 : content.length - 1;\r\n\t  }\r\n\t  position[1] = column + offset;\r\n\r\n\t  if (!colOffset) return position;\r\n\r\n\t  if (endsWithLinebreak) {\r\n\t    position[0]++;\r\n\t    position[1] = colOffset;\r\n\t  } else {\r\n\t    position[1] += colOffset;\r\n\t  }\r\n\r\n\t  return position;\r\n\t}\r\n\r\n\tfunction getLastPositionForArray(content, line, column, colOffset) {\r\n\t  var position;\r\n\r\n\t  if (content.length === 0) {\r\n\t    position = [line, column];\r\n\t  } else {\r\n\t    var c = content[content.length - 1];\r\n\t    if (c.hasOwnProperty('end')) {\r\n\t      position = [c.end.line, c.end.column];\r\n\t    } else {\r\n\t      position = getLastPosition(c.content, line, column);\r\n\t    }\r\n\t  }\r\n\r\n\t  if (!colOffset) return position;\r\n\r\n\t  if (tokens[pos - 1].type !== 'Newline') {\r\n\t    position[1] += colOffset;\r\n\t  } else {\r\n\t    position[0]++;\r\n\t    position[1] = 1;\r\n\t  }\r\n\r\n\t  return position;\r\n\t}\r\n\r\n\tfunction newNode(type, content, line, column, end) {\r\n\t  if (!end) end = getLastPosition(content, line, column);\r\n\t  return new Node({\r\n\t    type: type,\r\n\t    content: content,\r\n\t    start: {\r\n\t      line: line,\r\n\t      column: column\r\n\t    },\r\n\t    end: {\r\n\t      line: end[0],\r\n\t      column: end[1]\r\n\t    },\r\n\t    syntax: 'less'\r\n\t  });\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkAny(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkBrackets(i)) tokens[i].any_child = 1;else if (l = checkParentheses(i)) tokens[i].any_child = 2;else if (l = checkString(i)) tokens[i].any_child = 3;else if (l = checkVariablesList(i)) tokens[i].any_child = 4;else if (l = checkVariable(i)) tokens[i].any_child = 5;else if (l = checkPercentage(i)) tokens[i].any_child = 6;else if (l = checkDimension(i)) tokens[i].any_child = 7;else if (l = checkUnicodeRange(i)) tokens[i].any_child = 15;else if (l = checkNumber(i)) tokens[i].any_child = 8;else if (l = checkUri(i)) tokens[i].any_child = 9;else if (l = checkExpression(i)) tokens[i].any_child = 10;else if (l = checkFunction(i)) tokens[i].any_child = 11;else if (l = checkIdent(i)) tokens[i].any_child = 12;else if (l = checkClass(i)) tokens[i].any_child = 13;else if (l = checkUnary(i)) tokens[i].any_child = 14;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getAny() {\r\n\t  var childType = tokens[pos].any_child;\r\n\r\n\t  if (childType === 1) return getBrackets();\r\n\t  if (childType === 2) return getParentheses();\r\n\t  if (childType === 3) return getString();\r\n\t  if (childType === 4) return getVariablesList();\r\n\t  if (childType === 5) return getVariable();\r\n\t  if (childType === 6) return getPercentage();\r\n\t  if (childType === 7) return getDimension();\r\n\t  if (childType === 15) return getUnicodeRange();\r\n\t  if (childType === 8) return getNumber();\r\n\t  if (childType === 9) return getUri();\r\n\t  if (childType === 10) return getExpression();\r\n\t  if (childType === 11) return getFunction();\r\n\t  if (childType === 12) return getIdent();\r\n\t  if (childType === 13) return getClass();\r\n\t  if (childType === 14) return getUnary();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of mixin's arguments.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkArguments(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  while (i < tokens[start].right) {\r\n\t    if (l = checkArgument(i)) i += l;else return 0;\r\n\t  }\r\n\r\n\t  return tokens[start].right - start + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is valid to be part of arguments list.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkArgument(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkEscapedString(i)) tokens[i].argument_child = 1;else if (l = checkDeclaration(i)) tokens[i].argument_child = 2;else if (l = checkVariablesList(i)) tokens[i].argument_child = 3;else if (l = checkVariable(i)) tokens[i].argument_child = 4;else if (l = checkSC(i)) tokens[i].argument_child = 5;else if (l = checkUnary(i)) tokens[i].argument_child = 6;else if (l = checkOperator(i)) tokens[i].argument_child = 7;else if (l = checkDelim(i)) tokens[i].argument_child = 8;else if (l = checkDeclDelim(i)) tokens[i].argument_child = 9;else if (l = checkString(i)) tokens[i].argument_child = 10;else if (l = checkPercentage(i)) tokens[i].argument_child = 11;else if (l = checkDimension(i)) tokens[i].argument_child = 12;else if (l = checkNumber(i)) tokens[i].argument_child = 13;else if (l = checkUri(i)) tokens[i].argument_child = 14;else if (l = checkFunction(i)) tokens[i].argument_child = 15;else if (l = checkIdent(i)) tokens[i].argument_child = 16;else if (l = checkVhash(i)) tokens[i].argument_child = 17;else if (l = checkBlock(i)) tokens[i].argument_child = 18;else if (l = checkParentheses(i)) tokens[i].argument_child = 19;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array} Node that is part of arguments list.\r\n\t */\r\n\tfunction getArgument() {\r\n\t  var childType = tokens[pos].argument_child;\r\n\r\n\t  if (childType === 1) return getEscapedString();\r\n\t  if (childType === 2) return getDeclaration();\r\n\t  if (childType === 3) return getVariablesList();\r\n\t  if (childType === 4) return getVariable();\r\n\t  if (childType === 5) return getSC();\r\n\t  if (childType === 6) return getUnary();\r\n\t  if (childType === 7) return getOperator();\r\n\t  if (childType === 8) return getDelim();\r\n\t  if (childType === 9) return getDeclDelim();\r\n\t  if (childType === 10) return getString();\r\n\t  if (childType === 11) return getPercentage();\r\n\t  if (childType === 12) return getDimension();\r\n\t  if (childType === 13) return getNumber();\r\n\t  if (childType === 14) return getUri();\r\n\t  if (childType === 15) return getFunction();\r\n\t  if (childType === 16) return getIdent();\r\n\t  if (childType === 17) return getVhash();\r\n\t  if (childType === 18) return getBlock();\r\n\t  if (childType === 19) return getParentheses();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an @-word (e.g. `@import`, `@include`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkAtkeyword(i) {\r\n\t  var l;\r\n\r\n\t  // Check that token is `@`:\r\n\t  if (i >= tokensLength || tokens[i++].type !== TokenType.CommercialAt) return 0;\r\n\r\n\t  return (l = checkIdent(i)) ? l + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with @-word\r\n\t * @returns {Array} `['atkeyword', ['ident', x]]` where `x` is\r\n\t *      an identifier without\r\n\t *      `@` (e.g. `import`, `include`)\r\n\t */\r\n\tfunction getAtkeyword() {\r\n\t  var token = tokens[pos++];\r\n\t  var content = [getIdent()];\r\n\r\n\t  return newNode(NodeType.AtkeywordType, content, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a part of an @-rule\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of @-rule\r\n\t */\r\n\tfunction checkAtrule(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  // If token already has a record of being part of an @-rule,\r\n\t  // return the @-rule's length:\r\n\t  if (tokens[i].atrule_l !== undefined) return tokens[i].atrule_l;\r\n\r\n\t  // If token is part of an @-rule, save the rule's type to token.\r\n\t  if (l = checkKeyframesRule(i)) tokens[i].atrule_type = 4;\r\n\t  // @-rule with ruleset:\r\n\t  else if (l = checkAtruler(i)) tokens[i].atrule_type = 1;\r\n\t    // Block @-rule:\r\n\t    else if (l = checkAtruleb(i)) tokens[i].atrule_type = 2;\r\n\t      // Single-line @-rule:\r\n\t      else if (l = checkAtrules(i)) tokens[i].atrule_type = 3;else return 0;\r\n\r\n\t  // If token is part of an @-rule, save the rule's length to token:\r\n\t  tokens[i].atrule_l = l;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with @-rule\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getAtrule() {\r\n\t  switch (tokens[pos].atrule_type) {\r\n\t    case 1:\r\n\t      return getAtruler(); // @-rule with ruleset\r\n\t    case 2:\r\n\t      return getAtruleb(); // Block @-rule\r\n\t    case 3:\r\n\t      return getAtrules(); // Single-line @-rule\r\n\t    case 4:\r\n\t      return getKeyframesRule();\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a block @-rule\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the @-rule\r\n\t */\r\n\tfunction checkAtruleb(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkTsets(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a block @-rule\r\n\t * @returns {Array} `['atruleb', ['atkeyword', x], y, ['block', z]]`\r\n\t */\r\n\tfunction getAtruleb() {\r\n\t  var startPos = pos;\r\n\t  var content = [getAtkeyword()].concat(getTsets()).concat([getBlock()]);\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.AtruleType, content, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an @-rule with ruleset\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the @-rule\r\n\t */\r\n\tfunction checkAtruler(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkTsets(i)) i += l;\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket) i++;else return 0;\r\n\r\n\t  if (l = checkAtrulers(i)) i += l;\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an @-rule with ruleset\r\n\t * @returns {Array} ['atruler', ['atkeyword', x], y, z]\r\n\t */\r\n\tfunction getAtruler() {\r\n\t  var startPos = pos;\r\n\t  var content = [getAtkeyword()];\r\n\t  content = content.concat(getTsets());\r\n\t  content.push(getAtrulers());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.AtruleType, content, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkAtrulers(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkSC(i)) tokens[i].atrulers_child = 1;else if (l = checkAtrule(i)) tokens[i].atrulers_child = 2;else if (l = checkRuleset(i)) tokens[i].atrulers_child = 3;else break;\r\n\t    i += l;\r\n\t  }\r\n\r\n\t  tokens[i].atrulers_end = 1;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array} `['atrulers', x]`\r\n\t */\r\n\tfunction getAtrulers() {\r\n\t  var token = tokens[pos++];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = getSC();\r\n\r\n\t  while (!tokens[pos].atrulers_end) {\r\n\t    var childType = tokens[pos].atrulers_child;\r\n\t    if (childType === 1) content = content.concat(getSC());else if (childType === 2) content.push(getAtrule());else if (childType === 3) content.push(getRuleset());\r\n\t  }\r\n\r\n\t  content = content.concat(getSC());\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(NodeType.BlockType, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkAtrules(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkTsets(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array} `['atrules', ['atkeyword', x], y]`\r\n\t */\r\n\tfunction getAtrules() {\r\n\t  var startPos = pos;\r\n\t  var content = [getAtkeyword()].concat(getTsets());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.AtruleType, content, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a block (e.g. `{...}`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the block\r\n\t */\r\n\tfunction checkBlock(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket ? tokens[i].right - i + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a block\r\n\t * @returns {Array} `['block', x]`\r\n\t */\r\n\tfunction getBlock() {\r\n\t  var startPos = pos;\r\n\t  var end = tokens[pos++].right;\r\n\t  var content = [];\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  while (pos < end) {\r\n\t    if (checkBlockdecl(pos)) content = content.concat(getBlockdecl());else throwError(pos);\r\n\t  }\r\n\r\n\t  var end_ = getLastPosition(content, line, column, 1);\r\n\t  pos = end + 1;\r\n\r\n\t  return newNode(NodeType.BlockType, content, line, column, end_);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the declaration\r\n\t */\r\n\tfunction checkBlockdecl(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkBlockdecl1(i)) tokens[i].bd_type = 1;else if (l = checkBlockdecl2(i)) tokens[i].bd_type = 2;else if (l = checkBlockdecl3(i)) tokens[i].bd_type = 3;else if (l = checkBlockdecl4(i)) tokens[i].bd_type = 4;else return 0;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getBlockdecl() {\r\n\t  switch (tokens[pos].bd_type) {\r\n\t    case 1:\r\n\t      return getBlockdecl1();\r\n\t    case 2:\r\n\t      return getBlockdecl2();\r\n\t    case 3:\r\n\t      return getBlockdecl3();\r\n\t    case 4:\r\n\t      return getBlockdecl4();\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkBlockdecl1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkCondition(i)) tokens[i].bd_kind = 1;else if (l = checkExtend(i)) tokens[i].bd_kind = 6;else if (l = checkRuleset(i)) tokens[i].bd_kind = 2;else if (l = checkDeclaration(i)) tokens[i].bd_kind = 3;else if (l = checkAtrule(i)) tokens[i].bd_kind = 4;else if (l = checkInclude(i)) tokens[i].bd_kind = 5;else return 0;\r\n\r\n\t  i += l;\r\n\r\n\t  if (i < tokensLength && (l = checkDeclDelim(i))) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getBlockdecl1() {\r\n\t  var sc = getSC();\r\n\t  var x = undefined;\r\n\r\n\t  switch (tokens[pos].bd_kind) {\r\n\t    case 1:\r\n\t      x = getCondition();\r\n\t      break;\r\n\t    case 2:\r\n\t      x = getRuleset();\r\n\t      break;\r\n\t    case 3:\r\n\t      x = getDeclaration();\r\n\t      break;\r\n\t    case 4:\r\n\t      x = getAtrule();\r\n\t      break;\r\n\t    case 5:\r\n\t      x = getInclude();\r\n\t      break;\r\n\t    case 6:\r\n\t      x = getExtend();\r\n\t      break;\r\n\t  }\r\n\r\n\t  return sc.concat([x]).concat([getDeclDelim()]).concat(getSC());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkBlockdecl2(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkCondition(i)) tokens[i].bd_kind = 1;else if (l = checkExtend(i)) tokens[i].bd_kind = 3;else if (l = checkRuleset(i)) tokens[i].bd_kind = 6;else if (l = checkDeclaration(i)) tokens[i].bd_kind = 4;else if (l = checkAtrule(i)) tokens[i].bd_kind = 5;else if (l = checkInclude(i)) tokens[i].bd_kind = 2;else return 0;\r\n\r\n\t  i += l;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getBlockdecl2() {\r\n\t  var sc = getSC();\r\n\t  var x = undefined;\r\n\r\n\t  switch (tokens[pos].bd_kind) {\r\n\t    case 1:\r\n\t      x = getCondition();\r\n\t      break;\r\n\t    case 2:\r\n\t      x = getInclude();\r\n\t      break;\r\n\t    case 3:\r\n\t      x = getExtend();\r\n\t      break;\r\n\t    case 4:\r\n\t      x = getDeclaration();\r\n\t      break;\r\n\t    case 5:\r\n\t      x = getAtrule();\r\n\t      break;\r\n\t    case 6:\r\n\t      x = getRuleset();\r\n\t      break;\r\n\t  }\r\n\r\n\t  return sc.concat([x]).concat(getSC());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkBlockdecl3(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkDeclDelim(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array} `[s0, ['declDelim'], s1]` where `s0` and `s1` are\r\n\t *      are optional whitespaces.\r\n\t */\r\n\tfunction getBlockdecl3() {\r\n\t  return getSC().concat([getDeclDelim()]).concat(getSC());\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkBlockdecl4(i) {\r\n\t  return checkSC(i);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getBlockdecl4() {\r\n\t  return getSC();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of text inside square brackets, e.g. `[1]`\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkBrackets(i) {\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftSquareBracket) return 0;\r\n\r\n\t  return tokens[i].right - i + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with text inside square brackets, e.g. `[1]`\r\n\t * @returns {Node}\r\n\t */\r\n\tfunction getBrackets() {\r\n\t  var startPos = pos++;\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var tsets = getTsets();\r\n\r\n\t  var end = getLastPosition(tsets, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(NodeType.BracketsType, tsets, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a class selector (e.g. `.abc`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the class selector\r\n\t */\r\n\tfunction checkClass(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].class_l) return tokens[i].class_l;\r\n\r\n\t  if (tokens[i++].type === TokenType.FullStop) {\r\n\t    if (l = checkInterpolatedVariable(i)) tokens[i].class_child = 1;else if (l = checkIdent(i)) tokens[i].class_child = 2;else return 0;\r\n\r\n\t    tokens[i].class_l = l + 1;\r\n\t    return l + 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a class selector\r\n\t * @returns {Array} `['class', ['ident', x]]` where x is a class's\r\n\t *      identifier (without `.`, e.g. `abc`).\r\n\t */\r\n\tfunction getClass() {\r\n\t  var startPos = pos++;\r\n\t  var content = [];\r\n\r\n\t  var childType = tokens[pos].class_child;\r\n\t  if (childType === 1) content.push(getInterpolatedVariable());else content.push(getIdent());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ClassType, content, token.ln, token.col);\r\n\t}\r\n\r\n\tfunction checkCombinator(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkCombinator1(i)) tokens[i].combinatorType = 1;else if (l = checkCombinator2(i)) tokens[i].combinatorType = 2;else if (l = checkCombinator3(i)) tokens[i].combinatorType = 3;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getCombinator() {\r\n\t  var type = tokens[pos].combinatorType;\r\n\t  if (type === 1) return getCombinator1();\r\n\t  if (type === 2) return getCombinator2();\r\n\t  if (type === 3) return getCombinator3();\r\n\t}\r\n\t/**\r\n\t * (1) `||`\r\n\t */\r\n\tfunction checkCombinator1(i) {\r\n\t  if (tokens[i].type === TokenType.VerticalLine && tokens[i + 1].type === TokenType.VerticalLine) return 2;else return 0;\r\n\t}\r\n\r\n\tfunction getCombinator1() {\r\n\t  var type = NodeType.CombinatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '||';\r\n\r\n\t  pos += 2;\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `>`\r\n\t * (2) `+`\r\n\t * (3) `~`\r\n\t */\r\n\tfunction checkCombinator2(i) {\r\n\t  var type = tokens[i].type;\r\n\t  if (type === TokenType.PlusSign || type === TokenType.GreaterThanSign || type === TokenType.Tilde) return 1;else return 0;\r\n\t}\r\n\r\n\tfunction getCombinator2() {\r\n\t  var type = NodeType.CombinatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = tokens[pos++].value;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `/panda/`\r\n\t */\r\n\tfunction checkCombinator3(i) {\r\n\t  var start = i;\r\n\r\n\t  if (tokens[i].type === TokenType.Solidus) i++;else return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.Solidus) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getCombinator3() {\r\n\t  var type = NodeType.CombinatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  // Skip `/`.\r\n\t  pos++;\r\n\t  var ident = getIdent();\r\n\r\n\t  // Skip `/`.\r\n\t  pos++;\r\n\r\n\t  var content = '/' + ident.content + '/';\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a multiline comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a multiline comment, otherwise `0`\r\n\t */\r\n\tfunction checkCommentML(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.CommentML ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a multiline comment\r\n\t * @returns {Array} `['commentML', x]` where `x`\r\n\t *      is the comment's text (without `/*` and `* /`).\r\n\t */\r\n\tfunction getCommentML() {\r\n\t  var startPos = pos;\r\n\t  var s = tokens[pos].value.substring(2);\r\n\t  var l = s.length;\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  if (s.charAt(l - 2) === '*' && s.charAt(l - 1) === '/') s = s.substring(0, l - 2);\r\n\r\n\t  var end = getLastPosition(s, line, column, 2);\r\n\t  if (end[0] === line) end[1] += 2;\r\n\t  pos++;\r\n\r\n\t  return newNode(NodeType.CommentMLType, s, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a single-line comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a single-line comment, otherwise `0`\r\n\t */\r\n\tfunction checkCommentSL(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.CommentSL ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a single-line comment.\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getCommentSL() {\r\n\t  var startPos = pos;\r\n\t  var x = tokens[pos++].value.substring(2);\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  var end = getLastPosition(x, line, column + 2);\r\n\t  return newNode(NodeType.CommentSLType, x, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a condition.\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the condition\r\n\t */\r\n\tfunction checkCondition(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if ((l = checkIdent(i)) && tokens[i].value === 'when') i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkBlock(i)) {\r\n\t      tokens[i].condition_child = 0;\r\n\t      break;\r\n\t    } else if (l = checkFunction(i)) tokens[i].condition_child = 1;else if (l = checkBrackets(i)) tokens[i].condition_child = 2;else if (l = checkParentheses(i)) tokens[i].condition_child = 3;else if (l = checkVariable(i)) tokens[i].condition_child = 4;else if (l = checkIdent(i)) tokens[i].condition_child = 5;else if (l = checkNumber(i)) tokens[i].condition_child = 6;else if (l = checkDelim(i)) tokens[i].condition_child = 7;else if (l = checkOperator(i)) tokens[i].condition_child = 8;else if (l = checkCombinator(i)) tokens[i].condition_child = 9;else if (l = checkSC(i)) tokens[i].condition_child = 10;else if (l = checkString(i)) tokens[i].condition_child = 11;else return 0;\r\n\r\n\t    i += l;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a condition.\r\n\t * @returns {Array} `['condition', x]`\r\n\t */\r\n\tfunction getCondition() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  x.push(getIdent());\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    var childType = tokens[pos].condition_child;\r\n\r\n\t    if (childType === 0) break;else if (childType === 1) x.push(getFunction());else if (childType === 2) x.push(getBrackets());else if (childType === 3) x.push(getParentheses());else if (childType === 4) x.push(getVariable());else if (childType === 5) x.push(getIdent());else if (childType === 6) x.push(getNumber());else if (childType === 7) x.push(getDelim());else if (childType === 8) x.push(getOperator());else if (childType === 9) x.push(getCombinator());else if (childType === 10) x = x.concat(getSC());else if (childType === 11) x.push(getString());\r\n\t  }\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ConditionType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the declaration\r\n\t */\r\n\tfunction checkDeclaration(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkProperty(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkPropertyDelim(i)) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkValue(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a declaration\r\n\t * @returns {Array} `['declaration', ['property', x], ['propertyDelim'],\r\n\t *       ['value', y]]`\r\n\t */\r\n\tfunction getDeclaration() {\r\n\t  var startPos = pos;\r\n\t  var x = [getProperty()].concat(getSC()).concat([getPropertyDelim()]).concat(getSC()).concat([getValue()]);\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.DeclarationType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a semicolon\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a semicolon, otherwise `0`\r\n\t */\r\n\tfunction checkDeclDelim(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Semicolon ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a semicolon\r\n\t * @returns {Array} `['declDelim']`\r\n\t */\r\n\tfunction getDeclDelim() {\r\n\t  var startPos = pos++;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.DeclDelimType, ';', token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a comma\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a comma, otherwise `0`\r\n\t */\r\n\tfunction checkDelim(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Comma ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a comma\r\n\t * @returns {Array} `['delim']`\r\n\t */\r\n\tfunction getDelim() {\r\n\t  var startPos = pos++;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.DelimType, ',', token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a number with dimension unit (e.g. `10px`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkDimension(i) {\r\n\t  var ln = checkNumber(i);\r\n\t  var li = undefined;\r\n\r\n\t  if (i >= tokensLength || !ln || i + ln >= tokensLength) return 0;\r\n\r\n\t  return (li = checkNmName2(i + ln)) ? ln + li : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node of a number with dimension unit\r\n\t * @returns {Array} `['dimension', ['number', x], ['ident', y]]` where\r\n\t *      `x` is a number converted to string (e.g. `'10'`) and `y` is\r\n\t *      a dimension unit (e.g. `'px'`).\r\n\t */\r\n\tfunction getDimension() {\r\n\t  var startPos = pos;\r\n\t  var x = [getNumber()];\r\n\t  var token = tokens[pos];\r\n\t  var ident = newNode(NodeType.IdentType, getNmName2(), token.ln, token.col);\r\n\r\n\t  x.push(ident);\r\n\r\n\t  token = tokens[startPos];\r\n\t  return newNode(NodeType.DimensionType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an escaped string (e.g. `~\"ms:something\"`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the string (including `~` and quotes)\r\n\t */\r\n\tfunction checkEscapedString(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.Tilde && (l = checkString(i + 1))) return i + l - start;else return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an escaped string\r\n\t * @returns {Array} `['escapedString', ['string', x]]` where `x` is a string\r\n\t *      without `~` but with quotes\r\n\t */\r\n\tfunction getEscapedString() {\r\n\t  var startPos = pos++;\r\n\t  var x = tokens[pos++].value;\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  var end = getLastPosition(x, line, column + 1);\r\n\t  return newNode(NodeType.EscapedStringType, x, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkExpression(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].value !== 'expression' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  return tokens[i].right - start + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getExpression() {\r\n\t  var startPos = pos++;\r\n\t  var x = undefined;\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  x = joinValues(pos + 1, tokens[pos].right - 1);\r\n\t  var end = getLastPosition(x, line, column, 1);\r\n\t  if (end[0] === line) end[1] += 11;\r\n\t  pos = tokens[pos].right + 1;\r\n\r\n\t  return newNode(NodeType.ExpressionType, x, token.ln, token.col, end);\r\n\t}\r\n\r\n\tfunction checkExtend(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l;\r\n\t  if (l = checkExtend1(i)) tokens[i].extendType = 1;else if (l = checkExtend2(i)) tokens[i].extendType = 2;else return 0;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getExtend() {\r\n\t  var childType = tokens[pos].extendType;\r\n\t  if (childType === 1) return getExtend1();\r\n\t  if (childType === 2) return getExtend2();\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `selector:extend(selector) {...}`\r\n\t */\r\n\tfunction checkExtend1(i) {\r\n\t  var start = i;\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkExtendSelector(i)) i += l;else return 0;\r\n\r\n\t  if (tokens[i + 1] && tokens[i + 1].value === 'extend' && (l = checkPseudoc(i))) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getExtend1() {\r\n\t  var startPos = pos;\r\n\t  var x = [].concat(getExtendSelector(), [getPseudoc()], getSC(), [getBlock()]);\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ExtendType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `selector:extend(selector)`\r\n\t */\r\n\tfunction checkExtend2(i) {\r\n\t  var start = i;\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkExtendSelector(i)) i += l;else return 0;\r\n\r\n\t  if (tokens[i + 1] && tokens[i + 1].value === 'extend' && (l = checkPseudoc(i))) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getExtend2() {\r\n\t  var startPos = pos;\r\n\t  var x = [].concat(getExtendSelector(), [getPseudoc()]);\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ExtendType, x, token.ln, token.col);\r\n\t}\r\n\r\n\tfunction checkExtendSelector(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkParentSelectorWithExtension(i)) tokens[i].extend_type = 1;else if (l = checkIdent(i)) tokens[i].extend_type = 2;else if (l = checkClass(i)) tokens[i].extend_type = 3;else if (l = checkShash(i)) tokens[i].extend_type = 4;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getExtendSelector() {\r\n\t  var childType = tokens[pos].extend_type;\r\n\r\n\t  if (childType === 1) return getParentSelectorWithExtension();\r\n\t  if (childType === 2) return [getIdent()];\r\n\t  if (childType === 3) return [getClass()];\r\n\t  if (childType === 4) return [getShash()];\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkFunction(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i < tokensLength && tokens[i].type === TokenType.LeftParenthesis ? tokens[i].right - start + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getFunction() {\r\n\t  var token = tokens[pos];\r\n\t  var ident = getIdent();\r\n\t  var x = [ident];\r\n\t  var body;\r\n\r\n\t  body = getArguments();\r\n\r\n\t  x.push(body);\r\n\r\n\t  return newNode(NodeType.FunctionType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getArguments() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\t  var body = undefined;\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  pos++;\r\n\r\n\t  while (pos < tokensLength && tokens[pos].type !== TokenType.RightParenthesis) {\r\n\t    if (checkDeclaration(pos)) x.push(getDeclaration());else if (checkArgument(pos)) {\r\n\t      body = getArgument();\r\n\t      if (typeof body.content === 'string') x.push(body);else x = x.concat(body);\r\n\t    } else if (checkClass(pos)) x.push(getClass());else throwError(pos);\r\n\t  }\r\n\r\n\t  var end = getLastPosition(x, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(NodeType.ArgumentsType, x, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an identifier\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the identifier\r\n\t */\r\n\tfunction checkIdent(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.HyphenMinus) i++;\r\n\r\n\t  if (tokens[i].type === TokenType.LowLine || tokens[i].type === TokenType.Identifier) i++;else return 0;\r\n\r\n\t  for (; i < tokensLength; i++) {\r\n\t    if (tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier && tokens[i].type !== TokenType.DecimalNumber) break;\r\n\t  }\r\n\r\n\t  tokens[start].ident_last = i - 1;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an identifier\r\n\t * @returns {Array} `['ident', x]` where `x` is identifier's name\r\n\t */\r\n\tfunction getIdent() {\r\n\t  var startPos = pos;\r\n\t  var x = joinValues(pos, tokens[pos].ident_last);\r\n\r\n\t  pos = tokens[pos].ident_last + 1;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.IdentType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {number} i Token's index number\r\n\t * @returns {number} Length of the identifier\r\n\t */\r\n\tfunction checkPartialIdent(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  for (; i < tokensLength; i++) {\r\n\t    if (tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier && tokens[i].type !== TokenType.DecimalNumber) break;\r\n\t  }\r\n\r\n\t  tokens[start].ident_last = i - 1;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of `!important` word\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkImportant(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].value === 'important') {\r\n\t    tokens[start].importantEnd = i;\r\n\t    return i - start + 1;\r\n\t  } else {\r\n\t    return 0;\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with `!important` word\r\n\t * @returns {Array} `['important', sc]` where `sc` is optional whitespace\r\n\t */\r\n\tfunction getImportant() {\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = joinValues(pos, token.importantEnd);\r\n\r\n\t  pos = token.importantEnd + 1;\r\n\r\n\t  return newNode(NodeType.ImportantType, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of an include (`@include` or `@extend` directive).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkInclude(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkInclude1(i)) tokens[i].include_type = 1;else if (l = checkInclude2(i)) tokens[i].include_type = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with included mixin\r\n\t * @returns {Array} `['include', x]`\r\n\t */\r\n\tfunction getInclude() {\r\n\t  switch (tokens[pos].include_type) {\r\n\t    case 1:\r\n\t      return getInclude1();\r\n\t    case 2:\r\n\t      return getInclude2();\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkInclude1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkClass(i) || checkShash(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkClass(i) || checkShash(i) || checkSC(i)) i += l;else if (tokens[i].type === TokenType.GreaterThanSign) i++;else break;\r\n\t  }\r\n\r\n\t  if (l = checkArguments(i)) i += l;else return 0;\r\n\r\n\t  if (i < tokensLength && (l = checkSC(i))) i += l;\r\n\r\n\t  if (i < tokensLength && (l = checkImportant(i))) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array} `['include', x]`\r\n\t */\r\n\tfunction getInclude1() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  x.push(checkClass(pos) ? getClass() : getShash());\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    if (checkClass(pos)) x.push(getClass());else if (checkShash(pos)) x.push(getShash());else if (checkSC(pos)) x = x.concat(getSC());else if (checkOperator(pos)) x.push(getOperator());else break;\r\n\t  }\r\n\r\n\t  x.push(getArguments());\r\n\r\n\t  x = x.concat(getSC());\r\n\r\n\t  if (checkImportant(pos)) x.push(getImportant());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.IncludeType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkInclude2(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkClass(i) || checkShash(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkClass(i) || checkShash(i) || checkSC(i)) i += l;else if (tokens[i].type === TokenType.GreaterThanSign) i++;else break;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array} `['include', x]`\r\n\t */\r\n\tfunction getInclude2() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  x.push(checkClass(pos) ? getClass() : getShash());\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    if (checkClass(pos)) x.push(getClass());else if (checkShash(pos)) x.push(getShash());else if (checkSC(pos)) x = x.concat(getSC());else if (checkOperator(pos)) x.push(getOperator());else break;\r\n\t  }\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.IncludeType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of LESS interpolated variable\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkInterpolatedVariable(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].type !== TokenType.CommercialAt || !tokens[i + 1] || tokens[i + 1].type !== TokenType.LeftCurlyBracket) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  i += 2;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return tokens[i].type === TokenType.RightCurlyBracket ? i - start + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with LESS interpolated variable\r\n\t * @returns {Array} `['interpolatedVariable', x]`\r\n\t */\r\n\tfunction getInterpolatedVariable() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  // Skip `@{`:\r\n\t  pos += 2;\r\n\r\n\t  x.push(getIdent());\r\n\r\n\t  // Skip `}`:\r\n\t  var end = getLastPosition(x, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(NodeType.InterpolatedVariableType, x, line, column, end);\r\n\t}\r\n\r\n\tfunction checkKeyframesBlock(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkKeyframesSelector(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getKeyframesBlock() {\r\n\t  var type = NodeType.RulesetType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [].concat([getKeyframesSelector()], getSC(), [getBlock()]);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkKeyframesBlocks(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkKeyframesBlock(i)) i += l;else return 0;\r\n\r\n\t  while (tokens[i].type !== TokenType.RightCurlyBracket) {\r\n\t    if (l = checkSC(i)) i += l;else if (l = checkKeyframesBlock(i)) i += l;else break;\r\n\t  }\r\n\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getKeyframesBlocks() {\r\n\t  var type = NodeType.BlockType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\t  var keyframesBlocksEnd = token.right;\r\n\r\n\t  // Skip `{`.\r\n\t  pos++;\r\n\r\n\t  while (pos < keyframesBlocksEnd) {\r\n\t    if (checkSC(pos)) content = content.concat(getSC());else if (checkKeyframesBlock(pos)) content.push(getKeyframesBlock());\r\n\t  }\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\r\n\t  // Skip `}`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a @keyframes rule.\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the @keyframes rule\r\n\t */\r\n\tfunction checkKeyframesRule(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkAtkeyword(i)) i += l;else return 0;\r\n\r\n\t  var atruleName = joinValues2(i - l, l);\r\n\t  if (atruleName.indexOf('keyframes') === -1) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkKeyframesBlocks(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getKeyframesRule() {\r\n\t  var type = NodeType.AtruleType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [].concat([getAtkeyword()], getSC(), [getIdent()], getSC(), [getKeyframesBlocks()]);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkKeyframesSelector(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) {\r\n\t    // Valid selectors are only `from` and `to`.\r\n\t    var selector = joinValues2(i, l);\r\n\t    if (selector !== 'from' && selector !== 'to') return 0;\r\n\r\n\t    i += l;\r\n\t    tokens[start].keyframesSelectorType = 1;\r\n\t  } else if (l = checkPercentage(i)) {\r\n\t    i += l;\r\n\t    tokens[start].keyframesSelectorType = 2;\r\n\t  } else {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getKeyframesSelector() {\r\n\t  var keyframesSelectorType = NodeType.KeyframesSelectorType;\r\n\t  var selectorType = NodeType.SelectorType;\r\n\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (token.keyframesSelectorType === 1) {\r\n\t    content.push(getIdent());\r\n\t  } else {\r\n\t    content.push(getPercentage());\r\n\t  }\r\n\r\n\t  var keyframesSelector = newNode(keyframesSelectorType, content, line, column);\r\n\t  return newNode(selectorType, [keyframesSelector], line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a LESS mixin\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the mixin\r\n\t */\r\n\tfunction checkMixin(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkMixin1(i)) tokens[i].mixin_type = 1;else if (l = checkMixin2(i)) tokens[i].mixin_type = 2;else return 0;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getMixin() {\r\n\t  switch (tokens[pos].mixin_type) {\r\n\t    case 1:\r\n\t      return getMixin1();\r\n\t    case 2:\r\n\t      return getMixin2();\r\n\t  }\r\n\t}\r\n\r\n\tfunction checkMixin1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkClass(i) || checkShash(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkArguments(i)) i += l;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a mixin\r\n\t * @returns {Array} `['mixin', x]`\r\n\t */\r\n\tfunction getMixin1() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  x.push(checkClass(pos) ? getClass() : getShash());\r\n\r\n\t  x = x.concat(getSC());\r\n\r\n\t  if (checkArguments(pos)) x.push(getArguments());\r\n\r\n\t  x = x.concat(getSC());\r\n\r\n\t  if (checkBlock(pos)) x.push(getBlock());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.MixinType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a LESS mixin\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the mixin\r\n\t */\r\n\tfunction checkMixin2(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkClass(i) || checkShash(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkArguments(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a mixin\r\n\t * @returns {Array} `['mixin', x]`\r\n\t */\r\n\tfunction getMixin2() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  x.push(checkClass(pos) ? getClass() : getShash());\r\n\r\n\t  x = x.concat(getSC());\r\n\r\n\t  if (checkArguments(pos)) x.push(getArguments());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.MixinType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a namespace sign (`|`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is `|`, `0` if not\r\n\t */\r\n\tfunction checkNamespace(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.VerticalLine ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a namespace sign\r\n\t * @returns {Array} `['namespace']`\r\n\t */\r\n\tfunction getNamespace() {\r\n\t  var startPos = pos++;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.NamespaceType, '|', token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkNmName2(i) {\r\n\t  if (tokens[i].type === TokenType.Identifier) return 1;else if (tokens[i].type !== TokenType.DecimalNumber) return 0;\r\n\r\n\t  i++;\r\n\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Identifier ? 2 : 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {String}\r\n\t */\r\n\tfunction getNmName2() {\r\n\t  var s = tokens[pos].value;\r\n\r\n\t  if (tokens[pos++].type === TokenType.DecimalNumber && pos < tokensLength && tokens[pos].type === TokenType.Identifier) s += tokens[pos++].value;\r\n\r\n\t  return s;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a number\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of number\r\n\t */\r\n\tfunction checkNumber(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].number_l) return tokens[i].number_l;\r\n\r\n\t  // `10`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.DecimalNumber && (!tokens[i + 1] || tokens[i + 1] && tokens[i + 1].type !== TokenType.FullStop)) {\r\n\t    tokens[i].number_l = 1;\r\n\t    return 1;\r\n\t  }\r\n\r\n\t  // `10.`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && (!tokens[i + 2] || tokens[i + 2].type !== TokenType.DecimalNumber)) {\r\n\t    tokens[i].number_l = 2;\r\n\t    return 2;\r\n\t  }\r\n\r\n\t  // `.10`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.FullStop && tokens[i + 1].type === TokenType.DecimalNumber) {\r\n\t    tokens[i].number_l = 2;\r\n\t    return 2;\r\n\t  }\r\n\r\n\t  // `10.10`:\r\n\t  if (i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && tokens[i + 2] && tokens[i + 2].type === TokenType.DecimalNumber) {\r\n\t    tokens[i].number_l = 3;\r\n\t    return 3;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with number\r\n\t * @returns {Array} `['number', x]` where `x` is a number converted\r\n\t *      to string.\r\n\t */\r\n\tfunction getNumber() {\r\n\t  var x = '';\r\n\t  var startPos = pos;\r\n\t  var l = tokens[pos].number_l;\r\n\r\n\t  for (var j = 0; j < l; j++) {\r\n\t    x += tokens[pos + j].value;\r\n\t  }\r\n\r\n\t  pos += l;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.NumberType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is an operator (`/`, `,`, `:`, `=`, `>`, `<` or `*`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is an operator, otherwise `0`\r\n\t */\r\n\tfunction checkOperator(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  switch (tokens[i].type) {\r\n\t    case TokenType.Solidus:\r\n\t    case TokenType.Comma:\r\n\t    case TokenType.Colon:\r\n\t    case TokenType.EqualsSign:\r\n\t    case TokenType.LessThanSign:\r\n\t    case TokenType.GreaterThanSign:\r\n\t    case TokenType.Asterisk:\r\n\t      return 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an operator\r\n\t * @returns {Array} `['operator', x]` where `x` is an operator converted\r\n\t *      to string.\r\n\t */\r\n\tfunction getOperator() {\r\n\t  var startPos = pos;\r\n\t  var x = tokens[pos++].value;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.OperatorType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of text inside parentheses, e.g. `(1)`\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */\r\n\tfunction checkParentheses(i) {\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  return tokens[i].right - i + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with text inside parentheses, e.g. `(1)`\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getParentheses() {\r\n\t  var type = NodeType.ParenthesesType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  pos++;\r\n\r\n\t  var tsets = getTsets();\r\n\r\n\t  var end = getLastPosition(tsets, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(type, tsets, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a parent selector (`&`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkParentSelector(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Ampersand ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a parent selector\r\n\t * @returns {Array} `['parentSelector']`\r\n\t */\r\n\tfunction getParentSelector() {\r\n\t  var startPos = pos++;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ParentSelectorType, '&', token.ln, token.col);\r\n\t}\r\n\r\n\tfunction checkParentSelectorExtension(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkNumber(i) || checkPartialIdent(i)) i += l;else break;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getParentSelectorExtension() {\r\n\t  var type = NodeType.ParentSelectorExtensionType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    if (checkNumber(pos)) content.push(getNumber());else if (checkPartialIdent(pos)) content.push(getIdent());else break;\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkParentSelectorWithExtension(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkParentSelector(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkParentSelectorExtension(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getParentSelectorWithExtension() {\r\n\t  var content = [getParentSelector()];\r\n\r\n\t  if (checkParentSelectorExtension(pos)) content.push(getParentSelectorExtension());\r\n\r\n\t  return content;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a number with percent sign (e.g. `10%`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkPercentage(i) {\r\n\t  var x;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  x = checkNumber(i);\r\n\r\n\t  if (!x || i + x >= tokensLength) return 0;\r\n\r\n\t  return tokens[i + x].type === TokenType.PercentSign ? x + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node of number with percent sign\r\n\t * @returns {Array} `['percentage', ['number', x]]` where `x` is a number\r\n\t *      (without percent sign) converted to string.\r\n\t */\r\n\tfunction getPercentage() {\r\n\t  var startPos = pos;\r\n\t  var x = [getNumber()];\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  var end = getLastPosition(x, line, column, 1);\r\n\t  pos++;\r\n\r\n\t  return newNode(NodeType.PercentageType, x, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkProgid(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (joinValues2(i, 6) === 'progid:DXImageTransform.Microsoft.') i += 6;else return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.LeftParenthesis) {\r\n\t    tokens[start].progid_end = tokens[i].right;\r\n\t    i = tokens[i].right + 1;\r\n\t  } else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getProgid() {\r\n\t  var startPos = pos;\r\n\t  var progid_end = tokens[pos].progid_end;\r\n\t  var x = joinValues(pos, progid_end);\r\n\r\n\t  pos = progid_end + 1;\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ProgidType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a property\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the property\r\n\t */\r\n\tfunction checkProperty(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkVariable(i) || checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a property\r\n\t * @returns {Array} `['property', x]`\r\n\t */\r\n\tfunction getProperty() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  if (checkVariable(pos)) x.push(getVariable());else x.push(getIdent());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.PropertyType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a colon\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a colon, otherwise `0`\r\n\t */\r\n\tfunction checkPropertyDelim(i) {\r\n\t  return i < tokensLength && tokens[i].type === TokenType.Colon ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a colon\r\n\t * @returns {Array} `['propertyDelim']`\r\n\t */\r\n\tfunction getPropertyDelim() {\r\n\t  var startPos = pos++;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.PropertyDelimType, ':', token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkPseudo(i) {\r\n\t  return checkPseudoe(i) || checkPseudoc(i);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getPseudo() {\r\n\t  if (checkPseudoe(pos)) return getPseudoe();\r\n\t  if (checkPseudoc(pos)) return getPseudoc();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkPseudoe(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].type !== TokenType.Colon || i >= tokensLength || tokens[i++].type !== TokenType.Colon) return 0;\r\n\r\n\t  return (l = checkInterpolatedVariable(i) || checkIdent(i)) ? l + 2 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getPseudoe() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  pos += 2;\r\n\r\n\t  if (checkInterpolatedVariable(pos)) {\r\n\t    x.push(getInterpolatedVariable());\r\n\t  } else {\r\n\t    x.push(getIdent());\r\n\t  }\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.PseudoeType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkPseudoc(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.Colon) return 0;\r\n\r\n\t  if (l = checkPseudoClass3(i)) tokens[i].pseudoClassType = 3;else if (l = checkPseudoClass4(i)) tokens[i].pseudoClassType = 4;else if (l = checkPseudoClass5(i)) tokens[i].pseudoClassType = 5;else if (l = checkPseudoClass1(i)) tokens[i].pseudoClassType = 1;else if (l = checkPseudoClass2(i)) tokens[i].pseudoClassType = 2;else if (l = checkPseudoClass6(i)) tokens[i].pseudoClassType = 6;else return 0;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getPseudoc() {\r\n\t  var childType = tokens[pos].pseudoClassType;\r\n\t  if (childType === 1) return getPseudoClass1();\r\n\t  if (childType === 2) return getPseudoClass2();\r\n\t  if (childType === 3) return getPseudoClass3();\r\n\t  if (childType === 4) return getPseudoClass4();\r\n\t  if (childType === 5) return getPseudoClass5();\r\n\t  if (childType === 6) return getPseudoClass6();\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `:not(selector)`\r\n\t * (2) `:extend(selector, selector)`\r\n\t */\r\n\tfunction checkPseudoClass1(i) {\r\n\t  var start = i;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSelectorsGroup(i)) i += l;else return 0;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return right - start + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:not(panda)`\r\n\t */\r\n\tfunction getPseudoClass1() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  content.push(getIdent());\r\n\r\n\t  {\r\n\t    var _type = NodeType.ArgumentsType;\r\n\t    var _token = tokens[pos];\r\n\t    var _line = _token.ln;\r\n\t    var _column = _token.col;\r\n\r\n\t    // Skip `(`.\r\n\t    pos++;\r\n\r\n\t    var selectors = getSelectorsGroup();\r\n\t    var end = getLastPosition(selectors, _line, _column, 1);\r\n\t    var args = newNode(_type, selectors, _line, _column, end);\r\n\t    content.push(args);\r\n\r\n\t    // Skip `)`.\r\n\t    pos++;\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `:nth-child(odd)`\r\n\t * (2) `:nth-child(even)`\r\n\t * (3) `:lang(de-DE)`\r\n\t */\r\n\tfunction checkPseudoClass2(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass2() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  {\r\n\t    // Skip `(`.\r\n\t    pos++;\r\n\r\n\t    var l = tokens[pos].ln;\r\n\t    var c = tokens[pos].col;\r\n\t    var value = [];\r\n\r\n\t    value = value.concat(getSC());\r\n\t    value.push(getIdent());\r\n\t    value = value.concat(getSC());\r\n\r\n\t    var end = getLastPosition(value, l, c, 1);\r\n\t    var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t    content.push(args);\r\n\r\n\t    // Skip `)`.\r\n\t    pos++;\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:nth-child(-3n + 2)`\r\n\t */\r\n\tfunction checkPseudoClass3(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkUnary(i)) i += l;\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].value === 'n') i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].value === '+' || tokens[i].value === '-') i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass3() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  var l = tokens[pos].ln;\r\n\t  var c = tokens[pos].col;\r\n\t  var value = [];\r\n\r\n\t  // Skip `(`.\r\n\t  pos++;\r\n\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\r\n\t  {\r\n\t    var _l = tokens[pos].ln;\r\n\t    var _c = tokens[pos].col;\r\n\t    var _content = tokens[pos].value;\r\n\t    var _ident = newNode(NodeType.IdentType, _content, _l, _c);\r\n\t    value.push(_ident);\r\n\t    pos++;\r\n\t  }\r\n\r\n\t  value = value.concat(getSC());\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  value = value.concat(getSC());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\t  value = value.concat(getSC());\r\n\r\n\t  var end = getLastPosition(value, l, c, 1);\r\n\t  var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t  content.push(args);\r\n\r\n\t  // Skip `)`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:nth-child(-3n)`\r\n\t */\r\n\tfunction checkPseudoClass4(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkUnary(i)) i += l;\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;\r\n\r\n\t  if (tokens[i].value === 'n') i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass4() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  // Skip `(`.\r\n\t  pos++;\r\n\r\n\t  var l = tokens[pos].ln;\r\n\t  var c = tokens[pos].col;\r\n\t  var value = [];\r\n\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\t  if (checkIdent(pos)) value.push(getIdent());\r\n\t  value = value.concat(getSC());\r\n\r\n\t  var end = getLastPosition(value, l, c, 1);\r\n\t  var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t  content.push(args);\r\n\r\n\t  // Skip `)`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:nth-child(+8)`\r\n\t */\r\n\tfunction checkPseudoClass5(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\t  if (tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  var right = tokens[i].right;\r\n\r\n\t  // Skip `(`.\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkUnary(i)) i += l;\r\n\t  if (tokens[i].type === TokenType.DecimalNumber) i++;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (i !== right) return 0;\r\n\r\n\t  return i - start + 1;\r\n\t}\r\n\r\n\tfunction getPseudoClass5() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  // Skip `(`.\r\n\t  pos++;\r\n\r\n\t  var l = tokens[pos].ln;\r\n\t  var c = tokens[pos].col;\r\n\t  var value = [];\r\n\r\n\t  if (checkUnary(pos)) value.push(getUnary());\r\n\t  if (checkNumber(pos)) value.push(getNumber());\r\n\t  value = value.concat(getSC());\r\n\r\n\t  var end = getLastPosition(value, l, c, 1);\r\n\t  var args = newNode(NodeType.ArgumentsType, value, l, c, end);\r\n\t  content.push(args);\r\n\r\n\t  // Skip `)`.\r\n\t  pos++;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (-) `:checked`\r\n\t */\r\n\tfunction checkPseudoClass6(i) {\r\n\t  var start = i;\r\n\t  var l = 0;\r\n\r\n\t  // Skip `:`.\r\n\t  i++;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkInterpolatedVariable(i)) i += l;else if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getPseudoClass6() {\r\n\t  var type = NodeType.PseudocType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `:`.\r\n\t  pos++;\r\n\r\n\t  var ident = checkInterpolatedVariable(pos) ? getInterpolatedVariable() : getIdent();\r\n\t  content.push(ident);\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkRuleset(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkSelectorsGroup(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkBlock(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getRuleset() {\r\n\t  var type = NodeType.RulesetType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  content = content.concat(getSelectorsGroup());\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getBlock());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is marked as a space (if it's a space or a tab\r\n\t *      or a line break).\r\n\t * @param {Number} i\r\n\t * @returns {Number} Number of spaces in a row starting with the given token.\r\n\t */\r\n\tfunction checkS(i) {\r\n\t  return i < tokensLength && tokens[i].ws ? tokens[i].ws_last - i + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with spaces\r\n\t * @returns {Array} `['s', x]` where `x` is a string containing spaces\r\n\t */\r\n\tfunction getS() {\r\n\t  var startPos = pos;\r\n\t  var x = joinValues(pos, tokens[pos].ws_last);\r\n\r\n\t  pos = tokens[pos].ws_last + 1;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.SType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a space or a comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Number of similar (space or comment) tokens\r\n\t *      in a row starting with the given token.\r\n\t */\r\n\tfunction checkSC(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l = undefined;\r\n\t  var lsc = 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (!(l = checkS(i)) && !(l = checkCommentML(i)) && !(l = checkCommentSL(i))) break;\r\n\t    i += l;\r\n\t    lsc += l;\r\n\t  }\r\n\r\n\t  return lsc || 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with spaces and comments\r\n\t * @returns {Array} Array containing nodes with spaces (if there are any)\r\n\t *      and nodes with comments (if there are any):\r\n\t *      `[['s', x]*, ['comment', y]*]` where `x` is a string of spaces\r\n\t *      and `y` is a comment's text (without `/*` and `* /`).\r\n\t */\r\n\tfunction getSC() {\r\n\t  var sc = [];\r\n\r\n\t  if (pos >= tokensLength) return sc;\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    if (checkS(pos)) sc.push(getS());else if (checkCommentML(pos)) sc.push(getCommentML());else if (checkCommentSL(pos)) sc.push(getCommentSL());else break;\r\n\t  }\r\n\r\n\t  return sc;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      a simple selector\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkShash(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.NumberSign) return 0;\r\n\r\n\t  if (l = checkInterpolatedVariable(i + 1) || checkIdent(i + 1)) return l + 1;else return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside a simple\r\n\t *      selector\r\n\t * @returns {Array} `['shash', x]` where `x` is a hexadecimal number\r\n\t *      converted to string (without `#`, e.g. `fff`)\r\n\t */\r\n\tfunction getShash() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  pos++;\r\n\r\n\t  if (checkInterpolatedVariable(pos)) x.push(getInterpolatedVariable());else x.push(getIdent());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ShashType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a string (text wrapped in quotes)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is part of a string, `0` if not\r\n\t */\r\n\tfunction checkString(i) {\r\n\t  if (i >= tokensLength) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  if (tokens[i].type === TokenType.StringSQ || tokens[i].type === TokenType.StringDQ) {\r\n\t    return 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get string's node\r\n\t * @returns {Array} `['string', x]` where `x` is a string (including\r\n\t *      quotes).\r\n\t */\r\n\tfunction getString() {\r\n\t  var startPos = pos;\r\n\t  var x = tokens[pos++].value;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.StringType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Validate stylesheet: it should consist of any number (0 or more) of\r\n\t * rulesets (sets of rules with selectors), @-rules, whitespaces or\r\n\t * comments.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkStylesheet(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  // Check every token:\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkSC(i) || checkAtrule(i) || checkRuleset(i) || checkMixin(i) || checkDeclaration(i) || checkDeclDelim(i)) i += l;else throwError(i);\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array} `['stylesheet', x]` where `x` is all stylesheet's\r\n\t *      nodes.\r\n\t */\r\n\tfunction getStylesheet() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    if (checkSC(pos)) x = x.concat(getSC());else if (checkAtrule(pos)) x.push(getAtrule());else if (checkRuleset(pos)) x.push(getRuleset());else if (checkMixin(pos)) x.push(getMixin());else if (checkDeclaration(pos)) x.push(getDeclaration());else if (checkDeclDelim(pos)) x.push(getDeclDelim());else throwError(pos);\r\n\t  }\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.StylesheetType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkTset(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkVhash(i)) tokens[i].tset_child = 1;else if (l = checkAny(i)) tokens[i].tset_child = 2;else if (l = checkSC(i)) tokens[i].tset_child = 3;else if (l = checkOperator(i)) tokens[i].tset_child = 4;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getTset() {\r\n\t  var childType = tokens[pos].tset_child;\r\n\t  if (childType === 1) return getVhash();else if (childType === 2) return getAny();else if (childType === 3) return getSC();else if (childType === 4) return getOperator();\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkTsets(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  while (l = checkTset(i)) {\r\n\t    i += l;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getTsets() {\r\n\t  var x = [];\r\n\t  var t = undefined;\r\n\r\n\t  while (checkTset(pos)) {\r\n\t    t = getTset();\r\n\t    if (typeof t.content === 'string') x.push(t);else x = x.concat(t);\r\n\t  }\r\n\r\n\t  return x;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is an unary (arithmetical) sign (`+` or `-`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is an unary sign, `0` if not\r\n\t */\r\n\tfunction checkUnary(i) {\r\n\t  if (i >= tokensLength) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  if (tokens[i].type === TokenType.HyphenMinus || tokens[i].type === TokenType.PlusSign) {\r\n\t    return 1;\r\n\t  }\r\n\r\n\t  return 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with an unary (arithmetical) sign (`+` or `-`)\r\n\t * @returns {Array} `['unary', x]` where `x` is an unary sign\r\n\t *      converted to string.\r\n\t */\r\n\tfunction getUnary() {\r\n\t  var startPos = pos;\r\n\t  var x = tokens[pos++].value;\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.OperatorType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a unicode range (single or multiple <urange> nodes)\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Unicode range node's length\r\n\t */\r\n\tfunction checkUnicodeRange(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkUrange(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var spaceBefore = checkSC(i);\r\n\t    var comma = checkDelim(i + spaceBefore);\r\n\t    if (!comma) break;\r\n\r\n\t    var spaceAfter = checkSC(i + spaceBefore + comma);\r\n\t    if (l = checkUrange(i + spaceBefore + comma + spaceAfter)) {\r\n\t      i += spaceBefore + comma + spaceAfter + l;\r\n\t    } else break;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a unicode range node\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getUnicodeRange() {\r\n\t  var type = NodeType.UnicodeRangeType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    if (checkSC(pos)) content = content.concat(getSC());else if (checkDelim(pos)) content.push(getDelim());else if (checkUrange(pos)) content.push(getUrange());else break;\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is a u-range (part of a unicode-range)\r\n\t * (1) `U+416`\r\n\t * (2) `U+400-4ff`\r\n\t * (3) `U+4??`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Urange node's length\r\n\t */\r\n\tfunction checkUrange(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  // Check for unicode prefix (u+ or U+)\r\n\t  if (tokens[i].value === 'U' || tokens[i].value === 'u') i += 1;else return 0;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].value === '+') i += 1;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (l = checkIdent(i)) i += l;else if (l = checkNumber(i)) i += l;else if (l = checkUnary(i)) i += l;else if (l = _checkUnicodeWildcard(i)) i += l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].urangeEnd = i - 1;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a u-range node (part of a unicode-range)\r\n\t * @return {Node}\r\n\t */\r\n\tfunction getUrange() {\r\n\t  var startPos = pos;\r\n\t  var type = NodeType.UrangeType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  content = joinValues(startPos, tokens[startPos].urangeEnd);\r\n\t  pos = tokens[startPos].urangeEnd + 1;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Check for unicode wildcard characters `?`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Wildcard length\r\n\t */\r\n\tfunction _checkUnicodeWildcard(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    if (tokens[i].type === TokenType.QuestionMark) i += 1;else break;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of URI (e.g. `url('/css/styles.css')`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of URI\r\n\t */\r\n\tfunction checkUri(i) {\r\n\t  var start = i;\r\n\r\n\t  if (i >= tokensLength || tokens[i++].value !== 'url' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis) return 0;\r\n\r\n\t  return tokens[i].right - start + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with URI\r\n\t * @returns {Array} `['uri', x]` where `x` is URI's nodes (without `url`\r\n\t *      and braces, e.g. `['string', ''/css/styles.css'']`).\r\n\t */\r\n\tfunction getUri() {\r\n\t  var startPos = pos;\r\n\t  var uriExcluding = {};\r\n\t  var uri = undefined;\r\n\t  var token = undefined;\r\n\t  var l = undefined;\r\n\t  var raw = undefined;\r\n\r\n\t  pos += 2;\r\n\r\n\t  uriExcluding[TokenType.Space] = 1;\r\n\t  uriExcluding[TokenType.Tab] = 1;\r\n\t  uriExcluding[TokenType.Newline] = 1;\r\n\t  uriExcluding[TokenType.LeftParenthesis] = 1;\r\n\t  uriExcluding[TokenType.RightParenthesis] = 1;\r\n\r\n\t  if (checkUri1(pos)) {\r\n\t    uri = [].concat(getSC()).concat([getString()]).concat(getSC());\r\n\t  } else {\r\n\t    uri = getSC();\r\n\t    l = checkExcluding(uriExcluding, pos);\r\n\t    token = tokens[pos];\r\n\t    raw = newNode(NodeType.RawType, joinValues(pos, pos + l), token.ln, token.col);\r\n\r\n\t    uri.push(raw);\r\n\r\n\t    pos += l + 1;\r\n\r\n\t    uri = uri.concat(getSC());\r\n\t  }\r\n\r\n\t  token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var end = getLastPosition(uri, line, column, 1);\r\n\t  pos++;\r\n\t  return newNode(NodeType.UriType, uri, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkUri1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type !== TokenType.StringDQ && tokens[i].type !== TokenType.StringSQ) {\r\n\t    return 0;\r\n\t  }\r\n\r\n\t  i++;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a value\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the value\r\n\t */\r\n\tfunction checkValue(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\t  var s = undefined;\r\n\t  var _i = undefined;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    s = checkSC(i);\r\n\t    _i = i + s;\r\n\r\n\t    if (l = _checkValue(_i)) i += l + s;\r\n\t    if (!l || checkBlock(_i)) break;\r\n\t  }\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction _checkValue(i) {\r\n\t  return checkEscapedString(i) || checkInterpolatedVariable(i) || checkVariable(i) || checkVhash(i) || checkBlock(i) || checkProgid(i) || checkAny(i) || checkAtkeyword(i) || checkOperator(i) || checkImportant(i);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getValue() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\t  var s = undefined;\r\n\t  var _pos = undefined;\r\n\r\n\t  while (pos < tokensLength) {\r\n\t    s = checkSC(pos);\r\n\t    _pos = pos + s;\r\n\r\n\t    if (!_checkValue(_pos)) break;\r\n\r\n\t    if (s) x = x.concat(getSC());\r\n\t    x.push(_getValue());\r\n\t  }\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.ValueType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction _getValue() {\r\n\t  if (checkEscapedString(pos)) return getEscapedString();else if (checkInterpolatedVariable(pos)) return getInterpolatedVariable();else if (checkVariable(pos)) return getVariable();else if (checkVhash(pos)) return getVhash();else if (checkBlock(pos)) return getBlock();else if (checkProgid(pos)) return getProgid();else if (checkAny(pos)) return getAny();else if (checkAtkeyword(pos)) return getAtkeyword();else if (checkOperator(pos)) return getOperator();else if (checkImportant(pos)) return getImportant();\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of LESS variable\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the variable\r\n\t */\r\n\tfunction checkVariable(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.CommercialAt) return 0;\r\n\r\n\t  if (tokens[i - 1] && tokens[i - 1].type === TokenType.CommercialAt && tokens[i - 2] && tokens[i - 2].type === TokenType.CommercialAt) return 0;\r\n\r\n\t  return (l = checkVariable(i + 1) || checkIdent(i + 1)) ? l + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a variable\r\n\t * @returns {Array} `['variable', ['ident', x]]` where `x` is\r\n\t *      a variable name.\r\n\t */\r\n\tfunction getVariable() {\r\n\t  var startPos = pos;\r\n\t  var x = [];\r\n\r\n\t  pos++;\r\n\r\n\t  if (checkVariable(pos)) x.push(getVariable());else x.push(getIdent());\r\n\r\n\t  var token = tokens[startPos];\r\n\t  return newNode(NodeType.VariableType, x, token.ln, token.col);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a variables list (e.g. `@rest...`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkVariablesList(i) {\r\n\t  var d = 0; // Number of dots\r\n\t  var l = undefined;\r\n\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (l = checkVariable(i)) i += l;else return 0;\r\n\r\n\t  while (tokens[i] && tokens[i].type === TokenType.FullStop) {\r\n\t    d++;\r\n\t    i++;\r\n\t  }\r\n\r\n\t  return d === 3 ? l + d : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a variables list\r\n\t * @returns {Array} `['variableslist', ['variable', ['ident', x]]]` where\r\n\t *      `x` is a variable name.\r\n\t */\r\n\tfunction getVariablesList() {\r\n\t  var startPos = pos;\r\n\t  var x = [getVariable()];\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  var end = getLastPosition(x, line, column, 3);\r\n\t  pos += 3;\r\n\r\n\t  return newNode(NodeType.VariablesListType, x, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      some value\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction checkVhash(i) {\r\n\t  var l;\r\n\r\n\t  if (i >= tokensLength || tokens[i].type !== TokenType.NumberSign) return 0;\r\n\r\n\t  return (l = checkNmName2(i + 1)) ? l + 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside some value\r\n\t * @returns {Array} `['vhash', x]` where `x` is a hexadecimal number\r\n\t *      converted to string (without `#`, e.g. `'fff'`).\r\n\t */\r\n\tfunction getVhash() {\r\n\t  var startPos = pos;\r\n\t  var x = undefined;\r\n\t  var token = tokens[startPos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\r\n\t  pos++;\r\n\r\n\t  x = getNmName2();\r\n\t  var end = getLastPosition(x, line, column + 1);\r\n\t  return newNode(NodeType.VhashType, x, line, column, end);\r\n\t}\r\n\r\n\tmodule.exports = function (_tokens, context) {\r\n\t  tokens = _tokens;\r\n\t  tokensLength = tokens.length;\r\n\t  pos = 0;\r\n\r\n\t  return contexts[context]();\r\n\t};\r\n\r\n\tfunction checkSelectorsGroup(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkSelector(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var sb = checkSC(i);\r\n\t    var c = checkDelim(i + sb);\r\n\t    if (!c) break;\r\n\t    var sa = checkSC(i + sb + c);\r\n\t    if (l = checkSelector(i + sb + c + sa)) i += sb + c + sa + l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].selectorsGroupEnd = i;\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getSelectorsGroup() {\r\n\t  var selectorsGroup = [];\r\n\t  var selectorsGroupEnd = tokens[pos].selectorsGroupEnd;\r\n\r\n\t  selectorsGroup.push(getSelector());\r\n\r\n\t  while (pos < selectorsGroupEnd) {\r\n\t    selectorsGroup = selectorsGroup.concat(getSC());\r\n\t    selectorsGroup.push(getDelim());\r\n\t    selectorsGroup = selectorsGroup.concat(getSC());\r\n\t    selectorsGroup.push(getSelector());\r\n\t  }\r\n\r\n\t  return selectorsGroup;\r\n\t}\r\n\r\n\tfunction checkSelector(i) {\r\n\t  var l;\r\n\r\n\t  if (l = checkSelector1(i)) tokens[i].selectorType = 1;else if (l = checkSelector2(i)) tokens[i].selectorType = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getSelector() {\r\n\t  var selectorType = tokens[pos].selectorType;\r\n\t  if (selectorType === 1) return getSelector1();else return getSelector2();\r\n\t}\r\n\r\n\t/**\r\n\t * Checks for selector which starts with a compound selector.\r\n\t */\r\n\tfunction checkSelector1(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkCompoundSelector(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var s = checkSC(i);\r\n\t    var c = checkCombinator(i + s);\r\n\t    if (!s && !c) break;\r\n\t    if (c) {\r\n\t      i += s + c;\r\n\t      s = checkSC(i);\r\n\t    }\r\n\r\n\t    if (l = checkCompoundSelector(i + s)) i += s + l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].selectorEnd = i;\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getSelector1() {\r\n\t  var type = NodeType.SelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var selectorEnd = token.selectorEnd;\r\n\t  var content = getCompoundSelector();\r\n\r\n\t  while (pos < selectorEnd) {\r\n\t    if (checkSC(pos)) content = content.concat(getSC());else if (checkCombinator(pos)) content.push(getCombinator());else if (checkCompoundSelector(pos)) content = content.concat(getCompoundSelector());\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks for a selector that starts with a combinator.\r\n\t */\r\n\tfunction checkSelector2(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkCombinator(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var sb = checkSC(i);\r\n\t    if (l = checkCompoundSelector(i + sb)) i += sb + l;else break;\r\n\r\n\t    var sa = checkSC(i);\r\n\t    var c = checkCombinator(i + sa);\r\n\t    if (!sa && !c) break;\r\n\t    if (c) {\r\n\t      i += sa + c;\r\n\t    }\r\n\t  }\r\n\r\n\t  tokens[start].selectorEnd = i;\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getSelector2() {\r\n\t  var type = NodeType.SelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var selectorEnd = token.selectorEnd;\r\n\t  var content = [getCombinator()];\r\n\r\n\t  while (pos < selectorEnd) {\r\n\t    if (checkSC(pos)) content = content.concat(getSC());else if (checkCombinator(pos)) content.push(getCombinator());else if (checkCompoundSelector(pos)) content = content.concat(getCompoundSelector());\r\n\t  }\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkCompoundSelector(i) {\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkCompoundSelector1(i)) {\r\n\t    tokens[i].compoundSelectorType = 1;\r\n\t  } else if (l = checkCompoundSelector2(i)) {\r\n\t    tokens[i].compoundSelectorType = 2;\r\n\t  }\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getCompoundSelector() {\r\n\t  var type = tokens[pos].compoundSelectorType;\r\n\t  if (type === 1) return getCompoundSelector1();\r\n\t  if (type === 2) return getCompoundSelector2();\r\n\t}\r\n\r\n\tfunction checkCompoundSelector1(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkTypeSelector(i) || checkParentSelectorWithExtension(i)) i += l;else return 0;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var _l2 = checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i);\r\n\t    if (_l2) i += _l2;else break;\r\n\t  }\r\n\r\n\t  tokens[start].compoundSelectorEnd = i;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getCompoundSelector1() {\r\n\t  var sequence = [];\r\n\t  var compoundSelectorEnd = tokens[pos].compoundSelectorEnd;\r\n\r\n\t  if (checkTypeSelector(pos)) sequence.push(getTypeSelector());else if (checkParentSelectorWithExtension(pos)) sequence = sequence.concat(getParentSelectorWithExtension());\r\n\r\n\t  while (pos < compoundSelectorEnd) {\r\n\t    if (checkShash(pos)) sequence.push(getShash());else if (checkClass(pos)) sequence.push(getClass());else if (checkAttributeSelector(pos)) sequence.push(getAttributeSelector());else if (checkPseudo(pos)) sequence.push(getPseudo());\r\n\t  }\r\n\r\n\t  return sequence;\r\n\t}\r\n\r\n\tfunction checkCompoundSelector2(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\r\n\t  while (i < tokensLength) {\r\n\t    var l = checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i);\r\n\t    if (l) i += l;else break;\r\n\t  }\r\n\r\n\t  tokens[start].compoundSelectorEnd = i;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getCompoundSelector2() {\r\n\t  var sequence = [];\r\n\t  var compoundSelectorEnd = tokens[pos].compoundSelectorEnd;\r\n\r\n\t  while (pos < compoundSelectorEnd) {\r\n\t    if (checkShash(pos)) sequence.push(getShash());else if (checkClass(pos)) sequence.push(getClass());else if (checkAttributeSelector(pos)) sequence.push(getAttributeSelector());else if (checkPseudo(pos)) sequence.push(getPseudo());\r\n\t  }\r\n\r\n\t  return sequence;\r\n\t}\r\n\r\n\tfunction checkTypeSelector(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkNamePrefix(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.Asterisk) i++;else if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getTypeSelector() {\r\n\t  var type = NodeType.TypeSelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (checkNamePrefix(pos)) content.push(getNamePrefix());\r\n\r\n\t  token = tokens[pos];\r\n\t  if (token.type === TokenType.Asterisk) {\r\n\t    var asteriskNode = newNode(NodeType.IdentType, '*', token.ln, token.col);\r\n\t    content.push(asteriskNode);\r\n\t    pos++;\r\n\t  } else if (checkIdent(pos)) content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeSelector(i) {\r\n\t  var l = undefined;\r\n\t  if (l = checkAttributeSelector1(i)) tokens[i].attributeSelectorType = 1;else if (l = checkAttributeSelector2(i)) tokens[i].attributeSelectorType = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getAttributeSelector() {\r\n\t  var type = tokens[pos].attributeSelectorType;\r\n\t  if (type === 1) return getAttributeSelector1();else return getAttributeSelector2();\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `[panda=nani]`\r\n\t * (2) `[panda='nani']`\r\n\t * (3) `[panda='nani' i]`\r\n\t *\r\n\t */\r\n\tfunction checkAttributeSelector1(i) {\r\n\t  var start = i;\r\n\r\n\t  if (tokens[i].type === TokenType.LeftSquareBracket) i++;else return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeName(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeMatch(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeValue(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeFlags(i)) {\r\n\t    i += l;\r\n\t    if (l = checkSC(i)) i += l;\r\n\t  }\r\n\r\n\t  if (tokens[i].type === TokenType.RightSquareBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeSelector1() {\r\n\t  var type = NodeType.AttributeSelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `[`.\r\n\t  pos++;\r\n\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeName());\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeMatch());\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeValue());\r\n\t  content = content.concat(getSC());\r\n\r\n\t  if (checkAttributeFlags(pos)) {\r\n\t    content.push(getAttributeFlags());\r\n\t    content = content.concat(getSC());\r\n\t  }\r\n\r\n\t  // Skip `]`.\r\n\t  pos++;\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `[panda]`\r\n\t */\r\n\tfunction checkAttributeSelector2(i) {\r\n\t  var start = i;\r\n\r\n\t  if (tokens[i].type === TokenType.LeftSquareBracket) i++;else return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (l = checkAttributeName(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkSC(i)) i += l;\r\n\r\n\t  if (tokens[i].type === TokenType.RightSquareBracket) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeSelector2() {\r\n\t  var type = NodeType.AttributeSelectorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  // Skip `[`.\r\n\t  pos++;\r\n\r\n\t  content = content.concat(getSC());\r\n\t  content.push(getAttributeName());\r\n\t  content = content.concat(getSC());\r\n\r\n\t  // Skip `]`.\r\n\t  pos++;\r\n\r\n\t  var end = getLastPosition(content, line, column, 1);\r\n\t  return newNode(type, content, line, column, end);\r\n\t}\r\n\r\n\tfunction checkAttributeName(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkNamePrefix(i)) i += l;\r\n\r\n\t  if (l = checkIdent(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeName() {\r\n\t  var type = NodeType.AttributeNameType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (checkNamePrefix(pos)) content.push(getNamePrefix());\r\n\t  content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeMatch(i) {\r\n\t  var l = undefined;\r\n\t  if (l = checkAttributeMatch1(i)) tokens[i].attributeMatchType = 1;else if (l = checkAttributeMatch2(i)) tokens[i].attributeMatchType = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getAttributeMatch() {\r\n\t  var type = tokens[pos].attributeMatchType;\r\n\t  if (type === 1) return getAttributeMatch1();else return getAttributeMatch2();\r\n\t}\r\n\r\n\tfunction checkAttributeMatch1(i) {\r\n\t  var start = i;\r\n\r\n\t  var type = tokens[i].type;\r\n\t  if (type === TokenType.Tilde || type === TokenType.VerticalLine || type === TokenType.CircumflexAccent || type === TokenType.DollarSign || type === TokenType.Asterisk) i++;else return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.EqualsSign) i++;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getAttributeMatch1() {\r\n\t  var type = NodeType.AttributeMatchType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = tokens[pos].value + tokens[pos + 1].value;\r\n\t  pos += 2;\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeMatch2(i) {\r\n\t  if (tokens[i].type === TokenType.EqualsSign) return 1;else return 0;\r\n\t}\r\n\r\n\tfunction getAttributeMatch2() {\r\n\t  var type = NodeType.AttributeMatchType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '=';\r\n\r\n\t  pos++;\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeValue(i) {\r\n\t  return checkString(i) || checkIdent(i);\r\n\t}\r\n\r\n\tfunction getAttributeValue() {\r\n\t  var type = NodeType.AttributeValueType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (checkString(pos)) content.push(getString());else content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkAttributeFlags(i) {\r\n\t  return checkIdent(i);\r\n\t}\r\n\r\n\tfunction getAttributeFlags() {\r\n\t  var type = NodeType.AttributeFlagsType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getIdent()];\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\tfunction checkNamePrefix(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l = undefined;\r\n\t  if (l = checkNamePrefix1(i)) tokens[i].namePrefixType = 1;else if (l = checkNamePrefix2(i)) tokens[i].namePrefixType = 2;\r\n\r\n\t  return l;\r\n\t}\r\n\r\n\tfunction getNamePrefix() {\r\n\t  var type = tokens[pos].namePrefixType;\r\n\t  if (type === 1) return getNamePrefix1();else return getNamePrefix2();\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `panda|`\r\n\t * (2) `panda<comment>|`\r\n\t */\r\n\tfunction checkNamePrefix1(i) {\r\n\t  var start = i;\r\n\t  var l = undefined;\r\n\r\n\t  if (l = checkNamespacePrefix(i)) i += l;else return 0;\r\n\r\n\t  if (l = checkCommentML(i)) i += l;\r\n\r\n\t  if (l = checkNamespaceSeparator(i)) i += l;else return 0;\r\n\r\n\t  return i - start;\r\n\t}\r\n\r\n\tfunction getNamePrefix1() {\r\n\t  var type = NodeType.NamePrefixType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  content.push(getNamespacePrefix());\r\n\r\n\t  if (checkCommentML(pos)) content.push(getCommentML());\r\n\r\n\t  content.push(getNamespaceSeparator());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `|`\r\n\t */\r\n\tfunction checkNamePrefix2(i) {\r\n\t  return checkNamespaceSeparator(i);\r\n\t}\r\n\r\n\tfunction getNamePrefix2() {\r\n\t  var type = NodeType.NamePrefixType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [getNamespaceSeparator()];\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `*`\r\n\t * (2) `panda`\r\n\t */\r\n\tfunction checkNamespacePrefix(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  var l = undefined;\r\n\r\n\t  if (tokens[i].type === TokenType.Asterisk) return 1;else if (l = checkIdent(i)) return l;else return 0;\r\n\t}\r\n\r\n\tfunction getNamespacePrefix() {\r\n\t  var type = NodeType.NamespacePrefixType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = [];\r\n\r\n\t  if (tokens[pos].type === TokenType.Asterisk) {\r\n\t    var asteriskNode = newNode(NodeType.IdentType, '*', line, column);\r\n\t    content.push(asteriskNode);\r\n\t    pos++;\r\n\t  } else if (checkIdent(pos)) content.push(getIdent());\r\n\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n\t/**\r\n\t * (1) `|`\r\n\t */\r\n\tfunction checkNamespaceSeparator(i) {\r\n\t  if (i >= tokensLength) return 0;\r\n\r\n\t  if (tokens[i].type === TokenType.VerticalLine) return 1;else return 0;\r\n\t}\r\n\r\n\tfunction getNamespaceSeparator() {\r\n\t  var type = NodeType.NamespaceSeparatorType;\r\n\t  var token = tokens[pos];\r\n\t  var line = token.ln;\r\n\t  var column = token.col;\r\n\t  var content = '|';\r\n\r\n\t  pos++;\r\n\t  return newNode(type, content, line, column);\r\n\t}\r\n\r\n/***/ },\r\n/* 20 */\r\n/***/ function(module, exports, __nested_webpack_require_288369__) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function (css, tabSize) {\r\n\t  var TokenType = __nested_webpack_require_288369__(13);\r\n\r\n\t  var tokens = [];\r\n\t  var urlMode = false;\r\n\t  var c = undefined; // Current character\r\n\t  var cn = undefined; // Next character\r\n\t  var pos = 0;\r\n\t  var tn = 0;\r\n\t  var ln = 1;\r\n\t  var col = 1;\r\n\r\n\t  var Punctuation = {\r\n\t    ' ': TokenType.Space,\r\n\t    '\\n': TokenType.Newline,\r\n\t    '\\r': TokenType.Newline,\r\n\t    '\\t': TokenType.Tab,\r\n\t    '!': TokenType.ExclamationMark,\r\n\t    '\"': TokenType.QuotationMark,\r\n\t    '#': TokenType.NumberSign,\r\n\t    '$': TokenType.DollarSign,\r\n\t    '%': TokenType.PercentSign,\r\n\t    '&': TokenType.Ampersand,\r\n\t    '\\'': TokenType.Apostrophe,\r\n\t    '(': TokenType.LeftParenthesis,\r\n\t    ')': TokenType.RightParenthesis,\r\n\t    '*': TokenType.Asterisk,\r\n\t    '+': TokenType.PlusSign,\r\n\t    ',': TokenType.Comma,\r\n\t    '-': TokenType.HyphenMinus,\r\n\t    '.': TokenType.FullStop,\r\n\t    '/': TokenType.Solidus,\r\n\t    ':': TokenType.Colon,\r\n\t    ';': TokenType.Semicolon,\r\n\t    '<': TokenType.LessThanSign,\r\n\t    '=': TokenType.EqualsSign,\r\n\t    '>': TokenType.GreaterThanSign,\r\n\t    '?': TokenType.QuestionMark,\r\n\t    '@': TokenType.CommercialAt,\r\n\t    '[': TokenType.LeftSquareBracket,\r\n\t    ']': TokenType.RightSquareBracket,\r\n\t    '^': TokenType.CircumflexAccent,\r\n\t    '_': TokenType.LowLine,\r\n\t    '{': TokenType.LeftCurlyBracket,\r\n\t    '|': TokenType.VerticalLine,\r\n\t    '}': TokenType.RightCurlyBracket,\r\n\t    '~': TokenType.Tilde\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Add a token to the token list\r\n\t   * @param {string} type\r\n\t   * @param {string} value\r\n\t   */\r\n\t  function pushToken(type, value, column) {\r\n\t    tokens.push({\r\n\t      tn: tn++,\r\n\t      ln: ln,\r\n\t      col: column,\r\n\t      type: type,\r\n\t      value: value\r\n\t    });\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Check if a character is a decimal digit\r\n\t   * @param {string} c Character\r\n\t   * @returns {boolean}\r\n\t   */\r\n\t  function isDecimalDigit(c) {\r\n\t    return '0123456789'.indexOf(c) >= 0;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse spaces\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseSpaces(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a non-space character:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) !== ' ') break;\r\n\t    }\r\n\r\n\t    // Add a substring containing only spaces to tokens:\r\n\t    pushToken(TokenType.Space, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse a string within quotes\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   * @param {string} q Quote (either `'` or `\"`)\r\n\t   */\r\n\t  function parseString(css, q) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a matching quote:\r\n\t    for (pos++; pos < css.length; pos++) {\r\n\t      // Skip escaped quotes:\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (css.charAt(pos) === q) break;\r\n\t    }\r\n\r\n\t    // Add the string (including quotes) to tokens:\r\n\t    var type = q === '\"' ? TokenType.StringDQ : TokenType.StringSQ;\r\n\t    pushToken(type, css.substring(start, pos + 1), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse numbers\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseDecimalNumber(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a character that's not a digit:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      if (!isDecimalDigit(css.charAt(pos))) break;\r\n\t    }\r\n\r\n\t    // Add the number to tokens:\r\n\t    pushToken(TokenType.DecimalNumber, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse identifier\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseIdentifier(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Skip all opening slashes:\r\n\t    while (css.charAt(pos) === '/') pos++;\r\n\r\n\t    // Read the string until we meet a punctuation mark:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      // Skip all '\\':\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (css.charAt(pos) in Punctuation) break;\r\n\t    }\r\n\r\n\t    var ident = css.substring(start, pos--);\r\n\r\n\t    // Enter url mode if parsed substring is `url`:\r\n\t    if (!urlMode && ident === 'url' && css.charAt(pos + 1) === '(') {\r\n\t      urlMode = true;\r\n\t    }\r\n\r\n\t    // Add identifier to tokens:\r\n\t    pushToken(TokenType.Identifier, ident, col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Parse a multiline comment\r\n\t  * @param {string} css Unparsed part of CSS string\r\n\t  */\r\n\t  function parseMLComment(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet `*/`.\r\n\t    // Since we already know first 2 characters (`/*`), start reading\r\n\t    // from `pos + 2`:\r\n\t    for (pos = pos + 2; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) === '*' && css.charAt(pos + 1) === '/') {\r\n\t        pos++;\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Add full comment (including `/*` and `*/`) to the list of tokens:\r\n\t    var comment = css.substring(start, pos + 1);\r\n\t    pushToken(TokenType.CommentML, comment, col);\r\n\r\n\t    var newlines = comment.split('\\n');\r\n\t    if (newlines.length > 1) {\r\n\t      ln += newlines.length - 1;\r\n\t      col = newlines[newlines.length - 1].length;\r\n\t    } else {\r\n\t      col += pos - start;\r\n\t    }\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Parse a single line comment\r\n\t  * @param {string} css Unparsed part of CSS string\r\n\t  */\r\n\t  function parseSLComment(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet line break.\r\n\t    // Since we already know first 2 characters (`//`), start reading\r\n\t    // from `pos + 2`:\r\n\t    for (pos += 2; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) === '\\n' || css.charAt(pos) === '\\r') {\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Add comment (including `//` and line break) to the list of tokens:\r\n\t    pushToken(TokenType.CommentSL, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Convert a CSS string to a list of tokens\r\n\t   * @param {string} css CSS string\r\n\t   * @returns {Array} List of tokens\r\n\t   * @private\r\n\t   */\r\n\t  function getTokens(css) {\r\n\t    // Parse string, character by character:\r\n\t    for (pos = 0; pos < css.length; col++, pos++) {\r\n\t      c = css.charAt(pos);\r\n\t      cn = css.charAt(pos + 1);\r\n\r\n\t      // If we meet `/*`, it's a start of a multiline comment.\r\n\t      // Parse following characters as a multiline comment:\r\n\t      if (c === '/' && cn === '*') {\r\n\t        parseMLComment(css);\r\n\t      }\r\n\r\n\t      // If we meet `//` and it is not a part of url:\r\n\t      else if (!urlMode && c === '/' && cn === '/') {\r\n\t          // If we're currently inside a block, treat `//` as a start\r\n\t          // of identifier. Else treat `//` as a start of a single-line\r\n\t          // comment:\r\n\t          parseSLComment(css);\r\n\t        }\r\n\r\n\t        // If current character is a double or single quote, it's a start\r\n\t        // of a string:\r\n\t        else if (c === '\"' || c === \"'\") {\r\n\t            parseString(css, c);\r\n\t          }\r\n\r\n\t          // If current character is a space:\r\n\t          else if (c === ' ') {\r\n\t              parseSpaces(css);\r\n\t            }\r\n\r\n\t            // If current character is a punctuation mark:\r\n\t            else if (c in Punctuation) {\r\n\t                // Add it to the list of tokens:\r\n\t                pushToken(Punctuation[c], c, col);\r\n\t                if (c === '\\n' || c === '\\r') {\r\n\t                  ln++;\r\n\t                  col = 0;\r\n\t                } // Go to next line\r\n\t                if (c === ')') urlMode = false; // Exit url mode\r\n\t                else if (c === '\\t' && tabSize > 1) col += tabSize - 1;\r\n\t              }\r\n\r\n\t              // If current character is a decimal digit:\r\n\t              else if (isDecimalDigit(c)) {\r\n\t                  parseDecimalNumber(css);\r\n\t                }\r\n\r\n\t                // If current character is anything else:\r\n\t                else {\r\n\t                    parseIdentifier(css);\r\n\t                  }\r\n\t    }\r\n\r\n\t    return tokens;\r\n\t  }\r\n\r\n\t  return getTokens(css);\r\n\t};\r\n\r\n/***/ },\r\n/* 21 */\r\n/***/ function(module, exports, __nested_webpack_require_296489__) {\r\n\r\n\t'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports['default'] = {\r\n\t  mark: __nested_webpack_require_296489__(22),\r\n\t  parse: __nested_webpack_require_296489__(23),\r\n\t  stringify: __nested_webpack_require_296489__(5),\r\n\t  tokenizer: __nested_webpack_require_296489__(24)\r\n\t};\r\n\tmodule.exports = exports['default'];\r\n\r\n/***/ },\r\n/* 22 */\r\n/***/ function(module, exports, __nested_webpack_require_296834__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar TokenType = __nested_webpack_require_296834__(13);\r\n\r\n\tmodule.exports = (function () {\r\n\t  /**\r\n\t  * Mark whitespaces and comments\r\n\t  */\r\n\t  function markSC(tokens) {\r\n\t    var tokensLength = tokens.length;\r\n\t    var ws = -1; // Flag for whitespaces\r\n\t    var sc = -1; // Flag for whitespaces and comments\r\n\t    var t = undefined; // Current token\r\n\r\n\t    // For every token in the token list, mark spaces and line breaks\r\n\t    // as spaces (set both `ws` and `sc` flags). Mark multiline comments\r\n\t    // with `sc` flag.\r\n\t    // If there are several spaces or tabs or line breaks or multiline\r\n\t    // comments in a row, group them: take the last one's index number\r\n\t    // and save it to the first token in the group as a reference:\r\n\t    // e.g., `ws_last = 7` for a group of whitespaces or `sc_last = 9`\r\n\t    // for a group of whitespaces and comments.\r\n\t    for (var i = 0; i < tokensLength; i++) {\r\n\t      t = tokens[i];\r\n\t      switch (t.type) {\r\n\t        case TokenType.Space:\r\n\t        case TokenType.Tab:\r\n\t          t.ws = true;\r\n\t          t.sc = true;\r\n\r\n\t          if (ws === -1) ws = i;\r\n\t          if (sc === -1) sc = i;\r\n\r\n\t          break;\r\n\t        case TokenType.Newline:\r\n\t          t.ws = true;\r\n\t          t.sc = true;\r\n\r\n\t          ws = ws === -1 ? i : ws;\r\n\t          sc = sc === -1 ? i : ws;\r\n\r\n\t          tokens[ws].ws_last = i - 1;\r\n\t          tokens[sc].sc_last = i - 1;\r\n\t          tokens[i].ws_last = i;\r\n\t          tokens[i].sc_last = i;\r\n\r\n\t          ws = -1;\r\n\t          sc = -1;\r\n\r\n\t          break;\r\n\t        case TokenType.CommentML:\r\n\t        case TokenType.CommentSL:\r\n\t          if (ws !== -1) {\r\n\t            tokens[ws].ws_last = i - 1;\r\n\t            ws = -1;\r\n\t          }\r\n\r\n\t          t.sc = true;\r\n\r\n\t          break;\r\n\t        default:\r\n\t          if (ws !== -1) {\r\n\t            tokens[ws].ws_last = i - 1;\r\n\t            ws = -1;\r\n\t          }\r\n\r\n\t          if (sc !== -1) {\r\n\t            tokens[sc].sc_last = i - 1;\r\n\t            sc = -1;\r\n\t          }\r\n\t      }\r\n\t    }\r\n\r\n\t    if (ws !== -1) tokens[ws].ws_last = i - 1;\r\n\t    if (sc !== -1) tokens[sc].sc_last = i - 1;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Pair brackets\r\n\t  */\r\n\t  function markBrackets(tokens) {\r\n\t    var tokensLength = tokens.length;\r\n\t    var ps = []; // Parentheses\r\n\t    var sbs = []; // Square brackets\r\n\t    var cbs = []; // Curly brackets\r\n\t    var t = undefined; // Current token\r\n\r\n\t    // For every token in the token list, if we meet an opening (left)\r\n\t    // bracket, push its index number to a corresponding array.\r\n\t    // If we then meet a closing (right) bracket, look at the corresponding\r\n\t    // array. If there are any elements (records about previously met\r\n\t    // left brackets), take a token of the last left bracket (take\r\n\t    // the last index number from the array and find a token with\r\n\t    // this index number) and save right bracket's index as a reference:\r\n\t    for (var i = 0; i < tokensLength; i++) {\r\n\t      t = tokens[i];\r\n\t      switch (t.type) {\r\n\t        case TokenType.LeftParenthesis:\r\n\t          ps.push(i);\r\n\t          break;\r\n\t        case TokenType.RightParenthesis:\r\n\t          if (ps.length) {\r\n\t            t.left = ps.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t        case TokenType.LeftSquareBracket:\r\n\t          sbs.push(i);\r\n\t          break;\r\n\t        case TokenType.RightSquareBracket:\r\n\t          if (sbs.length) {\r\n\t            t.left = sbs.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t        case TokenType.LeftCurlyBracket:\r\n\t          cbs.push(i);\r\n\t          break;\r\n\t        case TokenType.RightCurlyBracket:\r\n\t          if (cbs.length) {\r\n\t            t.left = cbs.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  function markBlocks(tokens) {\r\n\t    var blocks = {};\r\n\t    var currentIL = 0;\r\n\t    var i = 0;\r\n\t    var l = tokens.length;\r\n\t    var iw = undefined;\r\n\r\n\t    for (; i !== l; i++) {\r\n\t      if (!tokens[i - 1]) continue;\r\n\r\n\t      // Skip all tokens on current line:\r\n\t      if (tokens[i].type !== TokenType.Newline) continue;\r\n\r\n\t      var end = getBlockEnd(tokens, i + 1, currentIL, iw);\r\n\t      if (!iw) iw = end.iw;\r\n\r\n\t      if (end.indent && end.indent === currentIL) continue;\r\n\r\n\t      // Not found nested block.\r\n\t      if (end.end !== null) {\r\n\t        markBlocksWithIndent(tokens, blocks, end);\r\n\r\n\t        for (var z = end.end + 1; z < l; z++) {\r\n\t          if (tokens[z].type === TokenType.Space || tokens[z].type === TokenType.Tab || tokens[z].type === TokenType.CommentSL || tokens[z].type === TokenType.CommentML) continue;\r\n\t          if (tokens[z].type === TokenType.Newline) i = z;\r\n\t          break;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (!blocks[end.indent]) blocks[end.indent] = [];\r\n\t      blocks[end.indent].push(i + 1);\r\n\t      currentIL = end.indent;\r\n\t    }\r\n\r\n\t    markBlocksWithIndent(tokens, blocks, { end: i - 1, indent: 0 });\r\n\t  }\r\n\r\n\t  function getBlockEnd(tokens, i, indent, iw, maybeEnd) {\r\n\t    var spaces = '';\r\n\t    if (!maybeEnd) maybeEnd = i - 1;\r\n\r\n\t    if (!tokens[i]) return { end: maybeEnd, indent: 0 };\r\n\r\n\t    for (var l = tokens.length; i < l; i++) {\r\n\t      if (tokens[i].type === TokenType.Space || tokens[i].type === TokenType.Tab || tokens[i].type === TokenType.CommentML || tokens[i].type === TokenType.CommentSL || tokens[i].type === TokenType.Newline) {\r\n\t        spaces += tokens[i].value;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // Got all spaces.\r\n\t      // Find trailing spaces.\r\n\t      var lastNewline = spaces.lastIndexOf('\\n');\r\n\t      spaces = spaces.slice(lastNewline + 1);\r\n\r\n\t      // Mark previous node as block end.\r\n\t      if (!spaces) return { end: maybeEnd, indent: 0 };\r\n\r\n\t      if (!iw) iw = spaces.length;\r\n\t      var newIndent = spaces.length / iw;\r\n\r\n\t      if (newIndent < indent) return { end: maybeEnd, indent: newIndent, iw: iw };\r\n\r\n\t      if (newIndent === indent) {\r\n\t        // Look for line end\r\n\t        for (; i < l; i++) {\r\n\t          if (tokens[i].type !== TokenType.Newline) continue;\r\n\t          var end = getBlockEnd(tokens, i + 1, indent, iw, maybeEnd);\r\n\t          return { end: end.end, indent: indent, iw: iw };\r\n\t        }\r\n\r\n\t        return { end: i - 1, indent: newIndent, iw: iw };\r\n\t      } else {\r\n\t        // If newIndent > indent\r\n\t        return { end: null, indent: newIndent, iw: iw };\r\n\t      }\r\n\t    }\r\n\r\n\t    return { end: i - 1 };\r\n\t  }\r\n\r\n\t  function markBlocksWithIndent(tokens, blocks, end) {\r\n\t    for (var indent in blocks) {\r\n\t      if (indent < end.indent + 1) continue;\r\n\t      var block = blocks[indent];\r\n\t      if (!block) continue;\r\n\r\n\t      for (var x = 0; x < block.length; x++) {\r\n\t        var y = block[x];\r\n\t        tokens[y].block_end = end.end;\r\n\t      }\r\n\t      blocks[indent] = null;\r\n\t    }\r\n\t  }\r\n\r\n\t  return function (tokens) {\r\n\t    markBrackets(tokens);\r\n\t    markSC(tokens);\r\n\t    markBlocks(tokens);\r\n\t  };\r\n\t})();\r\n\r\n/***/ },\r\n/* 23 */\r\n/***/ function(module, exports, __nested_webpack_require_303898__) {\r\n\r\n\t'use strict';var Node=__nested_webpack_require_303898__(1);var NodeType=__nested_webpack_require_303898__(15);var TokenType=__nested_webpack_require_303898__(13);var tokens=undefined;var tokensLength=undefined;var pos=undefined;var contexts={'arguments':function(){return checkArguments(pos) && getArguments();},'atkeyword':function(){return checkAtkeyword(pos) && getAtkeyword();},'atrule':function(){return checkAtrule(pos) && getAtrule();},'block':function(){return checkBlock(pos) && getBlock();},'brackets':function(){return checkBrackets(pos) && getBrackets();},'class':function(){return checkClass(pos) && getClass();},'combinator':function(){return checkCombinator(pos) && getCombinator();},'commentML':function(){return checkCommentML(pos) && getCommentML();},'commentSL':function(){return checkCommentSL(pos) && getCommentSL();},'condition':function(){return checkCondition(pos) && getCondition();},'conditionalStatement':function(){return checkConditionalStatement(pos) && getConditionalStatement();},'declaration':function(){return checkDeclaration(pos) && getDeclaration();},'declDelim':function(){return checkDeclDelim(pos) && getDeclDelim();},'default':function(){return checkDefault(pos) && getDefault();},'delim':function(){return checkDelim(pos) && getDelim();},'dimension':function(){return checkDimension(pos) && getDimension();},'expression':function(){return checkExpression(pos) && getExpression();},'extend':function(){return checkExtend(pos) && getExtend();},'function':function(){return checkFunction(pos) && getFunction();},'global':function(){return checkGlobal(pos) && getGlobal();},'ident':function(){return checkIdent(pos) && getIdent();},'important':function(){return checkImportant(pos) && getImportant();},'include':function(){return checkInclude(pos) && getInclude();},'interpolation':function(){return checkInterpolation(pos) && getInterpolation();},'loop':function(){return checkLoop(pos) && getLoop();},'mixin':function(){return checkMixin(pos) && getMixin();},'namespace':function(){return checkNamespace(pos) && getNamespace();},'number':function(){return checkNumber(pos) && getNumber();},'operator':function(){return checkOperator(pos) && getOperator();},'optional':function(){return checkOptional(pos) && getOptional();},'parentheses':function(){return checkParentheses(pos) && getParentheses();},'parentselector':function(){return checkParentSelector(pos) && getParentSelector();},'percentage':function(){return checkPercentage(pos) && getPercentage();},'placeholder':function(){return checkPlaceholder(pos) && getPlaceholder();},'progid':function(){return checkProgid(pos) && getProgid();},'property':function(){return checkProperty(pos) && getProperty();},'propertyDelim':function(){return checkPropertyDelim(pos) && getPropertyDelim();},'pseudoc':function(){return checkPseudoc(pos) && getPseudoc();},'pseudoe':function(){return checkPseudoe(pos) && getPseudoe();},'ruleset':function(){return checkRuleset(pos) && getRuleset();},'s':function(){return checkS(pos) && getS();},'selector':function(){return checkSelector(pos) && getSelector();},'shash':function(){return checkShash(pos) && getShash();},'string':function(){return checkString(pos) && getString();},'stylesheet':function(){return checkStylesheet(pos) && getStylesheet();},'unary':function(){return checkUnary(pos) && getUnary();},'unicodeRange':function(){return checkUnicodeRange(pos) && getUnicodeRange();},'urange':function(){return checkUrange(pos) && getUrange();},'uri':function(){return checkUri(pos) && getUri();},'value':function(){return checkValue(pos) && getValue();},'variable':function(){return checkVariable(pos) && getVariable();},'variableslist':function(){return checkVariablesList(pos) && getVariablesList();},'vhash':function(){return checkVhash(pos) && getVhash();}}; /**\r\n\t * Stops parsing and display error.\r\n\t *\r\n\t * @param {number=} opt_i Token's index number\r\n\t */function throwError(opt_i){var ln=opt_i?tokens[opt_i].ln:tokens[pos].ln;throw {line:ln,syntax:'sass'};} /**\r\n\t * @param {!Object} exclude\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkExcluding(exclude,i){var start=i;while(i < tokensLength) {if(exclude[tokens[i++].type])break;}return i - start - 2;} /**\r\n\t * @param {number} start\r\n\t * @param {number} finish\r\n\t * @return {string}\r\n\t */function joinValues(start,finish){var s='';for(var i=start;i < finish + 1;i++) {s += tokens[i].value;}return s;} /**\r\n\t * @param {number} start\r\n\t * @param {number} num\r\n\t * @return {string}\r\n\t */function joinValues2(start,num){if(start + num - 1 >= tokensLength)return;var s='';for(var i=0;i < num;i++) {s += tokens[start + i].value;}return s;} /**\r\n\t * @param {string|!Array} content\r\n\t * @param {number} line\r\n\t * @param {number} column\r\n\t * @param {number} colOffset\r\n\t */function getLastPosition(content,line,column,colOffset){return typeof content === 'string'?getLastPositionForString(content,line,column,colOffset):getLastPositionForArray(content,line,column,colOffset);} /**\r\n\t * @param {string} content\r\n\t * @param {number} line\r\n\t * @param {number} column\r\n\t * @param {number} colOffset\r\n\t */function getLastPositionForString(content,line,column,colOffset){var position=[];if(!content){position = [line,column];if(colOffset)position[1] += colOffset - 1;return position;}var lastLinebreak=content.lastIndexOf('\\n');var endsWithLinebreak=lastLinebreak === content.length - 1;var splitContent=content.split('\\n');var linebreaksCount=splitContent.length - 1;var prevLinebreak=linebreaksCount === 0 || linebreaksCount === 1?-1:content.length - splitContent[linebreaksCount - 1].length - 2; // Line:\r\n\tvar offset=endsWithLinebreak?linebreaksCount - 1:linebreaksCount;position[0] = line + offset; // Column:\r\n\tif(endsWithLinebreak){offset = prevLinebreak !== -1?content.length - prevLinebreak:content.length - 1;}else {offset = linebreaksCount !== 0?content.length - lastLinebreak - column - 1:content.length - 1;}position[1] = column + offset;if(!colOffset)return position;if(endsWithLinebreak){position[0]++;position[1] = colOffset;}else {position[1] += colOffset;}return position;} /**\r\n\t * @param {!Array} content\r\n\t * @param {number} line\r\n\t * @param {number} column\r\n\t * @param {number} colOffset\r\n\t */function getLastPositionForArray(content,line,column,colOffset){var position;if(content.length === 0){position = [line,column];}else {var c=content[content.length - 1];if(c.hasOwnProperty('end')){position = [c.end.line,c.end.column];}else {position = getLastPosition(c.content,line,column);}}if(!colOffset)return position;if(tokens[pos - 1].type !== 'Newline'){position[1] += colOffset;}else {position[0]++;position[1] = 1;}return position;} /**\r\n\t * @param {string} type\r\n\t * @param {string|!Array} content\r\n\t * @param {number} line\r\n\t * @param {number} column\r\n\t * @param {!Array} end\r\n\t */function newNode(type,content,line,column,end){if(!end)end = getLastPosition(content,line,column);return new Node({type:type,content:content,start:{line:line,column:column},end:{line:end[0],column:end[1]},syntax:'sass'});} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkAny(i){var l;if(l = checkBrackets(i))tokens[i].any_child = 1;else if(l = checkParentheses(i))tokens[i].any_child = 2;else if(l = checkString(i))tokens[i].any_child = 3;else if(l = checkVariablesList(i))tokens[i].any_child = 4;else if(l = checkVariable(i))tokens[i].any_child = 5;else if(l = checkPlaceholder(i))tokens[i].any_child = 6;else if(l = checkPercentage(i))tokens[i].any_child = 7;else if(l = checkDimension(i))tokens[i].any_child = 8;else if(l = checkUnicodeRange(i))tokens[i].any_child = 17;else if(l = checkNumber(i))tokens[i].any_child = 9;else if(l = checkUri(i))tokens[i].any_child = 10;else if(l = checkExpression(i))tokens[i].any_child = 11;else if(l = checkFunction(i))tokens[i].any_child = 12;else if(l = checkInterpolation(i))tokens[i].any_child = 13;else if(l = checkIdent(i))tokens[i].any_child = 14;else if(l = checkClass(i))tokens[i].any_child = 15;else if(l = checkUnary(i))tokens[i].any_child = 16;return l;} /**\r\n\t * @return {!Node}\r\n\t */function getAny(){var childType=tokens[pos].any_child;if(childType === 1)return getBrackets();else if(childType === 2)return getParentheses();else if(childType === 3)return getString();else if(childType === 4)return getVariablesList();else if(childType === 5)return getVariable();else if(childType === 6)return getPlaceholder();else if(childType === 7)return getPercentage();else if(childType === 8)return getDimension();else if(childType === 17)return getUnicodeRange();else if(childType === 9)return getNumber();else if(childType === 10)return getUri();else if(childType === 11)return getExpression();else if(childType === 12)return getFunction();else if(childType === 13)return getInterpolation();else if(childType === 14)return getIdent();else if(childType === 15)return getClass();else if(childType === 16)return getUnary();} /**\r\n\t * Checks if token is part of mixin's arguments.\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of arguments\r\n\t */function checkArguments(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;i++;while(i < tokens[start].right) {if(l = checkArgument(i))i += l;else return 0;}return tokens[start].right - start + 1;} /**\r\n\t * Checks if token is valid to be part of arguments list\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of argument\r\n\t */function checkArgument(i){var l;if(l = checkBrackets(i))tokens[i].argument_child = 1;else if(l = checkParentheses(i))tokens[i].argument_child = 2;else if(l = checkDeclaration(i))tokens[i].argument_child = 3;else if(l = checkFunction(i))tokens[i].argument_child = 4;else if(l = checkVariablesList(i))tokens[i].argument_child = 5;else if(l = checkVariable(i))tokens[i].argument_child = 6;else if(l = checkSC(i))tokens[i].argument_child = 7;else if(l = checkDelim(i))tokens[i].argument_child = 8;else if(l = checkDeclDelim(i))tokens[i].argument_child = 9;else if(l = checkString(i))tokens[i].argument_child = 10;else if(l = checkPercentage(i))tokens[i].argument_child = 11;else if(l = checkDimension(i))tokens[i].argument_child = 12;else if(l = checkNumber(i))tokens[i].argument_child = 13;else if(l = checkUri(i))tokens[i].argument_child = 14;else if(l = checkInterpolation(i))tokens[i].argument_child = 15;else if(l = checkIdent(i))tokens[i].argument_child = 16;else if(l = checkVhash(i))tokens[i].argument_child = 17;else if(l = checkOperator(i))tokens[i].argument_child = 18;else if(l = checkUnary(i))tokens[i].argument_child = 19;else if(l = checkParentSelector(i))tokens[i].argument_child = 20;else if(l = checkImportant(i))tokens[i].argument_child = 21;return l;} /**\r\n\t * @return {!Node}\r\n\t */function getArgument(){var childType=tokens[pos].argument_child;if(childType === 1)return getBrackets();else if(childType === 2)return getParentheses();else if(childType === 3)return getDeclaration();else if(childType === 4)return getFunction();else if(childType === 5)return getVariablesList();else if(childType === 6)return getVariable();else if(childType === 7)return getSC();else if(childType === 8)return getDelim();else if(childType === 9)return getDeclDelim();else if(childType === 10)return getString();else if(childType === 11)return getPercentage();else if(childType === 12)return getDimension();else if(childType === 13)return getNumber();else if(childType === 14)return getUri();else if(childType === 15)return getInterpolation();else if(childType === 16)return getIdent();else if(childType === 17)return getVhash();else if(childType === 18)return getOperator();else if(childType === 19)return getUnary();else if(childType === 20)return getParentSelector();else if(childType === 21)return getImportant();} /**\r\n\t * Checks if token is part of an @-word (e.g. `@import`, `@include`).\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkAtkeyword(i){var l; // Check that token is `@`:\r\n\tif(i >= tokensLength || tokens[i++].type !== TokenType.CommercialAt)return 0;return (l = checkIdentOrInterpolation(i))?l + 1:0;} /**\r\n\t * Gets node with @-word.\r\n\t *\r\n\t * @return {!Node}\r\n\t */function getAtkeyword(){var startPos=pos++;var x=getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.AtkeywordType,x,token.ln,token.col);} /**\r\n\t * Checks if token is a part of an @-rule.\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of @-rule\r\n\t */function checkAtrule(i){var l;if(i >= tokensLength)return 0; // If token already has a record of being part of an @-rule,\r\n\t// return the @-rule's length:\r\n\tif(tokens[i].atrule_l !== undefined)return tokens[i].atrule_l; // If token is part of an @-rule, save the rule's type to token.\r\n\t// @keyframes:\r\n\tif(l = checkKeyframesRule(i))tokens[i].atrule_type = 4; // @-rule with ruleset:\r\n\telse if(l = checkAtruler(i))tokens[i].atrule_type = 1; // Block @-rule:\r\n\telse if(l = checkAtruleb(i))tokens[i].atrule_type = 2; // Single-line @-rule:\r\n\telse if(l = checkAtrules(i))tokens[i].atrule_type = 3;else return 0; // If token is part of an @-rule, save the rule's length to token:\r\n\ttokens[i].atrule_l = l;return l;} /**\r\n\t * Gets node with @-rule.\r\n\t *\r\n\t * @return {!Node}\r\n\t */function getAtrule(){switch(tokens[pos].atrule_type){case 1:return getAtruler(); // @-rule with ruleset\r\n\tcase 2:return getAtruleb(); // Block @-rule\r\n\tcase 3:return getAtrules(); // Single-line @-rule\r\n\tcase 4:return getKeyframesRule();}} /**\r\n\t * Checks if token is part of a block @-rule.\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the @-rule\r\n\t */function checkAtruleb(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Gets node with a block @-rule.\r\n\t *\r\n\t * @return {!Node}\r\n\t */function getAtruleb(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets()).concat([getBlock()]);var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**\r\n\t * Checks if token is part of an @-rule with ruleset.\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the @-rule\r\n\t */function checkAtruler(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;if(l = checkAtrulers(i))i += l;else return 0;return i - start;} /**\r\n\t * Gets node with an @-rule with ruleset.\r\n\t *\r\n\t * @return {!Node}\r\n\t */function getAtruler(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets());x.push(getAtrulers());var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkAtrulers(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(!tokens[i].block_end)return 0;if(l = checkSC(i))i += l;if(l = checkRuleset(i) || checkAtrule(i))i += l;else return 0;while(l = checkRuleset(i) || checkAtrule(i) || checkSC(i)) {i += l;}if(i < tokensLength)tokens[i].atrulers_end = 1;return i - start;} /**\r\n\t * @return {!Node}\r\n\t */function getAtrulers(){var startPos=pos;var token=tokens[startPos];var line=token.ln;var column=token.col;var x=getSC();while(pos < tokensLength && !tokens[pos].atrulers_end) {if(checkSC(pos))x = x.concat(getSC());else if(checkAtrule(pos))x.push(getAtrule());else if(checkRuleset(pos))x.push(getRuleset());}var end=getLastPosition(x,line,column);return newNode(NodeType.BlockType,x,token.ln,token.col,end);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkAtrules(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;return i - start;} /**\r\n\t * @return {!Node}\r\n\t */function getAtrules(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets());var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**\r\n\t * Checks if token is part of a block (e.g. `{...}`).\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the block\r\n\t */function checkBlock(i){return i < tokensLength && tokens[i].block_end?tokens[i].block_end - i + 1:0;} /**\r\n\t * Gets node with a block.\r\n\t *\r\n\t * @return {!Node}\r\n\t */function getBlock(){var startPos=pos;var end=tokens[pos].block_end;var x=[];var token=tokens[startPos];while(pos < end) {if(checkBlockdecl(pos))x = x.concat(getBlockdecl());else throwError();}return newNode(NodeType.BlockType,x,token.ln,token.col);} /**\r\n\t * Checks if token is part of a declaration (property-value pair).\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the declaration\r\n\t */function checkBlockdecl(i){var l;if(i >= tokensLength)return 0;if(l = checkBlockdecl7(i))tokens[i].bd_type = 7;else if(l = checkBlockdecl5(i))tokens[i].bd_type = 5;else if(l = checkBlockdecl6(i))tokens[i].bd_type = 6;else if(l = checkBlockdecl1(i))tokens[i].bd_type = 1;else if(l = checkBlockdecl2(i))tokens[i].bd_type = 2;else if(l = checkBlockdecl3(i))tokens[i].bd_type = 3;else if(l = checkBlockdecl4(i))tokens[i].bd_type = 4;else return 0;return l;} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl(){switch(tokens[pos].bd_type){case 1:return getBlockdecl1();case 2:return getBlockdecl2();case 3:return getBlockdecl3();case 4:return getBlockdecl4();case 5:return getBlockdecl5();case 6:return getBlockdecl6();case 7:return getBlockdecl7();}} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBlockdecl1(i){var start=i;var l=undefined;if(l = checkInclude(i))tokens[i].bd_kind = 2;else if(l = checkDeclaration(i))tokens[i].bd_kind = 5;else if(l = checkAtrule(i))tokens[i].bd_kind = 6;else return 0;i += l;if(tokens[start].bd_kind === 2 && [2,4,6,8].indexOf(tokens[start].include_type) === -1)return 0;if(tokens[start].bd_kind === 6 && tokens[start].atrule_type === 3)return 0;while(i < tokensLength) {if(l = checkDeclDelim(i))return i + l - start;if(l = checkS(i))i += l;else if(l = checkCommentSL(i))i += l;else break;}return 0;} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl1(){var x=[];var _x=[];var kind=tokens[pos].bd_kind;switch(kind){case 2:x.push(getInclude());break;case 5:x.push(getDeclaration());break;case 6:x.push(getAtrule());break;}while(pos < tokensLength) {var _pos=pos;if(checkDeclDelim(pos)){_x.push(getDeclDelim());x = x.concat(_x);break;}if(checkS(pos))_x.push(getS());else if(checkCommentSL(pos))_x.push(getCommentSL());else {pos = _pos;break;}}return x;} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBlockdecl2(i){var start=i;var l=undefined;if(l = checkConditionalStatement(i))tokens[i].bd_kind = 1;else if(l = checkInclude(i))tokens[i].bd_kind = 2;else if(l = checkExtend(i))tokens[i].bd_kind = 4;else if(l = checkMixin(i))tokens[i].bd_kind = 8;else if(l = checkLoop(i))tokens[i].bd_kind = 3;else if(l = checkRuleset(i))tokens[i].bd_kind = 7;else if(l = checkDeclaration(i))tokens[i].bd_kind = 5;else if(l = checkAtrule(i))tokens[i].bd_kind = 6;else return 0;i += l;while(i < tokensLength) {if(l = checkS(i))i += l;else if(l = checkCommentSL(i))i += l;else break;}return i - start;} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl2(){var x=[];switch(tokens[pos].bd_kind){case 1:x.push(getConditionalStatement());break;case 2:x.push(getInclude());break;case 3:x.push(getLoop());break;case 4:x.push(getExtend());break;case 5:x.push(getDeclaration());break;case 6:x.push(getAtrule());break;case 7:x.push(getRuleset());break;case 8:x.push(getMixin());break;}while(pos < tokensLength) {if(checkS(pos))x.push(getS());else if(checkCommentSL(pos))x.push(getCommentSL());else break;}return x;} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBlockdecl3(i){var start=i;var l=undefined;if(l = checkConditionalStatement(i))tokens[i].bd_kind = 1;else if(l = checkInclude(i))tokens[i].bd_kind = 2;else if(l = checkExtend(i))tokens[i].bd_kind = 4;else if(l = checkLoop(i))tokens[i].bd_kind = 3;else if(l = checkRuleset(i))tokens[i].bd_kind = 7;else if(l = checkDeclaration(i))tokens[i].bd_kind = 5;else if(l = checkAtrule(i))tokens[i].bd_kind = 6;else return 0;i += l;return i - start;} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl3(){var x=undefined;switch(tokens[pos].bd_kind){case 1:x = getConditionalStatement();break;case 2:x = getInclude();break;case 3:x = getLoop();break;case 4:x = getExtend();break;case 5:x = getDeclaration();break;case 6:x = getAtrule();break;case 7:x = getRuleset();break;}return [x];} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBlockdecl4(i){return checkSC(i);} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl4(){return getSC();} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBlockdecl5(i){var start=i;var l=undefined;if(l = checkInclude(i))i += l;else if(l = checkRuleset(i))i += l;else return 0;while(i < tokensLength) {if(l = checkS(i))i += l;else if(l = checkCommentSL(i))i += l;else break;}return i - start;} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl5(){var x=[];if(checkInclude(pos))x.push(getInclude());else x.push(getRuleset());while(pos < tokensLength) {if(checkS(pos))x.push(getS());else if(checkCommentSL(pos))x.push(getCommentSL());else break;}return x;} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBlockdecl6(i){var start=i;var l=undefined;if(l = checkInclude(i))i += l;else if(l = checkRuleset(i))i += l;else return 0;return i - start;} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl6(){var x=undefined;if(checkInclude(pos))x = getInclude();else x = getRuleset();return [x];} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBlockdecl7(i){var start=i;var l=undefined;if(l = checkInclude(i))i += l;else return 0;if([2,4,6,8].indexOf(tokens[start].include_type) === -1)return 0;while(i < tokensLength) {if(l = checkDeclDelim(i))return i + l - start;if(l = checkS(i))i += l;else if(l = checkCommentSL(i))i += l;else break;}return 0;} /**\r\n\t * @return {!Array}\r\n\t */function getBlockdecl7(){var x=[];var _x=[];x.push(getInclude());while(pos < tokensLength) {var _pos=pos;if(checkDeclDelim(pos)){_x.push(getDeclDelim());x = x.concat(_x);break;}if(checkS(pos))_x.push(getS());else if(checkCommentSL(pos))_x.push(getCommentSL());else {pos = _pos;break;}}return x;} /**\r\n\t * Checks if token is part of text inside square brackets, e.g. `[1]`.\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkBrackets(i){if(i >= tokensLength || tokens[i].type !== TokenType.LeftSquareBracket)return 0;return tokens[i].right - i + 1;} /**\r\n\t * Gets node with text inside square brackets, e.g. `[1]`.\r\n\t *\r\n\t * @return {!Node}\r\n\t */function getBrackets(){var startPos=pos;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;var tsets=getTsets();var end=getLastPosition(tsets,line,column,1);pos++;return newNode(NodeType.BracketsType,tsets,token.ln,token.col,end);} /**\r\n\t * Checks if token is part of a class selector (e.g. `.abc`).\r\n\t *\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the class selector\r\n\t */function checkClass(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(tokens[i].class_l)return tokens[i].class_l;if(tokens[i++].type !== TokenType.FullStop)return 0; // Check for `-` at beginning\r\n\tif(tokens[i].type === TokenType.HyphenMinus)i += 1;if(l = checkIdentOrInterpolation(i))i += l;else return 0;while(i < tokensLength) {if(l = checkIdentOrInterpolation(i) || checkNumber(i))i += l;else if(tokens[i].type === TokenType.HyphenMinus)i += 1;else break;}tokens[start].classEnd = i;return i - start;} /**\r\n\t * Gets node with a class selector.\r\n\t *\r\n\t * @return {!Node}\r\n\t */function getClass(){var startPos=pos;var type=NodeType.ClassType;var token=tokens[startPos];var line=token.ln;var column=token.col;var content=[];var end=token.classEnd; // Skip `.`\r\n\tpos++;while(pos < end) {if(checkIdentOrInterpolation(pos)){content = content.concat(getIdentOrInterpolation());}else if(checkNumber(pos)){content = content.concat(getNumber());}else if(tokens[pos].type === TokenType.HyphenMinus){content.push(newNode(NodeType.IdentType,tokens[pos].value,tokens[pos].ln,tokens[pos].col));pos++;}else break;}return newNode(type,content,line,column);} /**\r\n\t * @param {number} i\r\n\t * @return {number}\r\n\t */function checkCombinator(i){if(i >= tokensLength)return 0;var l=undefined;if(l = checkCombinator1(i))tokens[i].combinatorType = 1;else if(l = checkCombinator2(i))tokens[i].combinatorType = 2;else if(l = checkCombinator3(i))tokens[i].combinatorType = 3;return l;} /**\r\n\t * @return {!Node}\r\n\t */function getCombinator(){var type=tokens[pos].combinatorType;if(type === 1)return getCombinator1();if(type === 2)return getCombinator2();if(type === 3)return getCombinator3();} /**\r\n\t * (1) `||`\r\n\t *\r\n\t * @param {number} i\r\n\t * @return {number}\r\n\t */function checkCombinator1(i){if(tokens[i].type === TokenType.VerticalLine && tokens[i + 1].type === TokenType.VerticalLine)return 2;else return 0;} /**\r\n\t * @return {!Node}\r\n\t */function getCombinator1(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='||';pos += 2;return newNode(type,content,line,column);} /**\r\n\t * (1) `>`\r\n\t * (2) `+`\r\n\t * (3) `~`\r\n\t *\r\n\t * @param {number} i\r\n\t * @return {number}\r\n\t */function checkCombinator2(i){var type=tokens[i].type;if(type === TokenType.PlusSign || type === TokenType.GreaterThanSign || type === TokenType.Tilde)return 1;else return 0;}function getCombinator2(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=tokens[pos++].value;return newNode(type,content,line,column);} /**\r\n\t * (1) `/panda/`\r\n\t */function checkCombinator3(i){var start=i;if(tokens[i].type === TokenType.Solidus)i++;else return 0;var l=undefined;if(l = checkIdent(i))i += l;else return 0;if(tokens[i].type === TokenType.Solidus)i++;else return 0;return i - start;}function getCombinator3(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `/`.\r\n\tpos++;var ident=getIdent(); // Skip `/`.\r\n\tpos++;var content='/' + ident.content + '/';return newNode(type,content,line,column);} /**\r\n\t * Check if token is a multiline comment.\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is a multiline comment, otherwise `0`\r\n\t */function checkCommentML(i){return i < tokensLength && tokens[i].type === TokenType.CommentML?1:0;} /**\r\n\t * Get node with a multiline comment\r\n\t * @return {Array} `['commentML', x]` where `x`\r\n\t *      is the comment's text (without `/*` and `* /`).\r\n\t */function getCommentML(){var startPos=pos;var x=tokens[pos].value.substring(2);var token=tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition(x,line,column + 2);pos++;return newNode(NodeType.CommentMLType,x,token.ln,token.col,end);} /**\r\n\t * Check if token is part of a single-line comment.\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is a single-line comment, otherwise `0`\r\n\t */function checkCommentSL(i){return i < tokensLength && tokens[i].type === TokenType.CommentSL?1:0;} /**\r\n\t * Get node with a single-line comment.\r\n\t * @return {Array} `['commentSL', x]` where `x` is comment's message\r\n\t *      (without `//`)\r\n\t */function getCommentSL(){var startPos=pos;var token=tokens[startPos];var line=token.ln;var column=token.col;var x=tokens[pos++].value.substring(2);var end=!x?[line,column + 1]:getLastPosition(x,line,column + 2);return newNode(NodeType.CommentSLType,x,token.ln,token.col,end);} /**\r\n\t * Check if token is part of a condition\r\n\t * (e.g. `@if ...`, `@else if ...` or `@else ...`).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the condition\r\n\t */function checkCondition(i){var start=i;var l=undefined;var _i=undefined;var s=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(['if','else'].indexOf(tokens[start + 1].value) < 0)return 0;while(i < tokensLength) {if(l = checkBlock(i))break;s = checkSC(i);_i = i + s;if(l = _checkCondition(_i))i += l + s;else break;}return i - start;}function _checkCondition(i){return checkVariable(i) || checkNumber(i) || checkInterpolation(i) || checkIdent(i) || checkOperator(i) || checkCombinator(i) || checkString(i);} /**\r\n\t * Get node with a condition.\r\n\t * @return {Array} `['condition', x]`\r\n\t */function getCondition(){var startPos=pos;var x=[getAtkeyword()];while(pos < tokensLength) {if(checkBlock(pos))break;var s=checkSC(pos);var _pos=pos + s;if(!_checkCondition(_pos))break;if(s)x = x.concat(getSC());x.push(_getCondition());}var token=tokens[startPos];return newNode(NodeType.ConditionType,x,token.ln,token.col);}function _getCondition(){if(checkVariable(pos))return getVariable();if(checkNumber(pos))return getNumber();if(checkInterpolation(pos))return getInterpolation();if(checkIdent(pos))return getIdent();if(checkOperator(pos))return getOperator();if(checkCombinator(pos))return getCombinator();if(checkString(pos))return getString();} /**\r\n\t * Check if token is part of a conditional statement\r\n\t * (e.g. `@if ... {} @else if ... {} @else ... {}`).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the condition\r\n\t */function checkConditionalStatement(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkCondition(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a condition.\r\n\t * @return {Array} `['condition', x]`\r\n\t */function getConditionalStatement(){var startPos=pos;var x=[];x.push(getCondition());x = x.concat(getSC());x.push(getBlock());var token=tokens[startPos];return newNode(NodeType.ConditionalStatementType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the declaration\r\n\t */function checkDeclaration(i){return checkDeclaration1(i) || checkDeclaration2(i);} /**\r\n\t * Get node with a declaration\r\n\t * @return {Array} `['declaration', ['property', x], ['propertyDelim'],\r\n\t *       ['value', y]]`\r\n\t */function getDeclaration(){return checkDeclaration1(pos)?getDeclaration1():getDeclaration2();} /**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the declaration\r\n\t */function checkDeclaration1(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkProperty(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkPropertyDelim(i))i++;else return 0;if(l = checkValue(i))return i + l - start;if(l = checkS(i))i += l;if(l = checkValue(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a declaration\r\n\t * @return {Array} `['declaration', ['property', x], ['propertyDelim'],\r\n\t *       ['value', y]]`\r\n\t */function getDeclaration1(){var startPos=pos;var x=[];x.push(getProperty());if(checkS(pos))x.push(getS());x.push(getPropertyDelim());if(checkS(pos))x.push(getS());x.push(getValue());var token=tokens[startPos];return newNode(NodeType.DeclarationType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the declaration\r\n\t */function checkDeclaration2(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkPropertyDelim(i))i++;else return 0;if(l = checkProperty(i))i += l;else return 0;if(l = checkValue(i))return i + l - start;if(l = checkSC(i))i += l;if(l = checkValue(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a declaration\r\n\t * @return {Array} `['declaration', ['propertyDelim'], ['property', x],\r\n\t *       ['value', y]]`\r\n\t */function getDeclaration2(){var startPos=pos;var x=[];x.push(getPropertyDelim());x.push(getProperty());x = x.concat(getSC());x.push(getValue());var token=tokens[startPos];return newNode(NodeType.DeclarationType,x,token.ln,token.col);} /**\r\n\t * Check if token is a semicolon\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is a semicolon, otherwise `0`\r\n\t */function checkDeclDelim(i){if(i >= tokensLength)return 0;return tokens[i].type === TokenType.Newline || tokens[i].type === TokenType.Semicolon?1:0;} /**\r\n\t * Get node with a semicolon\r\n\t * @return {Array} `['declDelim']`\r\n\t */function getDeclDelim(){var startPos=pos++;var token=tokens[startPos];return newNode(NodeType.DeclDelimType,'\\n',token.ln,token.col);} /**\r\n\t * Check if token if part of `!default` word.\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the `!default` word\r\n\t */function checkDefault(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'default'){tokens[start].defaultEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with a `!default` word\r\n\t * @return {Array} `['default', sc]` where `sc` is optional whitespace\r\n\t */function getDefault(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.defaultEnd);pos = token.defaultEnd + 1;return newNode(NodeType.DefaultType,content,line,column);} /**\r\n\t * Check if token is a comma\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is a comma, otherwise `0`\r\n\t */function checkDelim(i){return i < tokensLength && tokens[i].type === TokenType.Comma?1:0;} /**\r\n\t * Get node with a comma\r\n\t * @return {Array} `['delim']`\r\n\t */function getDelim(){var startPos=pos++;var token=tokens[startPos];return newNode(NodeType.DelimType,',',token.ln,token.col);} /**\r\n\t * Check if token is part of a number with dimension unit (e.g. `10px`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */function checkDimension(i){var ln=checkNumber(i);var li=undefined;if(i >= tokensLength || !ln || i + ln >= tokensLength)return 0;return (li = checkUnit(i + ln))?ln + li:0;} /**\r\n\t * Get node of a number with dimension unit\r\n\t * @return {Node}\r\n\t */function getDimension(){var type=NodeType.DimensionType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[getNumber(),getUnit()];return newNode(type,content,line,column);} /**\r\n\t * Check if token is unit\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */function checkUnit(i){var units=['em','ex','ch','rem','vh','vw','vmin','vmax','px','mm','q','cm','in','pt','pc','deg','grad','rad','turn','s','ms','Hz','kHz','dpi','dpcm','dppx'];return units.indexOf(tokens[i].value) !== -1?1:0;} /**\r\n\t * Get unit node of type ident\r\n\t * @return {Node} An ident node containing the unit value\r\n\t */function getUnit(){var type=NodeType.IdentType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=token.value;pos++;return newNode(type,content,line,column);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkExpression(i){var start=i;if(i >= tokensLength || tokens[i++].value !== 'expression' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis){return 0;}return tokens[i].right - start + 1;} /**\r\n\t * @return {Array}\r\n\t */function getExpression(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;x = joinValues(pos + 1,tokens[pos].right - 1);var end=getLastPosition(x,line,column,1);if(end[0] === line)end[1] += 11;pos = tokens[pos].right + 1;return newNode(NodeType.ExpressionType,x,token.ln,token.col,end);}function checkExtend(i){var l=0;if(l = checkExtend1(i))tokens[i].extend_child = 1;else if(l = checkExtend2(i))tokens[i].extend_child = 2;return l;}function getExtend(){var type=tokens[pos].extend_child;if(type === 1)return getExtend1();else if(type === 2)return getExtend2();} /**\r\n\t * Checks if token is part of an extend with `!optional` flag.\r\n\t * @param {number} i\r\n\t */function checkExtend1(i){var start=i;var l;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'extend')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkOptional(i))i += l;else return 0;return i - start;}function getExtend1(){var startPos=pos;var x=[].concat([getAtkeyword()],getSC(),getSelectorsGroup(),getSC(),getOptional());var token=tokens[startPos];return newNode(NodeType.ExtendType,x,token.ln,token.col);} /**\r\n\t * Checks if token is part of an extend without `!optional` flag.\r\n\t * @param {number} i\r\n\t */function checkExtend2(i){var start=i;var l;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'extend')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;return i - start;}function getExtend2(){var startPos=pos;var x=[].concat([getAtkeyword()],getSC(),getSelectorsGroup());var token=tokens[startPos];return newNode(NodeType.ExtendType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkFunction(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i < tokensLength && tokens[i].type === TokenType.LeftParenthesis?tokens[i].right - start + 1:0;} /**\r\n\t * @return {Array}\r\n\t */function getFunction(){var startPos=pos;var x=getIdentOrInterpolation();var body=undefined;body = getArguments();x.push(body);var token=tokens[startPos];return newNode(NodeType.FunctionType,x,token.ln,token.col);} /**\r\n\t * @return {Array}\r\n\t */function getArguments(){var startPos=pos;var x=[];var body=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;while(pos < tokensLength && tokens[pos].type !== TokenType.RightParenthesis) {if(checkDeclaration(pos))x.push(getDeclaration());else if(checkArgument(pos)){body = getArgument();if(typeof body.content === 'string')x.push(body);else x = x.concat(body);}else if(checkClass(pos))x.push(getClass());else throwError();}var end=getLastPosition(x,line,column,1);pos++;return newNode(NodeType.ArgumentsType,x,token.ln,token.col,end);} /**\r\n\t * Check if token is part of `!global` word\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkGlobal(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'global'){tokens[start].globalEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with `!global` word\r\n\t */function getGlobal(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.globalEnd);pos = token.globalEnd + 1;return newNode(NodeType.GlobalType,content,line,column);} /**\r\n\t * Check if token is part of an identifier\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the identifier\r\n\t */function checkIdent(i){var start=i;if(i >= tokensLength)return 0;if(tokens[i].type === TokenType.HyphenMinus && tokens[i + 1].type === TokenType.DecimalNumber)return 0;if(tokens[i].type === TokenType.HyphenMinus)i++;if(tokens[i].type === TokenType.LowLine || tokens[i].type === TokenType.Identifier)i++;else return 0;for(;i < tokensLength;i++) {if(tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier && tokens[i].type !== TokenType.DecimalNumber)break;}tokens[start].ident_last = i - 1;return i - start;} /**\r\n\t * Get node with an identifier\r\n\t * @return {Array} `['ident', x]` where `x` is identifier's name\r\n\t */function getIdent(){var startPos=pos;var x=joinValues(pos,tokens[pos].ident_last);pos = tokens[pos].ident_last + 1;var token=tokens[startPos];return newNode(NodeType.IdentType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @returns {number} Length of the identifier\r\n\t */function checkPartialIdent(i){var start=i;if(i >= tokensLength)return 0;for(;i < tokensLength;i++) {if(tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier && tokens[i].type !== TokenType.DecimalNumber)break;}tokens[start].ident_last = i - 1;return i - start;}function checkIdentOrInterpolation(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkInterpolation(i) || checkIdent(i))i += l;else break;}return i - start;}function getIdentOrInterpolation(){var x=[];while(pos < tokensLength) {if(checkInterpolation(pos))x.push(getInterpolation());else if(checkIdent(pos))x.push(getIdent());else break;}return x;} /**\r\n\t * Check if token is part of `!important` word\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkImportant(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'important'){tokens[start].importantEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with `!important` word\r\n\t * @return {Array} `['important', sc]` where `sc` is optional whitespace\r\n\t */function getImportant(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.importantEnd);pos = token.importantEnd + 1;return newNode(NodeType.ImportantType,content,line,column);} /**\r\n\t * Check if token is part of an included mixin (`@include` or `@extend`\r\n\t *      directive).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the included mixin\r\n\t */function checkInclude(i){var l;if(i >= tokensLength)return 0;if(l = checkInclude1(i))tokens[i].include_type = 1;else if(l = checkInclude2(i))tokens[i].include_type = 2;else if(l = checkInclude3(i))tokens[i].include_type = 3;else if(l = checkInclude4(i))tokens[i].include_type = 4;else if(l = checkInclude5(i))tokens[i].include_type = 5;else if(l = checkInclude6(i))tokens[i].include_type = 6;else if(l = checkInclude7(i))tokens[i].include_type = 7;else if(l = checkInclude8(i))tokens[i].include_type = 8;return l;} /**\r\n\t * Get node with included mixin\r\n\t * @return {Array} `['include', x]`\r\n\t */function getInclude(){switch(tokens[pos].include_type){case 1:return getInclude1();case 2:return getInclude2();case 3:return getInclude3();case 4:return getInclude4();case 5:return getInclude5();case 6:return getInclude6();case 7:return getInclude7();case 8:return getInclude8();}} /**\r\n\t * Check if token is part of an included mixin like `@include nani(foo) {...}`\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the include\r\n\t */function checkInclude1(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with included mixin like `@include nani(foo) {...}`\r\n\t * @return {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,\r\n\t *      ['arguments', z], sc, ['block', q], sc` where `x` is `include` or\r\n\t *      `extend`, `y` is mixin's identifier (selector), `z` are arguments\r\n\t *      passed to the mixin, `q` is block passed to the mixin and `sc`\r\n\t *      are optional whitespaces\r\n\t */function getInclude1(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin like `@include nani(foo)`\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the include\r\n\t */function checkInclude2(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with included mixin like `@include nani(foo)`\r\n\t * @return {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,\r\n\t *      ['arguments', z], sc]` where `x` is `include` or `extend`, `y` is\r\n\t *      mixin's identifier (selector), `z` are arguments passed to the\r\n\t *      mixin and `sc` are optional whitespaces\r\n\t */function getInclude2(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin with a content block passed\r\n\t *      as an argument (e.g. `@include nani {...}`)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the mixin\r\n\t */function checkInclude3(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with an included mixin with a content block passed\r\n\t *      as an argument (e.g. `@include nani {...}`)\r\n\t * @return {Array} `['include', x]`\r\n\t */function getInclude3(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkInclude4(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**\r\n\t * @return {Array} `['include', x]`\r\n\t */function getInclude4(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin like `+nani(foo) {...}`\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the include\r\n\t */function checkInclude5(i){var start=i;var l=undefined;if(tokens[i].type === TokenType.PlusSign)i++;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with included mixin like `+nani(foo) {...}`\r\n\t * @return {Array} `['include', ['operator', '+'], ['selector', x], sc,\r\n\t *      ['arguments', y], sc, ['block', z], sc` where `x` is\r\n\t *      mixin's identifier (selector), `y` are arguments passed to the\r\n\t *      mixin, `z` is block passed to mixin and `sc` are optional whitespaces\r\n\t */function getInclude5(){var startPos=pos;var x=[].concat(getOperator(),getIdentOrInterpolation(),getSC(),getArguments(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin like `+nani(foo)`\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the include\r\n\t */function checkInclude6(i){var start=i;var l=undefined;if(tokens[i].type === TokenType.PlusSign)i++;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with included mixin like `+nani(foo)`\r\n\t * @return {Array} `['include', ['operator', '+'], ['selector', y], sc,\r\n\t *      ['arguments', z], sc]` where `y` is\r\n\t *      mixin's identifier (selector), `z` are arguments passed to the\r\n\t *      mixin and `sc` are optional whitespaces\r\n\t */function getInclude6(){var startPos=pos;var x=[].concat(getOperator(),getIdentOrInterpolation(),getSC(),getArguments());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin with a content block passed\r\n\t *      as an argument (e.g. `+nani {...}`)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the mixin\r\n\t */function checkInclude7(i){var start=i;var l=undefined;if(tokens[i].type === TokenType.PlusSign)i++;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with an included mixin with a content block passed\r\n\t *      as an argument (e.g. `+nani {...}`)\r\n\t * @return {Array} `['include', x]`\r\n\t */function getInclude7(){var startPos=pos;var x=[].concat(getOperator(),getIdentOrInterpolation(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkInclude8(i){var start=i;var l=undefined;if(tokens[i].type === TokenType.PlusSign)i++;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**\r\n\t * @return {Array} `['include', x]`\r\n\t */function getInclude8(){var startPos=pos;var x=[].concat(getOperator(),getIdentOrInterpolation());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an interpolated variable (e.g. `#{$nani}`).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkInterpolation(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.NumberSign || !tokens[i + 1] || tokens[i + 1].type !== TokenType.LeftCurlyBracket)return 0;i += 2;while(tokens[i].type !== TokenType.RightCurlyBracket) {if(l = checkArgument(i))i += l;else return 0;}return tokens[i].type === TokenType.RightCurlyBracket?i - start + 1:0;} /**\r\n\t * Get node with an interpolated variable\r\n\t * @return {Array} `['interpolation', x]`\r\n\t */function getInterpolation(){var startPos=pos;var x=[];var token=tokens[startPos];var line=token.ln;var column=token.col; // Skip `#{`:\r\n\tpos += 2;while(pos < tokensLength && tokens[pos].type !== TokenType.RightCurlyBracket) {var body=getArgument();if(typeof body.content === 'string')x.push(body);else x = x.concat(body);}var end=getLastPosition(x,line,column,1); // Skip `}`:\r\n\tpos++;return newNode(NodeType.InterpolationType,x,token.ln,token.col,end);} /**\r\n\t * Check a single keyframe block - `5% {}`\r\n\t * @param {number} i\r\n\t * @return {number}\r\n\t */function checkKeyframesBlock(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkKeyframesSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get a single keyframe block - `5% {}`\r\n\t * @return {Node}\r\n\t */function getKeyframesBlock(){var type=NodeType.RulesetType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[].concat(getKeyframesSelectorsGroup(),getSC(),[getBlock()]);return newNode(type,content,line,column);} /**\r\n\t * Check all keyframe blocks - `5% {} 100% {}`\r\n\t * @param {number} i\r\n\t * @return {number}\r\n\t */function checkKeyframesBlocks(i){return i < tokensLength && tokens[i].block_end?tokens[i].block_end - i + 1:0;} /**\r\n\t * Get all keyframe blocks - `5% {} 100% {}`\r\n\t * @return {Node}\r\n\t */function getKeyframesBlocks(){var type=NodeType.BlockType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];var keyframesBlocksEnd=token.block_end;while(pos < keyframesBlocksEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkKeyframesBlock(pos))content.push(getKeyframesBlock());else if(checkAtrule(pos))content.push(getAtrule()); // @content\r\n\telse break;}return newNode(type,content,line,column);} /**\r\n\t * Check if token is part of a @keyframes rule.\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the @keyframes rule\r\n\t */function checkKeyframesRule(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;var atruleName=joinValues2(i - l,l);if(atruleName.indexOf('keyframes') === -1)return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkKeyframesBlocks(i))i += l;else return 0;return i - start;} /**\r\n\t * @return {Node}\r\n\t */function getKeyframesRule(){var type=NodeType.AtruleType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[].concat([getAtkeyword()],getSC(),getIdentOrInterpolation(),getSC(),[getKeyframesBlocks()]);return newNode(type,content,line,column);} /**\r\n\t * Check a single keyframe selector - `5%`, `from` etc\r\n\t * @param {number} i\r\n\t * @return {number}\r\n\t */function checkKeyframesSelector(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkIdent(i)){ // Valid selectors are only `from` and `to`.\r\n\tvar selector=joinValues2(i,l);if(selector !== 'from' && selector !== 'to')return 0;i += l;tokens[start].keyframesSelectorType = 1;}else if(l = checkPercentage(i)){i += l;tokens[start].keyframesSelectorType = 2;}else if(l = checkInterpolation(i)){i += l;tokens[start].keyframesSelectorType = 3;}else {return 0;}return i - start;} /**\r\n\t * Get a single keyframe selector\r\n\t * @return {Node}\r\n\t */function getKeyframesSelector(){var keyframesSelectorType=NodeType.KeyframesSelectorType;var selectorType=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(token.keyframesSelectorType === 1){content.push(getIdent());}else if(token.keyframesSelectorType === 2){content.push(getPercentage());}else if(token.keyframesSelectorType === 3){content.push(getInterpolation());}var keyframesSelector=newNode(keyframesSelectorType,content,line,column);return newNode(selectorType,[keyframesSelector],line,column);} /**\r\n\t * Check the keyframe's selector groups\r\n\t * @param {number} i\r\n\t * @return {number}\r\n\t */function checkKeyframesSelectorsGroup(i){var start=i;var l=undefined;if(l = checkKeyframesSelector(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);var c=checkDelim(i + sb);if(!c)break;var sa=checkSC(i + sb + c);if(l = checkKeyframesSelector(i + sb + c + sa))i += sb + c + sa + l;else break;}tokens[start].selectorsGroupEnd = i;return i - start;} /**\r\n\t * Get the keyframe's selector groups\r\n\t * @return {Array} An array of keyframe selectors\r\n\t */function getKeyframesSelectorsGroup(){var selectorsGroup=[];var selectorsGroupEnd=tokens[pos].selectorsGroupEnd;selectorsGroup.push(getKeyframesSelector());while(pos < selectorsGroupEnd) {selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getDelim());selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getKeyframesSelector());}return selectorsGroup;} /**\r\n\t * Check if token is part of a loop.\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the loop\r\n\t */function checkLoop(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(['for','each','while'].indexOf(tokens[start + 1].value) < 0)return 0;while(i < tokensLength) {if(l = checkBlock(i)){i += l;break;}else if(l = checkVariable(i) || checkNumber(i) || checkInterpolation(i) || checkIdent(i) || checkSC(i) || checkOperator(i) || checkCombinator(i) || checkString(i))i += l;else return 0;}return i - start;} /**\r\n\t * Get node with a loop.\r\n\t * @return {Array} `['loop', x]`\r\n\t */function getLoop(){var startPos=pos;var x=[];x.push(getAtkeyword());while(pos < tokensLength) {if(checkBlock(pos)){x.push(getBlock());break;}else if(checkVariable(pos))x.push(getVariable());else if(checkNumber(pos))x.push(getNumber());else if(checkInterpolation(pos))x.push(getInterpolation());else if(checkIdent(pos))x.push(getIdent());else if(checkOperator(pos))x.push(getOperator());else if(checkCombinator(pos))x.push(getCombinator());else if(checkSC(pos))x = x.concat(getSC());else if(checkString(pos))x.push(getString());}var token=tokens[startPos];return newNode(NodeType.LoopType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a mixin\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the mixin\r\n\t */function checkMixin(i){return checkMixin1(i) || checkMixin2(i);} /**\r\n\t * Get node with a mixin\r\n\t * @return {Array} `['mixin', x]`\r\n\t */function getMixin(){return checkMixin1(pos)?getMixin1():getMixin2();} /**\r\n\t * Check if token is part of a mixin\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the mixin\r\n\t */function checkMixin1(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if((l = checkAtkeyword(i)) && tokens[i + 1].value === 'mixin')i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else {if(l = checkArguments(i))i += l;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;}return i - start;} /**\r\n\t * Get node with a mixin\r\n\t * @return {Array} `['mixin', x]`\r\n\t */function getMixin1(){var startPos=pos;var x=[getAtkeyword()];x = x.concat(getSC());if(checkIdentOrInterpolation(pos))x = x.concat(getIdentOrInterpolation());x = x.concat(getSC());if(checkBlock(pos))x.push(getBlock());else {if(checkArguments(pos))x.push(getArguments());x = x.concat(getSC());x.push(getBlock());}var token=tokens[startPos];return newNode(NodeType.MixinType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a mixin\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the mixin\r\n\t */function checkMixin2(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(tokens[i].type === TokenType.EqualsSign)i++;else return 0;if(l = checkSC(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else {if(l = checkArguments(i))i += l;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;}return i - start;} /**\r\n\t* Get node with a mixin\r\n\t* @return {Array} `['mixin', x]`\r\n\t*/function getMixin2(){var startPos=pos;var x=[getOperator()];x = x.concat(getSC());if(checkIdentOrInterpolation(pos))x = x.concat(getIdentOrInterpolation());x = x.concat(getSC());if(checkBlock(pos))x.push(getBlock());else {if(checkArguments(pos))x.push(getArguments());x = x.concat(getSC());x.push(getBlock());}var token=tokens[startPos];return newNode(NodeType.MixinType,x,token.ln,token.col);} /**\r\n\t * Check if token is a namespace sign (`|`)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is `|`, `0` if not\r\n\t */function checkNamespace(i){return i < tokensLength && tokens[i].type === TokenType.VerticalLine?1:0;} /**\r\n\t * Get node with a namespace sign\r\n\t * @return {Array} `['namespace']`\r\n\t */function getNamespace(){var startPos=pos++;var token=tokens[startPos];return newNode(NodeType.NamespaceType,'|',token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkNmName2(i){if(tokens[i].type === TokenType.Identifier)return 1;else if(tokens[i].type !== TokenType.DecimalNumber)return 0;i++;return i < tokensLength && tokens[i].type === TokenType.Identifier?2:1;} /**\r\n\t * @return {string}\r\n\t */function getNmName2(){var s=tokens[pos].value;if(tokens[pos++].type === TokenType.DecimalNumber && pos < tokensLength && tokens[pos].type === TokenType.Identifier)s += tokens[pos++].value;return s;} /**\r\n\t * Check if token is part of a number\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of number\r\n\t */function checkNumber(i){if(i >= tokensLength)return 0;if(tokens[i].number_l)return tokens[i].number_l; // `10`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && (!tokens[i + 1] || tokens[i + 1] && tokens[i + 1].type !== TokenType.FullStop)){tokens[i].number_l = 1;return 1;} // `10.`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && (!tokens[i + 2] || tokens[i + 2].type !== TokenType.DecimalNumber)){tokens[i].number_l = 2;return 2;} // `.10`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.FullStop && tokens[i + 1].type === TokenType.DecimalNumber){tokens[i].number_l = 2;return 2;} // `10.10`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && tokens[i + 2] && tokens[i + 2].type === TokenType.DecimalNumber){tokens[i].number_l = 3;return 3;}return 0;} /**\r\n\t * Get node with number\r\n\t * @return {Array} `['number', x]` where `x` is a number converted\r\n\t *      to string.\r\n\t */function getNumber(){var s='';var startPos=pos;var l=tokens[pos].number_l;for(var j=0;j < l;j++) {s += tokens[pos + j].value;}pos += l;var token=tokens[startPos];return newNode(NodeType.NumberType,s,token.ln,token.col);} /**\r\n\t * Check if token is an operator (`/`, `%`, `,`, `:` or `=`).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is an operator, otherwise `0`\r\n\t */function checkOperator(i){if(i >= tokensLength)return 0;switch(tokens[i].type){case TokenType.Solidus:case TokenType.PercentSign:case TokenType.Comma:case TokenType.Colon:case TokenType.EqualsSign:case TokenType.EqualitySign:case TokenType.InequalitySign:case TokenType.LessThanSign:case TokenType.GreaterThanSign:case TokenType.Asterisk:return 1;}return 0;} /**\r\n\t * Get node with an operator\r\n\t * @return {Array} `['operator', x]` where `x` is an operator converted\r\n\t *      to string.\r\n\t */function getOperator(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.OperatorType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of `!optional` word\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkOptional(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'optional'){tokens[start].optionalEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with `!optional` word\r\n\t */function getOptional(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.optionalEnd);pos = token.optionalEnd + 1;return newNode(NodeType.OptionalType,content,line,column);} /**\r\n\t * Check if token is part of text inside parentheses, e.g. `(1)`\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkParentheses(i){if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - i + 1;} /**\r\n\t * Get node with text inside parentheses, e.g. `(1)`\r\n\t * @return {Node}\r\n\t */function getParentheses(){var type=NodeType.ParenthesesType;var token=tokens[pos];var line=token.ln;var column=token.col;pos++;var tsets=getTsets();var end=getLastPosition(tsets,line,column,1);pos++;return newNode(type,tsets,line,column,end);} /**\r\n\t * Check if token is a parent selector, e.g. `&`\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkParentSelector(i){return i < tokensLength && tokens[i].type === TokenType.Ampersand?1:0;} /**\r\n\t * Get node with a parent selector\r\n\t * @return {Node}\r\n\t */function getParentSelector(){var startPos=pos;var token=tokens[startPos];pos++;return newNode(NodeType.ParentSelectorType,'&',token.ln,token.col);} /**\r\n\t * Check if token is a parent selector extension, e.g. `&--foo-bar`\r\n\t * @param {number} i Token's index number\r\n\t * @returns {number} Length of the parent selector extension\r\n\t */function checkParentSelectorExtension(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;while(i < tokensLength) {if(l = checkNumber(i) || checkPartialIdent(i) || checkIdentOrInterpolation(i))i += l;else break;}return i - start;} /**\r\n\t * Get parent selector extension node\r\n\t * @return {Node}\r\n\t */function getParentSelectorExtension(){var type=NodeType.ParentSelectorExtensionType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];while(pos < tokensLength) {if(checkNumber(pos)){content.push(getNumber());}else if(checkPartialIdent(pos)){content.push(getIdent());}else if(checkIdentOrInterpolation(pos)){content = content.concat(getIdentOrInterpolation());}else break;}return newNode(type,content,line,column);} /**\r\n\t * Check if token is a parent selector with an extension or not\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the parent selector and extension if applicable\r\n\t */function checkParentSelectorWithExtension(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkParentSelector(i))i += l;else return 0;if(l = checkParentSelectorExtension(i))i += l;return i - start;} /**\r\n\t * Get parent selector node and extension node if applicable\r\n\t * @return {Array}\r\n\t */function getParentSelectorWithExtension(){var content=[getParentSelector()];if(checkParentSelectorExtension(pos))content.push(getParentSelectorExtension());return content;} /**\r\n\t * Check if token is part of a number or an interpolation with a percent sign\r\n\t * (e.g. `10%`).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkPercentage(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkNumberOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.PercentSign)return 0;return i - start + 1;} /**\r\n\t * Get a percentage node that contains either a number or an interpolation\r\n\t * @return {Object} The percentage node\r\n\t */function getPercentage(){var startPos=pos;var token=tokens[startPos];var line=token.ln;var column=token.col;var content=getNumberOrInterpolation();var end=getLastPosition(content,line,column,1); // Skip %\r\n\tpos++;return newNode(NodeType.PercentageType,content,token.ln,token.col,end);} /**\r\n\t * Check if token is a number or an interpolation\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkNumberOrInterpolation(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkInterpolation(i) || checkNumber(i))i += l;else break;}return i - start;} /**\r\n\t * Get a number and/or interpolation node\r\n\t * @return {Array} An array containing a single or multiple nodes\r\n\t */function getNumberOrInterpolation(){var content=[];while(pos < tokensLength) {if(checkInterpolation(pos))content.push(getInterpolation());else if(checkNumber(pos))content.push(getNumber());else break;}return content;} /**\r\n\t * Check if token is part of a placeholder selector (e.g. `%abc`).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the selector\r\n\t */function checkPlaceholder(i){var l;if(i >= tokensLength)return 0;if(tokens[i].placeholder_l)return tokens[i].placeholder_l;if(tokens[i].type !== TokenType.PercentSign){return 0;}if(l = checkIdentOrInterpolation(i + 1)){tokens[i].placeholder_l = l + 1;return l + 1;}return 0;} /**\r\n\t * Get node with a placeholder selector\r\n\t * @return {Array} `['placeholder', ['ident', x]]` where x is a placeholder's\r\n\t *      identifier (without `%`, e.g. `abc`).\r\n\t */function getPlaceholder(){var startPos=pos;pos++;var x=getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.PlaceholderType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkProgid(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(joinValues2(i,6) === 'progid:DXImageTransform.Microsoft.')i += 6;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(tokens[i].type === TokenType.LeftParenthesis){tokens[start].progid_end = tokens[i].right;i = tokens[i].right + 1;}else return 0;return i - start;} /**\r\n\t * @return {Array}\r\n\t */function getProgid(){var startPos=pos;var progid_end=tokens[pos].progid_end;var x=joinValues(pos,progid_end);pos = progid_end + 1;var token=tokens[startPos];return newNode(NodeType.ProgidType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a property\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the property\r\n\t */function checkProperty(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkVariable(i) || checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a property\r\n\t * @return {Array} `['property', x]`\r\n\t */function getProperty(){var startPos=pos;var x=[];if(checkVariable(pos)){x.push(getVariable());}else {x = x.concat(getIdentOrInterpolation());}var token=tokens[startPos];return newNode(NodeType.PropertyType,x,token.ln,token.col);} /**\r\n\t * Check if token is a colon\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is a colon, otherwise `0`\r\n\t */function checkPropertyDelim(i){return i < tokensLength && tokens[i].type === TokenType.Colon?1:0;} /**\r\n\t * Get node with a colon\r\n\t * @return {Array} `['propertyDelim']`\r\n\t */function getPropertyDelim(){var startPos=pos++;var token=tokens[startPos];return newNode(NodeType.PropertyDelimType,':',token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkPseudo(i){return checkPseudoe(i) || checkPseudoc(i);} /**\r\n\t * @return {Array}\r\n\t */function getPseudo(){if(checkPseudoe(pos))return getPseudoe();if(checkPseudoc(pos))return getPseudoc();} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkPseudoe(i){var l;if(i >= tokensLength || tokens[i++].type !== TokenType.Colon || i >= tokensLength || tokens[i++].type !== TokenType.Colon)return 0;return (l = checkIdentOrInterpolation(i))?l + 2:0;} /**\r\n\t * @return {Array}\r\n\t */function getPseudoe(){var startPos=pos;pos += 2;var x=getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.PseudoeType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkPseudoc(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.Colon)return 0;if(l = checkPseudoClass3(i))tokens[i].pseudoClassType = 3;else if(l = checkPseudoClass4(i))tokens[i].pseudoClassType = 4;else if(l = checkPseudoClass5(i))tokens[i].pseudoClassType = 5;else if(l = checkPseudoClass1(i))tokens[i].pseudoClassType = 1;else if(l = checkPseudoClass2(i))tokens[i].pseudoClassType = 2;else if(l = checkPseudoClass6(i))tokens[i].pseudoClassType = 6;else return 0;return l;} /**\r\n\t * @return {Array}\r\n\t */function getPseudoc(){var childType=tokens[pos].pseudoClassType;if(childType === 1)return getPseudoClass1();if(childType === 2)return getPseudoClass2();if(childType === 3)return getPseudoClass3();if(childType === 4)return getPseudoClass4();if(childType === 5)return getPseudoClass5();if(childType === 6)return getPseudoClass6();} /**\r\n\t * (-) `:not(panda)`\r\n\t */function checkPseudoClass1(i){var start=i; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;var l=undefined;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSelectorsGroup(i))i += l;else return 0;if(i !== right)return 0;return right - start + 1;} /**\r\n\t * (-) `:not(panda)`\r\n\t */function getPseudoClass1(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `:`.\r\n\tpos++;content = content.concat(getIdentOrInterpolation());{var _type=NodeType.ArgumentsType;var _token=tokens[pos];var _line=_token.ln;var _column=_token.col; // Skip `(`.\r\n\tpos++;var selectors=getSelectorsGroup();var end=getLastPosition(selectors,_line,_column,1);var args=newNode(_type,selectors,_line,_column,end);content.push(args); // Skip `)`.\r\n\tpos++;}return newNode(type,content,line,column);} /**\r\n\t * (1) `:nth-child(odd)`\r\n\t * (2) `:nth-child(even)`\r\n\t * (3) `:lang(de-DE)`\r\n\t */function checkPseudoClass2(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass2(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `:`.\r\n\tpos++;content = content.concat(getIdentOrInterpolation());var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;value = value.concat(getSC()).concat(getIdentOrInterpolation()).concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:nth-child(-3n + 2)`\r\n\t */function checkPseudoClass3(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(l = checkNumberOrInterpolation(i))i += l;if(i >= tokensLength)return 0;if(tokens[i].value === 'n')i++;else return 0;if(l = checkSC(i))i += l;if(i >= tokensLength)return 0;if(tokens[i].type === TokenType.PlusSign || tokens[i].type === TokenType.HyphenMinus)i++;else return 0;if(l = checkSC(i))i += l;if(l = checkNumberOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass3(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;if(checkUnary(pos))value.push(getUnary());if(checkNumberOrInterpolation(pos))value = value.concat(getNumberOrInterpolation());{var _l=tokens[pos].ln;var _c=tokens[pos].col;var _content=tokens[pos].value;var ident=newNode(NodeType.IdentType,_content,_l,_c);value.push(ident);pos++;}value = value.concat(getSC());if(checkUnary(pos))value.push(getUnary());value = value.concat(getSC());if(checkNumberOrInterpolation(pos))value = value.concat(getNumberOrInterpolation());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:nth-child(-3n)`\r\n\t */function checkPseudoClass4(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(l = checkInterpolation(i))i += l;if(tokens[i].type === TokenType.DecimalNumber)i++;if(tokens[i].value === 'n')i++;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass4(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;if(checkUnary(pos))value.push(getUnary());if(checkInterpolation(pos))value.push(getInterpolation());if(checkNumber(pos))value.push(getNumber());if(checkIdent(pos))value.push(getIdent());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:nth-child(+8)`\r\n\t */function checkPseudoClass5(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(tokens[i].type === TokenType.DecimalNumber)i++;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass5(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;if(checkUnary(pos))value.push(getUnary());if(checkNumber(pos))value.push(getNumber());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:checked`\r\n\t */function checkPseudoClass6(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getPseudoClass6(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();return newNode(type,content,line,column);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkRuleset(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i)){i += l;}else if(l = checkSC(i)){i += l;if(l = checkBlock(i))i += l;else return 0;}else return 0;return i - start;}function getRuleset(){var type=NodeType.RulesetType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content = content.concat(getSelectorsGroup());content = content.concat(getSC());if(checkBlock(pos)){content.push(getBlock());}else {content = content.concat(getSC(),getBlock());}return newNode(type,content,line,column);} /**\r\n\t * Check if token is marked as a space (if it's a space or a tab\r\n\t *      or a line break).\r\n\t * @param {number} i\r\n\t * @return {number} Number of spaces in a row starting with the given token.\r\n\t */function checkS(i){return i < tokensLength && tokens[i].ws?tokens[i].ws_last - i + 1:0;} /**\r\n\t * Get node with spaces\r\n\t * @return {Array} `['s', x]` where `x` is a string containing spaces\r\n\t */function getS(){var startPos=pos;var x=joinValues(pos,tokens[pos].ws_last);pos = tokens[pos].ws_last + 1;var token=tokens[startPos];return newNode(NodeType.SType,x,token.ln,token.col);} /**\r\n\t * Check if token is a space or a comment.\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Number of similar (space or comment) tokens\r\n\t *      in a row starting with the given token.\r\n\t */function checkSC(i){if(!tokens[i])return 0;var l=undefined;var lsc=0;var ln=tokens[i].ln;while(i < tokensLength) {if(tokens[i].ln !== ln)break;if(!(l = checkS(i)) && !(l = checkCommentML(i)) && !(l = checkCommentSL(i)))break;i += l;lsc += l;if(tokens[i] && tokens[i].type === TokenType.Newline)break;}return lsc || 0;} /**\r\n\t * Get node with spaces and comments\r\n\t * @return {Array} Array containing nodes with spaces (if there are any)\r\n\t *      and nodes with comments (if there are any):\r\n\t *      `[['s', x]*, ['comment', y]*]` where `x` is a string of spaces\r\n\t *      and `y` is a comment's text (without `/*` and `* /`).\r\n\t */function getSC(){var sc=[];var ln=undefined;if(pos >= tokensLength)return sc;ln = tokens[pos].ln;while(pos < tokensLength) {if(tokens[pos].ln !== ln)break;else if(checkS(pos))sc.push(getS());else if(checkCommentML(pos))sc.push(getCommentML());else if(checkCommentSL(pos))sc.push(getCommentSL());else break;if(tokens[pos] && tokens[pos].type === TokenType.Newline)break;}return sc;} /**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      a simple selector\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkShash(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.NumberSign)return 0;return (l = checkIdentOrInterpolation(i + 1))?l + 1:0;} /**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside a simple\r\n\t *      selector\r\n\t * @return {Array} `['shash', x]` where `x` is a hexadecimal number\r\n\t *      converted to string (without `#`, e.g. `fff`)\r\n\t */function getShash(){var startPos=pos;var token=tokens[startPos];pos++;var x=getIdentOrInterpolation();return newNode(NodeType.ShashType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a string (text wrapped in quotes)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is part of a string, `0` if not\r\n\t */function checkString(i){if(i >= tokensLength){return 0;}if(tokens[i].type === TokenType.StringSQ || tokens[i].type === TokenType.StringDQ){return 1;}return 0;} /**\r\n\t * Get string's node\r\n\t * @return {Array} `['string', x]` where `x` is a string (including\r\n\t *      quotes).\r\n\t */function getString(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.StringType,x,token.ln,token.col);} /**\r\n\t * Validate stylesheet: it should consist of any number (0 or more) of\r\n\t * rulesets (sets of rules with selectors), @-rules, whitespaces or\r\n\t * comments.\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkStylesheet(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkSC(i) || checkDeclaration(i) || checkDeclDelim(i) || checkInclude(i) || checkExtend(i) || checkMixin(i) || checkLoop(i) || checkConditionalStatement(i) || checkAtrule(i) || checkRuleset(i))i += l;else throwError(i);}return i - start;} /**\r\n\t * @return {Array} `['stylesheet', x]` where `x` is all stylesheet's\r\n\t *      nodes.\r\n\t */function getStylesheet(){var startPos=pos;var x=[];var node;var wasDeclaration=false;while(pos < tokensLength) {if(wasDeclaration && checkDeclDelim(pos))node = getDeclDelim();else if(checkSC(pos))node = getSC();else if(checkRuleset(pos))node = getRuleset();else if(checkInclude(pos))node = getInclude();else if(checkExtend(pos))node = getExtend();else if(checkMixin(pos))node = getMixin();else if(checkLoop(pos))node = getLoop();else if(checkConditionalStatement(pos))node = getConditionalStatement();else if(checkAtrule(pos))node = getAtrule();else if(checkDeclaration(pos))node = getDeclaration();else throwError();wasDeclaration = node.type === NodeType.DeclarationType;if(Array.isArray(node))x = x.concat(node);else x.push(node);}var token=tokens[startPos];return newNode(NodeType.StylesheetType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkTset(i){return checkVhash(i) || checkOperator(i) || checkAny(i) || checkSC(i) || checkInterpolation(i);} /**\r\n\t * @return {Array}\r\n\t */function getTset(){if(checkVhash(pos))return getVhash();else if(checkOperator(pos))return getOperator();else if(checkAny(pos))return getAny();else if(checkSC(pos))return getSC();else if(checkInterpolation(pos))return getInterpolation();} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkTsets(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;while(tokens[i - 1].type !== TokenType.Newline && (l = checkTset(i))) {i += l;}return i - start;} /**\r\n\t * @return {Array}\r\n\t */function getTsets(){var x=[];var t=undefined;while(tokens[pos - 1].type !== TokenType.Newline && (t = getTset())) {if(typeof t.content === 'string')x.push(t);else x = x.concat(t);}return x;} /**\r\n\t * Check if token is an unary (arithmetical) sign (`+` or `-`)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} `1` if token is an unary sign, `0` if not\r\n\t */function checkUnary(i){if(i >= tokensLength){return 0;}if(tokens[i].type === TokenType.HyphenMinus || tokens[i].type === TokenType.PlusSign){return 1;}return 0;} /**\r\n\t * Get node with an unary (arithmetical) sign (`+` or `-`)\r\n\t * @return {Array} `['unary', x]` where `x` is an unary sign\r\n\t *      converted to string.\r\n\t */function getUnary(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.OperatorType,x,token.ln,token.col);} /**\r\n\t * Check if token is a unicode range (single or multiple <urange> nodes)\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Unicode range node's length\r\n\t */function checkUnicodeRange(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkUrange(i))i += l;else return 0;while(i < tokensLength) {var spaceBefore=checkSC(i);var comma=checkDelim(i + spaceBefore);if(!comma)break;var spaceAfter=checkSC(i + spaceBefore + comma);if(l = checkUrange(i + spaceBefore + comma + spaceAfter)){i += spaceBefore + comma + spaceAfter + l;}else break;}return i - start;} /**\r\n\t * Get a unicode range node\r\n\t * @return {Node}\r\n\t */function getUnicodeRange(){var type=NodeType.UnicodeRangeType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];while(pos < tokensLength) {if(checkSC(pos))content = content.concat(getSC());else if(checkDelim(pos))content.push(getDelim());else if(checkUrange(pos))content.push(getUrange());else break;}return newNode(type,content,line,column);} /**\r\n\t * Check if token is a u-range (part of a unicode-range)\r\n\t * (1) `U+416`\r\n\t * (2) `U+400-4ff`\r\n\t * (3) `U+4??`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Urange node's length\r\n\t */function checkUrange(i){var start=i;var l=undefined;if(i >= tokensLength)return 0; // Check for unicode prefix (u+ or U+)\r\n\tif(tokens[i].value === 'U' || tokens[i].value === 'u')i += 1;else return 0;if(i >= tokensLength)return 0;if(tokens[i].value === '+')i += 1;else return 0;while(i < tokensLength) {if(l = checkIdent(i))i += l;else if(l = checkNumber(i))i += l;else if(l = checkUnary(i))i += l;else if(l = _checkUnicodeWildcard(i))i += l;else break;}tokens[start].urangeEnd = i - 1;return i - start;} /**\r\n\t * Get a u-range node (part of a unicode-range)\r\n\t * @return {Node}\r\n\t */function getUrange(){var startPos=pos;var type=NodeType.UrangeType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content = joinValues(startPos,tokens[startPos].urangeEnd);pos = tokens[startPos].urangeEnd + 1;return newNode(type,content,line,column);} /**\r\n\t * Check for unicode wildcard characters `?`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Wildcard length\r\n\t */function _checkUnicodeWildcard(i){var start=i;if(i >= tokensLength)return 0;while(i < tokensLength) {if(tokens[i].type === TokenType.QuestionMark)i += 1;else break;}return i - start;} /**\r\n\t * Check if token is part of URI (e.g. `url('/css/styles.css')`)\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of URI\r\n\t */function checkUri(i){var start=i;if(i >= tokensLength || tokens[i++].value !== 'url' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - start + 1;} /**\r\n\t * Get node with URI\r\n\t * @return {Array} `['uri', x]` where `x` is URI's nodes (without `url`\r\n\t *      and braces, e.g. `['string', ''/css/styles.css'']`).\r\n\t */function getUri(){var startPos=pos;var uriExcluding={};var uri=undefined;var token=undefined;var l=undefined;var raw=undefined;pos += 2;uriExcluding[TokenType.Space] = 1;uriExcluding[TokenType.Tab] = 1;uriExcluding[TokenType.Newline] = 1;uriExcluding[TokenType.LeftParenthesis] = 1;uriExcluding[TokenType.RightParenthesis] = 1;if(checkUriContent(pos)){uri = [].concat(getSC()).concat(getUriContent()).concat(getSC());}else {uri = [].concat(getSC());l = checkExcluding(uriExcluding,pos);token = tokens[pos];raw = newNode(NodeType.RawType,joinValues(pos,pos + l),token.ln,token.col);uri.push(raw);pos += l + 1;uri = uri.concat(getSC());}token = tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition(uri,line,column,1);pos++;return newNode(NodeType.UriType,uri,token.ln,token.col,end);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkUriContent(i){return checkUri1(i) || checkFunction(i);} /**\r\n\t * @return {Array}\r\n\t */function getUriContent(){if(checkUri1(pos))return getString();else if(checkFunction(pos))return getFunction();} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkUri1(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkSC(i))i += l;if(tokens[i].type !== TokenType.StringDQ && tokens[i].type !== TokenType.StringSQ)return 0;i++;if(l = checkSC(i))i += l;return i - start;} /**\r\n\t * Check if token is part of a value\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the value\r\n\t */function checkValue(i){var start=i;var l=undefined;var s=undefined;var _i=undefined;while(i < tokensLength) {if(checkDeclDelim(i))break;if(l = checkBlock(i)){i += l;break;}s = checkS(i);_i = i + s;if(l = _checkValue(_i))i += l + s;if(!l || checkBlock(i - l))break;}return i - start;} /**\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function _checkValue(i){return checkVhash(i) || checkOperator(i) || checkImportant(i) || checkGlobal(i) || checkDefault(i) || checkProgid(i) || checkAny(i) || checkInterpolation(i) || checkParentSelector(i);} /**\r\n\t * @return {Array}\r\n\t */function getValue(){var startPos=pos;var x=[];var _pos=undefined;var s=undefined;while(pos < tokensLength) {if(checkDeclDelim(pos))break;s = checkS(pos);_pos = pos + s;if(checkDeclDelim(_pos))break;if(checkBlock(pos)){x.push(getBlock());break;}if(!_checkValue(_pos))break;if(s)x.push(getS());x.push(_getValue());if(checkBlock(_pos))break;}var token=tokens[startPos];return newNode(NodeType.ValueType,x,token.ln,token.col);} /**\r\n\t * @return {Array}\r\n\t */function _getValue(){if(checkVhash(pos))return getVhash();if(checkOperator(pos))return getOperator();if(checkImportant(pos))return getImportant();if(checkGlobal(pos))return getGlobal();if(checkDefault(pos))return getDefault();if(checkProgid(pos))return getProgid();if(checkAny(pos))return getAny();if(checkInterpolation(pos))return getInterpolation();if(checkParentSelector(pos))return getParentSelector();} /**\r\n\t * Check if token is part of a variable\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the variable\r\n\t */function checkVariable(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.DollarSign)return 0;return (l = checkIdent(i + 1))?l + 1:0;} /**\r\n\t * Get node with a variable\r\n\t * @return {Array} `['variable', ['ident', x]]` where `x` is\r\n\t *      a variable name.\r\n\t */function getVariable(){var startPos=pos;var x=[];pos++;x.push(getIdent());var token=tokens[startPos];return newNode(NodeType.VariableType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a variables list (e.g. `$values...`).\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkVariablesList(i){var d=0; // Number of dots\r\n\tvar l=undefined;if(i >= tokensLength)return 0;if(l = checkVariable(i))i += l;else return 0;while(i < tokensLength && tokens[i].type === TokenType.FullStop) {d++;i++;}return d === 3?l + d:0;} /**\r\n\t * Get node with a variables list\r\n\t * @return {Array} `['variableslist', ['variable', ['ident', x]]]` where\r\n\t *      `x` is a variable name.\r\n\t */function getVariablesList(){var startPos=pos;var x=[getVariable()];var token=tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition(x,line,column,3);pos += 3;return newNode(NodeType.VariablesListType,x,token.ln,token.col,end);} /**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      some value\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkVhash(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.NumberSign)return 0;return (l = checkNmName2(i + 1))?l + 1:0;} /**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside some value\r\n\t * @return {Array} `['vhash', x]` where `x` is a hexadecimal number\r\n\t *      converted to string (without `#`, e.g. `'fff'`).\r\n\t */function getVhash(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;x = getNmName2();var end=getLastPosition(x,line,column + 1);return newNode(NodeType.VhashType,x,token.ln,token.col,end);}module.exports = function(_tokens,context){tokens = _tokens;tokensLength = tokens.length;pos = 0;return contexts[context]();};function checkSelectorsGroup(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkSelector(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);var c=checkDelim(i + sb);if(!c)break;var sa=checkSC(i + sb + c);var saa=sa?checkSC(i + sb + c + sa):0;if(l = checkSelector(i + sb + c + sa + saa))i += sb + c + sa + saa + l;else break;}tokens[start].selectorsGroupEnd = i;return i - start;}function getSelectorsGroup(){var selectorsGroup=[];var selectorsGroupEnd=tokens[pos].selectorsGroupEnd;selectorsGroup.push(getSelector());while(pos < selectorsGroupEnd) {selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getDelim());selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getSelector());}return selectorsGroup;}function checkSelector(i){var l;if(l = checkSelector1(i))tokens[i].selectorType = 1;else if(l = checkSelector2(i))tokens[i].selectorType = 2;return l;}function getSelector(){var selectorType=tokens[pos].selectorType;if(selectorType === 1)return getSelector1();else return getSelector2();} /**\r\n\t * Checks for selector which starts with a compound selector.\r\n\t */function checkSelector1(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkCompoundSelector(i))i += l;else return 0;while(i < tokensLength) {var s=checkSC(i);var c=checkCombinator(i + s);if(!s && !c)break;if(c){i += s + c;s = checkSC(i);}if(l = checkCompoundSelector(i + s))i += s + l;else break;}tokens[start].selectorEnd = i;return i - start;}function getSelector1(){var type=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var selectorEnd=token.selectorEnd;var content=getCompoundSelector();while(pos < selectorEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkCombinator(pos))content.push(getCombinator());else if(checkCompoundSelector(pos))content = content.concat(getCompoundSelector());}return newNode(type,content,line,column);} /**\r\n\t * Checks for a selector that starts with a combinator.\r\n\t */function checkSelector2(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkCombinator(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);if(l = checkCompoundSelector(i + sb))i += sb + l;else break;var sa=checkSC(i);var c=checkCombinator(i + sa);if(!sa && !c)break;if(c){i += sa + c;}}tokens[start].selectorEnd = i;return i - start;}function getSelector2(){var type=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var selectorEnd=token.selectorEnd;var content=[getCombinator()];while(pos < selectorEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkCombinator(pos))content.push(getCombinator());else if(checkCompoundSelector(pos))content = content.concat(getCompoundSelector());}return newNode(type,content,line,column);}function checkCompoundSelector(i){var l=undefined;if(l = checkCompoundSelector1(i)){tokens[i].compoundSelectorType = 1;}else if(l = checkCompoundSelector2(i)){tokens[i].compoundSelectorType = 2;}return l;}function getCompoundSelector(){var type=tokens[pos].compoundSelectorType;if(type === 1)return getCompoundSelector1();if(type === 2)return getCompoundSelector2();} /**\r\n\t * Check for compound selectors that start with either a type selector,\r\n\t * placeholder or parent selector with extension\r\n\t * (1) `foo.bar`\r\n\t * (2) `foo[attr=val]`\r\n\t * (3) `foo:first-of-type`\r\n\t * (4) `foo%bar`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Compound selector's length\r\n\t */function checkCompoundSelector1(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkTypeSelector(i) || checkPlaceholder(i) || checkParentSelectorWithExtension(i))i += l;else return 0;while(i < tokensLength) {var _l2=checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i) || checkPlaceholder(i);if(_l2)i += _l2;else break;}tokens[start].compoundSelectorEnd = i;return i - start;} /**\r\n\t * @return {Array} An array of nodes that make up the compound selector\r\n\t */function getCompoundSelector1(){var sequence=[];var compoundSelectorEnd=tokens[pos].compoundSelectorEnd;if(checkTypeSelector(pos))sequence.push(getTypeSelector());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());else if(checkParentSelectorWithExtension(pos))sequence = sequence.concat(getParentSelectorWithExtension());while(pos < compoundSelectorEnd) {if(checkShash(pos))sequence.push(getShash());else if(checkClass(pos))sequence.push(getClass());else if(checkAttributeSelector(pos))sequence.push(getAttributeSelector());else if(checkPseudo(pos))sequence.push(getPseudo());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());else break;}return sequence;} /**\r\n\t * Check for all other compound selectors\r\n\t * (1) `.foo.bar`\r\n\t * (2) `.foo[attr=val]`\r\n\t * (3) `.foo:first-of-type`\r\n\t * (4) `.foo%bar`\r\n\t * (5) `.foo#{$bar}`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Compound selector's length\r\n\t */function checkCompoundSelector2(i){if(i >= tokensLength)return 0;var start=i;while(i < tokensLength) {var l=checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i) || checkPlaceholder(i) || checkInterpolation(i);if(l)i += l;else break;}tokens[start].compoundSelectorEnd = i;return i - start;} /**\r\n\t * @return {Array} An array of nodes that make up the compound selector\r\n\t */function getCompoundSelector2(){var sequence=[];var compoundSelectorEnd=tokens[pos].compoundSelectorEnd;while(pos < compoundSelectorEnd) {if(checkShash(pos))sequence.push(getShash());else if(checkClass(pos))sequence.push(getClass());else if(checkAttributeSelector(pos))sequence.push(getAttributeSelector());else if(checkPseudo(pos))sequence.push(getPseudo());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());else if(checkInterpolation(pos))sequence.push(getInterpolation());else break;}return sequence;}function checkTypeSelector(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkNamePrefix(i))i += l;if(tokens[i].type === TokenType.Asterisk)i++;else if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getTypeSelector(){var type=NodeType.TypeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkNamePrefix(pos))content.push(getNamePrefix());token = tokens[pos];if(token.type === TokenType.Asterisk){var asteriskNode=newNode(NodeType.IdentType,'*',token.ln,token.col);content.push(asteriskNode);pos++;}else if(checkIdentOrInterpolation(pos))content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeSelector(i){var l=undefined;if(l = checkAttributeSelector1(i))tokens[i].attributeSelectorType = 1;else if(l = checkAttributeSelector2(i))tokens[i].attributeSelectorType = 2;return l;}function getAttributeSelector(){var type=tokens[pos].attributeSelectorType;if(type === 1)return getAttributeSelector1();else return getAttributeSelector2();} /**\r\n\t * (1) `[panda=nani]`\r\n\t * (2) `[panda='nani']`\r\n\t * (3) `[panda='nani' i]`\r\n\t *\r\n\t */function checkAttributeSelector1(i){var start=i;if(tokens[i].type === TokenType.LeftSquareBracket)i++;else return 0;var l=undefined;if(l = checkSC(i))i += l;if(l = checkAttributeName(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeMatch(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeValue(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeFlags(i)){i += l;if(l = checkSC(i))i += l;}if(tokens[i].type === TokenType.RightSquareBracket)i++;else return 0;return i - start;}function getAttributeSelector1(){var type=NodeType.AttributeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `[`.\r\n\tpos++;content = content.concat(getSC());content.push(getAttributeName());content = content.concat(getSC());content.push(getAttributeMatch());content = content.concat(getSC());content.push(getAttributeValue());content = content.concat(getSC());if(checkAttributeFlags(pos)){content.push(getAttributeFlags());content = content.concat(getSC());} // Skip `]`.\r\n\tpos++;var end=getLastPosition(content,line,column,1);return newNode(type,content,line,column,end);} /**\r\n\t * (1) `[panda]`\r\n\t */function checkAttributeSelector2(i){var start=i;if(tokens[i].type === TokenType.LeftSquareBracket)i++;else return 0;var l=undefined;if(l = checkSC(i))i += l;if(l = checkAttributeName(i))i += l;else return 0;if(l = checkSC(i))i += l;if(tokens[i].type === TokenType.RightSquareBracket)i++;else return 0;return i - start;}function getAttributeSelector2(){var type=NodeType.AttributeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `[`.\r\n\tpos++;content = content.concat(getSC());content.push(getAttributeName());content = content.concat(getSC()); // Skip `]`.\r\n\tpos++;var end=getLastPosition(content,line,column,1);return newNode(type,content,line,column,end);}function checkAttributeName(i){var start=i;var l=undefined;if(l = checkNamePrefix(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getAttributeName(){var type=NodeType.AttributeNameType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkNamePrefix(pos))content.push(getNamePrefix());content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeMatch(i){var l=undefined;if(l = checkAttributeMatch1(i))tokens[i].attributeMatchType = 1;else if(l = checkAttributeMatch2(i))tokens[i].attributeMatchType = 2;return l;}function getAttributeMatch(){var type=tokens[pos].attributeMatchType;if(type === 1)return getAttributeMatch1();else return getAttributeMatch2();}function checkAttributeMatch1(i){var start=i;var type=tokens[i].type;if(type === TokenType.Tilde || type === TokenType.VerticalLine || type === TokenType.CircumflexAccent || type === TokenType.DollarSign || type === TokenType.Asterisk)i++;else return 0;if(tokens[i].type === TokenType.EqualsSign)i++;else return 0;return i - start;}function getAttributeMatch1(){var type=NodeType.AttributeMatchType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=tokens[pos].value + tokens[pos + 1].value;pos += 2;return newNode(type,content,line,column);}function checkAttributeMatch2(i){if(tokens[i].type === TokenType.EqualsSign)return 1;else return 0;}function getAttributeMatch2(){var type=NodeType.AttributeMatchType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='=';pos++;return newNode(type,content,line,column);}function checkAttributeValue(i){return checkString(i) || checkIdentOrInterpolation(i);}function getAttributeValue(){var type=NodeType.AttributeValueType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkString(pos))content.push(getString());else content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeFlags(i){return checkIdentOrInterpolation(i);}function getAttributeFlags(){var type=NodeType.AttributeFlagsType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=getIdentOrInterpolation();return newNode(type,content,line,column);}function checkNamePrefix(i){if(i >= tokensLength)return 0;var l=undefined;if(l = checkNamePrefix1(i))tokens[i].namePrefixType = 1;else if(l = checkNamePrefix2(i))tokens[i].namePrefixType = 2;return l;}function getNamePrefix(){var type=tokens[pos].namePrefixType;if(type === 1)return getNamePrefix1();else return getNamePrefix2();} /**\r\n\t * (1) `panda|`\r\n\t * (2) `panda<comment>|`\r\n\t */function checkNamePrefix1(i){var start=i;var l=undefined;if(l = checkNamespacePrefix(i))i += l;else return 0;if(l = checkCommentML(i))i += l;if(l = checkNamespaceSeparator(i))i += l;else return 0;return i - start;}function getNamePrefix1(){var type=NodeType.NamePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content.push(getNamespacePrefix());if(checkCommentML(pos))content.push(getCommentML());content.push(getNamespaceSeparator());return newNode(type,content,line,column);} /**\r\n\t * (1) `|`\r\n\t */function checkNamePrefix2(i){return checkNamespaceSeparator(i);}function getNamePrefix2(){var type=NodeType.NamePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[getNamespaceSeparator()];return newNode(type,content,line,column);} /**\r\n\t * (1) `*`\r\n\t * (2) `panda`\r\n\t */function checkNamespacePrefix(i){if(i >= tokensLength)return 0;var l=undefined;if(tokens[i].type === TokenType.Asterisk)return 1;else if(l = checkIdentOrInterpolation(i))return l;else return 0;}function getNamespacePrefix(){var type=NodeType.NamespacePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(token.type === TokenType.Asterisk){var asteriskNode=newNode(NodeType.IdentType,'*',token.ln,token.col);content.push(asteriskNode);pos++;}else if(checkIdentOrInterpolation(pos))content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);} /**\r\n\t * (1) `|`\r\n\t */function checkNamespaceSeparator(i){if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.VerticalLine)return 0; // Return false if `|=` - [attr|=value]\r\n\tif(tokens[i + 1] && tokens[i + 1].type === TokenType.EqualsSign)return 0;return 1;}function getNamespaceSeparator(){var type=NodeType.NamespaceSeparatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='|';pos++;return newNode(type,content,line,column);}\r\n\r\n/***/ },\r\n/* 24 */\r\n/***/ function(module, exports, __nested_webpack_require_410836__) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function (css, tabSize) {\r\n\t  var TokenType = __nested_webpack_require_410836__(13);\r\n\r\n\t  var tokens = [];\r\n\t  var urlMode = false;\r\n\t  var c = undefined; // Current character\r\n\t  var cn = undefined; // Next character\r\n\t  var pos = 0;\r\n\t  var tn = 0;\r\n\t  var ln = 1;\r\n\t  var col = 1;\r\n\r\n\t  var Punctuation = {\r\n\t    ' ': TokenType.Space,\r\n\t    '\\n': TokenType.Newline,\r\n\t    '\\r': TokenType.Newline,\r\n\t    '\\t': TokenType.Tab,\r\n\t    '!': TokenType.ExclamationMark,\r\n\t    '\"': TokenType.QuotationMark,\r\n\t    '#': TokenType.NumberSign,\r\n\t    '$': TokenType.DollarSign,\r\n\t    '%': TokenType.PercentSign,\r\n\t    '&': TokenType.Ampersand,\r\n\t    '\\'': TokenType.Apostrophe,\r\n\t    '(': TokenType.LeftParenthesis,\r\n\t    ')': TokenType.RightParenthesis,\r\n\t    '*': TokenType.Asterisk,\r\n\t    '+': TokenType.PlusSign,\r\n\t    ',': TokenType.Comma,\r\n\t    '-': TokenType.HyphenMinus,\r\n\t    '.': TokenType.FullStop,\r\n\t    '/': TokenType.Solidus,\r\n\t    ':': TokenType.Colon,\r\n\t    ';': TokenType.Semicolon,\r\n\t    '<': TokenType.LessThanSign,\r\n\t    '=': TokenType.EqualsSign,\r\n\t    '==': TokenType.EqualitySign,\r\n\t    '!=': TokenType.InequalitySign,\r\n\t    '>': TokenType.GreaterThanSign,\r\n\t    '?': TokenType.QuestionMark,\r\n\t    '@': TokenType.CommercialAt,\r\n\t    '[': TokenType.LeftSquareBracket,\r\n\t    ']': TokenType.RightSquareBracket,\r\n\t    '^': TokenType.CircumflexAccent,\r\n\t    '_': TokenType.LowLine,\r\n\t    '{': TokenType.LeftCurlyBracket,\r\n\t    '|': TokenType.VerticalLine,\r\n\t    '}': TokenType.RightCurlyBracket,\r\n\t    '~': TokenType.Tilde\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Add a token to the token list\r\n\t   * @param {string} type\r\n\t   * @param {string} value\r\n\t   */\r\n\t  function pushToken(type, value, column) {\r\n\t    tokens.push({\r\n\t      tn: tn++,\r\n\t      ln: ln,\r\n\t      col: column,\r\n\t      type: type,\r\n\t      value: value\r\n\t    });\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Check if a character is a decimal digit\r\n\t   * @param {string} c Character\r\n\t   * @returns {boolean}\r\n\t   */\r\n\t  function isDecimalDigit(c) {\r\n\t    return '0123456789'.indexOf(c) >= 0;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse spaces\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseSpaces(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a non-space character:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) !== ' ') break;\r\n\t    }\r\n\r\n\t    // Add a substring containing only spaces to tokens:\r\n\t    pushToken(TokenType.Space, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse a string within quotes\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   * @param {string} q Quote (either `'` or `\"`)\r\n\t   */\r\n\t  function parseString(css, q) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a matching quote:\r\n\t    for (pos++; pos < css.length; pos++) {\r\n\t      // Skip escaped quotes:\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (css.charAt(pos) === q) break;\r\n\t    }\r\n\r\n\t    // Add the string (including quotes) to tokens:\r\n\t    var type = q === '\"' ? TokenType.StringDQ : TokenType.StringSQ;\r\n\t    pushToken(type, css.substring(start, pos + 1), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse numbers\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseDecimalNumber(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a character that's not a digit:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      if (!isDecimalDigit(css.charAt(pos))) break;\r\n\t    }\r\n\r\n\t    // Add the number to tokens:\r\n\t    pushToken(TokenType.DecimalNumber, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse identifier\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseIdentifier(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Skip all opening slashes:\r\n\t    while (css.charAt(pos) === '/') pos++;\r\n\r\n\t    // Read the string until we meet a punctuation mark:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      // Skip all '\\':\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (css.charAt(pos) in Punctuation) break;\r\n\t    }\r\n\r\n\t    var ident = css.substring(start, pos--);\r\n\r\n\t    // Enter url mode if parsed substring is `url`:\r\n\t    if (!urlMode && ident === 'url' && css.charAt(pos + 1) === '(') {\r\n\t      urlMode = true;\r\n\t    }\r\n\r\n\t    // Add identifier to tokens:\r\n\t    pushToken(TokenType.Identifier, ident, col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse equality sign\r\n\t   */\r\n\t  function parseEquality() {\r\n\t    pushToken(TokenType.EqualitySign, '==', col);\r\n\t    pos++;\r\n\t    col++;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse inequality sign\r\n\t   */\r\n\t  function parseInequality() {\r\n\t    pushToken(TokenType.InequalitySign, '!=', col);\r\n\t    pos++;\r\n\t    col++;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Parse a multiline comment\r\n\t  * @param {string} css Unparsed part of CSS string\r\n\t  */\r\n\t  function parseMLComment(css) {\r\n\t    var start = pos;\r\n\t    var col_ = col;\r\n\r\n\t    // Get current indent level:\r\n\t    var il = 0;\r\n\t    for (var _pos = pos - 1; _pos > -1; _pos--) {\r\n\t      // TODO: Can be tabs:\r\n\t      if (css.charAt(_pos) === ' ') il++;else break;\r\n\t    }\r\n\r\n\t    for (pos += 2; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) === '\\n') {\r\n\t        var _pos = undefined;\r\n\t        // Get new line's indent level:\r\n\t        var _il = 0;\r\n\t        for (_pos = pos + 1; _pos < css.length; _pos++) {\r\n\t          if (css.charAt(_pos) === ' ') _il++;else break;\r\n\t        }\r\n\r\n\t        if (_il > il) {\r\n\t          col = 0;\r\n\t          pos += _pos - pos;\r\n\t        } else {\r\n\t          pos--;\r\n\t          break;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\r\n\t    // If CRLF is used, we need to adjust pos\r\n\t    if (css.charAt(pos) === '\\r') pos--;\r\n\r\n\t    // Add full comment (including `/*`) to the list of tokens:\r\n\t    var comment = css.substring(start, pos + 1);\r\n\t    pushToken(TokenType.CommentML, comment, col_);\r\n\r\n\t    var newlines = comment.split('\\n');\r\n\t    if (newlines.length > 1) {\r\n\t      ln += newlines.length - 1;\r\n\t      col = newlines[newlines.length - 1].length;\r\n\t    } else {\r\n\t      col += pos - start;\r\n\t    }\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Parse a single line comment\r\n\t  * @param {string} css Unparsed part of CSS string\r\n\t  */\r\n\t  function parseSLComment(css) {\r\n\t    var start = pos;\r\n\t    var col_ = col;\r\n\t    var _pos;\r\n\r\n\t    // Check if comment is the only token on the line, and if so,\r\n\t    // get current indent level:\r\n\t    var il = 0;\r\n\t    var onlyToken = false;\r\n\t    for (_pos = pos - 1; _pos > -1; _pos--) {\r\n\t      // TODO: Can be tabs:\r\n\t      if (css.charAt(_pos) === ' ') il++;else if (css.charAt(_pos) === '\\n') {\r\n\t        onlyToken = true;\r\n\t        break;\r\n\t      } else break;\r\n\t    }\r\n\t    if (_pos === -1) onlyToken = true;\r\n\r\n\t    // Read the string until we meet comment end.\r\n\t    // Since we already know first 2 characters (`//`), start reading\r\n\t    // from `pos + 2`:\r\n\t    if (!onlyToken) {\r\n\t      for (pos += 2; pos < css.length; pos++) {\r\n\t        if (css.charAt(pos) === '\\n' || css.charAt(pos) === '\\r') {\r\n\t          break;\r\n\t        }\r\n\t      }\r\n\t    } else {\r\n\t      for (pos += 2; pos < css.length; pos++) {\r\n\t        if (css.charAt(pos) === '\\n') {\r\n\t          // Get new line's indent level:\r\n\t          var _il = 0;\r\n\t          for (_pos = pos + 1; _pos < css.length; _pos++) {\r\n\t            if (css.charAt(_pos) === ' ') _il++;else break;\r\n\t          }\r\n\r\n\t          if (_il > il) {\r\n\t            col = 0;\r\n\t            pos += _pos - pos;\r\n\t          } else {\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\r\n\t    // If CRLF is used, we need to adjust pos\r\n\t    if (css.charAt(pos - 1) === '\\r') pos--;\r\n\r\n\t    // Add comment (including `//` and line break) to the list of tokens:\r\n\t    var comment = css.substring(start, pos--);\r\n\t    pushToken(TokenType.CommentSL, comment, col_);\r\n\r\n\t    var newlines = comment.split('\\n');\r\n\t    if (newlines.length > 1) {\r\n\t      ln += newlines.length - 1;\r\n\t      col = newlines[newlines.length - 1].length;\r\n\t    } else {\r\n\t      col += pos - start;\r\n\t    }\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Convert a CSS string to a list of tokens\r\n\t   * @param {string} css CSS string\r\n\t   * @returns {Array} List of tokens\r\n\t   * @private\r\n\t   */\r\n\t  function getTokens(css) {\r\n\t    // Parse string, character by character:\r\n\t    for (pos = 0; pos < css.length; col++, pos++) {\r\n\t      c = css.charAt(pos);\r\n\t      cn = css.charAt(pos + 1);\r\n\r\n\t      // If we meet `/*`, it's a start of a multiline comment.\r\n\t      // Parse following characters as a multiline comment:\r\n\t      if (c === '/' && cn === '*') {\r\n\t        parseMLComment(css);\r\n\t      }\r\n\r\n\t      // If we meet `//` and it is not a part of url:\r\n\t      else if (!urlMode && c === '/' && cn === '/') {\r\n\t          // If we're currently inside a block, treat `//` as a start\r\n\t          // of identifier. Else treat `//` as a start of a single-line\r\n\t          // comment:\r\n\t          parseSLComment(css);\r\n\t        }\r\n\r\n\t        // If current character is a double or single quote, it's a start\r\n\t        // of a string:\r\n\t        else if (c === '\"' || c === \"'\") {\r\n\t            parseString(css, c);\r\n\t          }\r\n\r\n\t          // If current character is a space:\r\n\t          else if (c === ' ') {\r\n\t              parseSpaces(css);\r\n\t            }\r\n\r\n\t            // If current character is `=`, it must be combined with next `=`\r\n\t            else if (c === '=' && cn === '=') {\r\n\t                parseEquality(css);\r\n\t              }\r\n\r\n\t              // If we meet `!=`, this must be inequality\r\n\t              else if (c === '!' && cn === '=') {\r\n\t                  parseInequality(css);\r\n\t                }\r\n\r\n\t                // If current character is a punctuation mark:\r\n\t                else if (c in Punctuation) {\r\n\t                    // Check for CRLF here or just LF\r\n\t                    if (c === '\\r' && cn === '\\n' || c === '\\n') {\r\n\t                      // If \\r we know the next character is \\n due to statement above\r\n\t                      // so we push a CRLF token type to the token list and importantly\r\n\t                      // skip the next character so as not to double count newlines or\r\n\t                      // columns etc\r\n\t                      if (c === '\\r') {\r\n\t                        pushToken(TokenType.Newline, '\\r\\n', col);\r\n\t                        pos++; // If CRLF skip the next character and push crlf token\r\n\t                      } else if (c === '\\n') {\r\n\t                          // If just a LF newline and not part of CRLF newline we can just\r\n\t                          // push punctuation as usual\r\n\t                          pushToken(Punctuation[c], c, col);\r\n\t                        }\r\n\r\n\t                      ln++; // Go to next line\r\n\t                      col = 0; // Reset the column count\r\n\t                    } else if (c !== '\\r' && c !== '\\n') {\r\n\t                        // Handle all other punctuation and add to list of tokens\r\n\t                        pushToken(Punctuation[c], c, col);\r\n\t                      } // Go to next line\r\n\t                    if (c === ')') urlMode = false; // Exit url mode\r\n\t                    else if (c === '\\t' && tabSize > 1) col += tabSize - 1;\r\n\t                  }\r\n\r\n\t                  // If current character is a decimal digit:\r\n\t                  else if (isDecimalDigit(c)) {\r\n\t                      parseDecimalNumber(css);\r\n\t                    }\r\n\r\n\t                    // If current character is anything else:\r\n\t                    else {\r\n\t                        parseIdentifier(css);\r\n\t                      }\r\n\t    }\r\n\r\n\t    return tokens;\r\n\t  }\r\n\r\n\t  return getTokens(css);\r\n\t};\r\n\r\n/***/ },\r\n/* 25 */\r\n/***/ function(module, exports, __nested_webpack_require_422582__) {\r\n\r\n\t'use strict';\r\n\r\n\texports.__esModule = true;\r\n\texports['default'] = {\r\n\t  mark: __nested_webpack_require_422582__(26),\r\n\t  parse: __nested_webpack_require_422582__(27),\r\n\t  stringify: __nested_webpack_require_422582__(6),\r\n\t  tokenizer: __nested_webpack_require_422582__(28)\r\n\t};\r\n\tmodule.exports = exports['default'];\r\n\r\n/***/ },\r\n/* 26 */\r\n/***/ function(module, exports, __nested_webpack_require_422927__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar TokenType = __nested_webpack_require_422927__(13);\r\n\r\n\tmodule.exports = (function () {\r\n\t  /**\r\n\t  * Mark whitespaces and comments\r\n\t  */\r\n\t  function markSC(tokens) {\r\n\t    var tokensLength = tokens.length;\r\n\t    var ws = -1; // Flag for whitespaces\r\n\t    var sc = -1; // Flag for whitespaces and comments\r\n\t    var t = undefined; // Current token\r\n\r\n\t    // For every token in the token list, mark spaces and line breaks\r\n\t    // as spaces (set both `ws` and `sc` flags). Mark multiline comments\r\n\t    // with `sc` flag.\r\n\t    // If there are several spaces or tabs or line breaks or multiline\r\n\t    // comments in a row, group them: take the last one's index number\r\n\t    // and save it to the first token in the group as a reference:\r\n\t    // e.g., `ws_last = 7` for a group of whitespaces or `sc_last = 9`\r\n\t    // for a group of whitespaces and comments.\r\n\t    for (var i = 0; i < tokensLength; i++) {\r\n\t      t = tokens[i];\r\n\t      switch (t.type) {\r\n\t        case TokenType.Space:\r\n\t        case TokenType.Tab:\r\n\t        case TokenType.Newline:\r\n\t          t.ws = true;\r\n\t          t.sc = true;\r\n\r\n\t          if (ws === -1) ws = i;\r\n\t          if (sc === -1) sc = i;\r\n\r\n\t          break;\r\n\t        case TokenType.CommentML:\r\n\t        case TokenType.CommentSL:\r\n\t          if (ws !== -1) {\r\n\t            tokens[ws].ws_last = i - 1;\r\n\t            ws = -1;\r\n\t          }\r\n\r\n\t          t.sc = true;\r\n\r\n\t          break;\r\n\t        default:\r\n\t          if (ws !== -1) {\r\n\t            tokens[ws].ws_last = i - 1;\r\n\t            ws = -1;\r\n\t          }\r\n\r\n\t          if (sc !== -1) {\r\n\t            tokens[sc].sc_last = i - 1;\r\n\t            sc = -1;\r\n\t          }\r\n\t      }\r\n\t    }\r\n\r\n\t    if (ws !== -1) tokens[ws].ws_last = i - 1;\r\n\t    if (sc !== -1) tokens[sc].sc_last = i - 1;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Pair brackets\r\n\t  */\r\n\t  function markBrackets(tokens) {\r\n\t    var tokensLength = tokens.length;\r\n\t    var ps = []; // Parentheses\r\n\t    var sbs = []; // Square brackets\r\n\t    var cbs = []; // Curly brackets\r\n\t    var t = undefined; // Current token\r\n\r\n\t    // For every token in the token list, if we meet an opening (left)\r\n\t    // bracket, push its index number to a corresponding array.\r\n\t    // If we then meet a closing (right) bracket, look at the corresponding\r\n\t    // array. If there are any elements (records about previously met\r\n\t    // left brackets), take a token of the last left bracket (take\r\n\t    // the last index number from the array and find a token with\r\n\t    // this index number) and save right bracket's index as a reference:\r\n\t    for (var i = 0; i < tokensLength; i++) {\r\n\t      t = tokens[i];\r\n\t      switch (t.type) {\r\n\t        case TokenType.LeftParenthesis:\r\n\t          ps.push(i);\r\n\t          break;\r\n\t        case TokenType.RightParenthesis:\r\n\t          if (ps.length) {\r\n\t            t.left = ps.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t        case TokenType.LeftSquareBracket:\r\n\t          sbs.push(i);\r\n\t          break;\r\n\t        case TokenType.RightSquareBracket:\r\n\t          if (sbs.length) {\r\n\t            t.left = sbs.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t        case TokenType.LeftCurlyBracket:\r\n\t          cbs.push(i);\r\n\t          break;\r\n\t        case TokenType.RightCurlyBracket:\r\n\t          if (cbs.length) {\r\n\t            t.left = cbs.pop();\r\n\t            tokens[t.left].right = i;\r\n\t          }\r\n\t          break;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  return function (tokens) {\r\n\t    markBrackets(tokens);\r\n\t    markSC(tokens);\r\n\t  };\r\n\t})();\r\n\r\n/***/ },\r\n/* 27 */\r\n/***/ function(module, exports, __nested_webpack_require_426590__) {\r\n\r\n\t'use strict';var Node=__nested_webpack_require_426590__(1);var NodeType=__nested_webpack_require_426590__(15);var TokenType=__nested_webpack_require_426590__(13);var tokens=undefined;var tokensLength=undefined;var pos=undefined;var contexts={'arguments':function(){return checkArguments(pos) && getArguments();},'atkeyword':function(){return checkAtkeyword(pos) && getAtkeyword();},'atrule':function(){return checkAtrule(pos) && getAtrule();},'block':function(){return checkBlock(pos) && getBlock();},'brackets':function(){return checkBrackets(pos) && getBrackets();},'class':function(){return checkClass(pos) && getClass();},'combinator':function(){return checkCombinator(pos) && getCombinator();},'commentML':function(){return checkCommentML(pos) && getCommentML();},'commentSL':function(){return checkCommentSL(pos) && getCommentSL();},'condition':function(){return checkCondition(pos) && getCondition();},'conditionalStatement':function(){return checkConditionalStatement(pos) && getConditionalStatement();},'declaration':function(){return checkDeclaration(pos) && getDeclaration();},'declDelim':function(){return checkDeclDelim(pos) && getDeclDelim();},'default':function(){return checkDefault(pos) && getDefault();},'delim':function(){return checkDelim(pos) && getDelim();},'dimension':function(){return checkDimension(pos) && getDimension();},'expression':function(){return checkExpression(pos) && getExpression();},'extend':function(){return checkExtend(pos) && getExtend();},'function':function(){return checkFunction(pos) && getFunction();},'global':function(){return checkGlobal(pos) && getGlobal();},'ident':function(){return checkIdent(pos) && getIdent();},'important':function(){return checkImportant(pos) && getImportant();},'include':function(){return checkInclude(pos) && getInclude();},'interpolation':function(){return checkInterpolation(pos) && getInterpolation();},'loop':function(){return checkLoop(pos) && getLoop();},'mixin':function(){return checkMixin(pos) && getMixin();},'namespace':function(){return checkNamespace(pos) && getNamespace();},'number':function(){return checkNumber(pos) && getNumber();},'operator':function(){return checkOperator(pos) && getOperator();},'optional':function(){return checkOptional(pos) && getOptional();},'parentheses':function(){return checkParentheses(pos) && getParentheses();},'parentselector':function(){return checkParentSelector(pos) && getParentSelector();},'percentage':function(){return checkPercentage(pos) && getPercentage();},'placeholder':function(){return checkPlaceholder(pos) && getPlaceholder();},'progid':function(){return checkProgid(pos) && getProgid();},'property':function(){return checkProperty(pos) && getProperty();},'propertyDelim':function(){return checkPropertyDelim(pos) && getPropertyDelim();},'pseudoc':function(){return checkPseudoc(pos) && getPseudoc();},'pseudoe':function(){return checkPseudoe(pos) && getPseudoe();},'ruleset':function(){return checkRuleset(pos) && getRuleset();},'s':function(){return checkS(pos) && getS();},'selector':function(){return checkSelector(pos) && getSelector();},'shash':function(){return checkShash(pos) && getShash();},'string':function(){return checkString(pos) && getString();},'stylesheet':function(){return checkStylesheet(pos) && getStylesheet();},'unary':function(){return checkUnary(pos) && getUnary();},'unicodeRange':function(){return checkUnicodeRange(pos) && getUnicodeRange();},'urange':function(){return checkUrange(pos) && getUrange();},'uri':function(){return checkUri(pos) && getUri();},'value':function(){return checkValue(pos) && getValue();},'variable':function(){return checkVariable(pos) && getVariable();},'variableslist':function(){return checkVariablesList(pos) && getVariablesList();},'vhash':function(){return checkVhash(pos) && getVhash();}}; /**\r\n\t * Stop parsing and display error\r\n\t * @param {Number=} i Token's index number\r\n\t */function throwError(i){var ln=i?tokens[i].ln:tokens[pos].ln;throw {line:ln,syntax:'scss'};} /**\r\n\t * @param {Object} exclude\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkExcluding(exclude,i){var start=i;while(i < tokensLength) {if(exclude[tokens[i++].type])break;}return i - start - 2;} /**\r\n\t * @param {Number} start\r\n\t * @param {Number} finish\r\n\t * @returns {String}\r\n\t */function joinValues(start,finish){var s='';for(var i=start;i < finish + 1;i++) {s += tokens[i].value;}return s;} /**\r\n\t * @param {Number} start\r\n\t * @param {Number} num\r\n\t * @returns {String}\r\n\t */function joinValues2(start,num){if(start + num - 1 >= tokensLength)return;var s='';for(var i=0;i < num;i++) {s += tokens[start + i].value;}return s;}function getLastPosition(content,line,column,colOffset){return typeof content === 'string'?getLastPositionForString(content,line,column,colOffset):getLastPositionForArray(content,line,column,colOffset);}function getLastPositionForString(content,line,column,colOffset){var position=[];if(!content){position = [line,column];if(colOffset)position[1] += colOffset - 1;return position;}var lastLinebreak=content.lastIndexOf('\\n');var endsWithLinebreak=lastLinebreak === content.length - 1;var splitContent=content.split('\\n');var linebreaksCount=splitContent.length - 1;var prevLinebreak=linebreaksCount === 0 || linebreaksCount === 1?-1:content.length - splitContent[linebreaksCount - 1].length - 2; // Line:\r\n\tvar offset=endsWithLinebreak?linebreaksCount - 1:linebreaksCount;position[0] = line + offset; // Column:\r\n\tif(endsWithLinebreak){offset = prevLinebreak !== -1?content.length - prevLinebreak:content.length - 1;}else {offset = linebreaksCount !== 0?content.length - lastLinebreak - column - 1:content.length - 1;}position[1] = column + offset;if(!colOffset)return position;if(endsWithLinebreak){position[0]++;position[1] = colOffset;}else {position[1] += colOffset;}return position;}function getLastPositionForArray(content,line,column,colOffset){var position;if(content.length === 0){position = [line,column];}else {var c=content[content.length - 1];if(c.hasOwnProperty('end')){position = [c.end.line,c.end.column];}else {position = getLastPosition(c.content,line,column);}}if(!colOffset)return position;if(tokens[pos - 1].type !== 'Newline'){position[1] += colOffset;}else {position[0]++;position[1] = 1;}return position;}function newNode(type,content,line,column,end){if(!end)end = getLastPosition(content,line,column);return new Node({type:type,content:content,start:{line:line,column:column},end:{line:end[0],column:end[1]},syntax:'scss'});} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkAny(i){return checkBrackets(i) || checkParentheses(i) || checkString(i) || checkVariablesList(i) || checkVariable(i) || checkPlaceholder(i) || checkPercentage(i) || checkDimension(i) || checkUnicodeRange(i) || checkNumber(i) || checkUri(i) || checkExpression(i) || checkFunction(i) || checkInterpolation(i) || checkIdent(i) || checkClass(i) || checkUnary(i);} /**\r\n\t * @returns {Array}\r\n\t */function getAny(){if(checkBrackets(pos))return getBrackets();else if(checkParentheses(pos))return getParentheses();else if(checkString(pos))return getString();else if(checkVariablesList(pos))return getVariablesList();else if(checkVariable(pos))return getVariable();else if(checkPlaceholder(pos))return getPlaceholder();else if(checkPercentage(pos))return getPercentage();else if(checkDimension(pos))return getDimension();else if(checkUnicodeRange(pos))return getUnicodeRange();else if(checkNumber(pos))return getNumber();else if(checkUri(pos))return getUri();else if(checkExpression(pos))return getExpression();else if(checkFunction(pos))return getFunction();else if(checkInterpolation(pos))return getInterpolation();else if(checkIdent(pos))return getIdent();else if(checkClass(pos))return getClass();else if(checkUnary(pos))return getUnary();} /**\r\n\t * Check if token is part of mixin's arguments.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of arguments\r\n\t */function checkArguments(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;i++;while(i < tokens[start].right) {if(l = checkArgument(i))i += l;else return 0;}return tokens[start].right - start + 1;} /**\r\n\t * Check if token is valid to be part of arguments list\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of argument\r\n\t */function checkArgument(i){return checkBrackets(i) || checkParentheses(i) || checkDeclaration(i) || checkFunction(i) || checkVariablesList(i) || checkVariable(i) || checkSC(i) || checkDelim(i) || checkDeclDelim(i) || checkString(i) || checkPercentage(i) || checkDimension(i) || checkNumber(i) || checkUri(i) || checkInterpolation(i) || checkIdent(i) || checkVhash(i) || checkOperator(i) || checkUnary(i) || checkImportant(i) || checkParentSelector(i);} /**\r\n\t * @returns {Array} Node that is part of arguments list\r\n\t */function getArgument(){if(checkBrackets(pos))return getBrackets();else if(checkParentheses(pos))return getParentheses();else if(checkDeclaration(pos))return getDeclaration();else if(checkFunction(pos))return getFunction();else if(checkVariablesList(pos))return getVariablesList();else if(checkVariable(pos))return getVariable();else if(checkSC(pos))return getSC();else if(checkDelim(pos))return getDelim();else if(checkDeclDelim(pos))return getDeclDelim();else if(checkString(pos))return getString();else if(checkPercentage(pos))return getPercentage();else if(checkDimension(pos))return getDimension();else if(checkNumber(pos))return getNumber();else if(checkUri(pos))return getUri();else if(checkInterpolation(pos))return getInterpolation();else if(checkIdent(pos))return getIdent();else if(checkVhash(pos))return getVhash();else if(checkOperator(pos))return getOperator();else if(checkUnary(pos))return getUnary();else if(checkImportant(pos))return getImportant();else if(checkParentSelector(pos))return getParentSelector();} /**\r\n\t * Check if token is part of an @-word (e.g. `@import`, `@include`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkAtkeyword(i){var l; // Check that token is `@`:\r\n\tif(i >= tokensLength || tokens[i++].type !== TokenType.CommercialAt)return 0;return (l = checkIdentOrInterpolation(i))?l + 1:0;} /**\r\n\t * Get node with @-word\r\n\t * @returns {Array} `['atkeyword', ['ident', x]]` where `x` is\r\n\t *      an identifier without\r\n\t *      `@` (e.g. `import`, `include`)\r\n\t */function getAtkeyword(){var startPos=pos;var x=undefined;pos++;x = getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.AtkeywordType,x,token.ln,token.col);} /**\r\n\t * Check if token is a part of an @-rule\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of @-rule\r\n\t */function checkAtrule(i){var l;if(i >= tokensLength)return 0; // If token already has a record of being part of an @-rule,\r\n\t// return the @-rule's length:\r\n\tif(tokens[i].atrule_l !== undefined)return tokens[i].atrule_l; // If token is part of an @-rule, save the rule's type to token.\r\n\t// @keyframes:\r\n\tif(l = checkKeyframesRule(i))tokens[i].atrule_type = 4; // @-rule with ruleset:\r\n\telse if(l = checkAtruler(i))tokens[i].atrule_type = 1; // Block @-rule:\r\n\telse if(l = checkAtruleb(i))tokens[i].atrule_type = 2; // Single-line @-rule:\r\n\telse if(l = checkAtrules(i))tokens[i].atrule_type = 3;else return 0; // If token is part of an @-rule, save the rule's length to token:\r\n\ttokens[i].atrule_l = l;return l;} /**\r\n\t * Get node with @-rule\r\n\t * @returns {Array}\r\n\t */function getAtrule(){switch(tokens[pos].atrule_type){case 1:return getAtruler(); // @-rule with ruleset\r\n\tcase 2:return getAtruleb(); // Block @-rule\r\n\tcase 3:return getAtrules(); // Single-line @-rule\r\n\tcase 4:return getKeyframesRule();}} /**\r\n\t * Check if token is part of a block @-rule\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the @-rule\r\n\t */function checkAtruleb(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a block @-rule\r\n\t * @returns {Array} `['atruleb', ['atkeyword', x], y, ['block', z]]`\r\n\t */function getAtruleb(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets()).concat([getBlock()]);var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an @-rule with ruleset\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the @-rule\r\n\t */function checkAtruler(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;if(i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket)i++;else return 0;if(l = checkAtrulers(i))i += l;if(i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket)i++;else return 0;return i - start;} /**\r\n\t * Get node with an @-rule with ruleset\r\n\t * @returns {Array} ['atruler', ['atkeyword', x], y, z]\r\n\t */function getAtruler(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets());x.push(getAtrulers());var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkAtrulers(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;while(l = checkRuleset(i) || checkAtrule(i) || checkSC(i)) {i += l;}if(i < tokensLength)tokens[i].atrulers_end = 1;return i - start;} /**\r\n\t * @returns {Array} `['atrulers', x]`\r\n\t */function getAtrulers(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;x = getSC();while(!tokens[pos].atrulers_end) {if(checkSC(pos))x = x.concat(getSC());else if(checkAtrule(pos))x.push(getAtrule());else if(checkRuleset(pos))x.push(getRuleset());}x = x.concat(getSC());var end=getLastPosition(x,line,column,1);pos++;return newNode(NodeType.BlockType,x,token.ln,token.col,end);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkAtrules(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;return i - start;} /**\r\n\t * @returns {Array} `['atrules', ['atkeyword', x], y]`\r\n\t */function getAtrules(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets());var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a block (e.g. `{...}`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the block\r\n\t */function checkBlock(i){return i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket?tokens[i].right - i + 1:0;} /**\r\n\t * Get node with a block\r\n\t * @returns {Array} `['block', x]`\r\n\t */function getBlock(){var startPos=pos;var end=tokens[pos].right;var x=[];var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;while(pos < end) {if(checkBlockdecl(pos))x = x.concat(getBlockdecl());else throwError();}var end_=getLastPosition(x,line,column,1);pos = end + 1;return newNode(NodeType.BlockType,x,token.ln,token.col,end_);} /**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the declaration\r\n\t */function checkBlockdecl(i){var l;if(i >= tokensLength)return 0;if(l = checkBlockdecl1(i))tokens[i].bd_type = 1;else if(l = checkBlockdecl2(i))tokens[i].bd_type = 2;else if(l = checkBlockdecl3(i))tokens[i].bd_type = 3;else if(l = checkBlockdecl4(i))tokens[i].bd_type = 4;else return 0;return l;} /**\r\n\t * @returns {Array}\r\n\t */function getBlockdecl(){switch(tokens[pos].bd_type){case 1:return getBlockdecl1();case 2:return getBlockdecl2();case 3:return getBlockdecl3();case 4:return getBlockdecl4();}} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkBlockdecl1(i){var start=i;var l=undefined;if(l = checkSC(i))i += l;if(l = checkConditionalStatement(i))tokens[i].bd_kind = 1;else if(l = checkInclude(i))tokens[i].bd_kind = 2;else if(l = checkExtend(i))tokens[i].bd_kind = 4;else if(l = checkLoop(i))tokens[i].bd_kind = 3;else if(l = checkAtrule(i))tokens[i].bd_kind = 6;else if(l = checkRuleset(i))tokens[i].bd_kind = 7;else if(l = checkDeclaration(i))tokens[i].bd_kind = 5;else return 0;i += l;if(i < tokensLength && (l = checkDeclDelim(i)))i += l;else return 0;if(l = checkSC(i))i += l;return i - start;} /**\r\n\t * @returns {Array}\r\n\t */function getBlockdecl1(){var sc=getSC();var x=undefined;switch(tokens[pos].bd_kind){case 1:x = getConditionalStatement();break;case 2:x = getInclude();break;case 3:x = getLoop();break;case 4:x = getExtend();break;case 5:x = getDeclaration();break;case 6:x = getAtrule();break;case 7:x = getRuleset();break;}return sc.concat([x]).concat([getDeclDelim()]).concat(getSC());} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkBlockdecl2(i){var start=i;var l=undefined;if(l = checkSC(i))i += l;if(l = checkConditionalStatement(i))tokens[i].bd_kind = 1;else if(l = checkInclude(i))tokens[i].bd_kind = 2;else if(l = checkExtend(i))tokens[i].bd_kind = 4;else if(l = checkMixin(i))tokens[i].bd_kind = 8;else if(l = checkLoop(i))tokens[i].bd_kind = 3;else if(l = checkAtrule(i))tokens[i].bd_kind = 6;else if(l = checkRuleset(i))tokens[i].bd_kind = 7;else if(l = checkDeclaration(i))tokens[i].bd_kind = 5;else return 0;i += l;if(l = checkSC(i))i += l;return i - start;} /**\r\n\t * @returns {Array}\r\n\t */function getBlockdecl2(){var sc=getSC();var x=undefined;switch(tokens[pos].bd_kind){case 1:x = getConditionalStatement();break;case 2:x = getInclude();break;case 3:x = getLoop();break;case 4:x = getExtend();break;case 5:x = getDeclaration();break;case 6:x = getAtrule();break;case 7:x = getRuleset();break;case 8:x = getMixin();break;}return sc.concat([x]).concat(getSC());} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkBlockdecl3(i){var start=i;var l=undefined;if(l = checkSC(i))i += l;if(l = checkDeclDelim(i))i += l;else return 0;if(l = checkSC(i))i += l;return i - start;} /**\r\n\t * @returns {Array} `[s0, ['declDelim'], s1]` where `s0` and `s1` are\r\n\t *      are optional whitespaces.\r\n\t */function getBlockdecl3(){return getSC().concat([getDeclDelim()]).concat(getSC());} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkBlockdecl4(i){return checkSC(i);} /**\r\n\t * @returns {Array}\r\n\t */function getBlockdecl4(){return getSC();} /**\r\n\t * Check if token is part of text inside square brackets, e.g. `[1]`\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkBrackets(i){if(i >= tokensLength || tokens[i].type !== TokenType.LeftSquareBracket)return 0;return tokens[i].right - i + 1;} /**\r\n\t * Get node with text inside parentheses or square brackets (e.g. `(1)`)\r\n\t * @return {Node}\r\n\t */function getBrackets(){var startPos=pos;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;var tsets=getTsets();var end=getLastPosition(tsets,line,column,1);pos++;return newNode(NodeType.BracketsType,tsets,token.ln,token.col,end);} /**\r\n\t * Check if token is part of a class selector (e.g. `.abc`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the class selector\r\n\t */function checkClass(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(tokens[i].class_l)return tokens[i].class_l;if(tokens[i++].type !== TokenType.FullStop)return 0; // Check for `-` at beginning.\r\n\tif(tokens[i].type === TokenType.HyphenMinus)i += 1;if(l = checkIdentOrInterpolation(i))i += l;else return 0;while(i < tokensLength) {if(l = checkIdentOrInterpolation(i) || checkNumber(i))i += l;else if(tokens[i].type === TokenType.HyphenMinus)i += 1;else break;}tokens[start].classEnd = i;return i - start;} /**\r\n\t * Get node with a class selector\r\n\t * @returns {Array} `['class', ['ident', x]]` where x is a class's\r\n\t *      identifier (without `.`, e.g. `abc`).\r\n\t */function getClass(){var startPos=pos;var type=NodeType.ClassType;var token=tokens[startPos];var line=token.ln;var column=token.col;var content=[];var end=token.classEnd; // Skip `.`\r\n\tpos++;while(pos < end) {if(checkIdentOrInterpolation(pos)){content = content.concat(getIdentOrInterpolation());}else if(checkNumber(pos)){content = content.concat(getNumber());}else if(tokens[pos].type === TokenType.HyphenMinus){content.push(newNode(NodeType.IdentType,tokens[pos].value,tokens[pos].ln,tokens[pos].col));pos++;}else break;}return newNode(type,content,line,column);}function checkCombinator(i){if(i >= tokensLength)return 0;var l=undefined;if(l = checkCombinator1(i))tokens[i].combinatorType = 1;else if(l = checkCombinator2(i))tokens[i].combinatorType = 2;else if(l = checkCombinator3(i))tokens[i].combinatorType = 3;return l;}function getCombinator(){var type=tokens[pos].combinatorType;if(type === 1)return getCombinator1();if(type === 2)return getCombinator2();if(type === 3)return getCombinator3();} /**\r\n\t * (1) `||`\r\n\t */function checkCombinator1(i){if(tokens[i].type === TokenType.VerticalLine && tokens[i + 1].type === TokenType.VerticalLine)return 2;else return 0;}function getCombinator1(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='||';pos += 2;return newNode(type,content,line,column);} /**\r\n\t * (1) `>`\r\n\t * (2) `+`\r\n\t * (3) `~`\r\n\t */function checkCombinator2(i){var type=tokens[i].type;if(type === TokenType.PlusSign || type === TokenType.GreaterThanSign || type === TokenType.Tilde)return 1;else return 0;}function getCombinator2(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=tokens[pos++].value;return newNode(type,content,line,column);} /**\r\n\t * (1) `/panda/`\r\n\t */function checkCombinator3(i){var start=i;if(tokens[i].type === TokenType.Solidus)i++;else return 0;var l=undefined;if(l = checkIdent(i))i += l;else return 0;if(tokens[i].type === TokenType.Solidus)i++;else return 0;return i - start;}function getCombinator3(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `/`.\r\n\tpos++;var ident=getIdent(); // Skip `/`.\r\n\tpos++;var content='/' + ident.content + '/';return newNode(type,content,line,column);} /**\r\n\t * Check if token is a multiline comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a multiline comment, otherwise `0`\r\n\t */function checkCommentML(i){return i < tokensLength && tokens[i].type === TokenType.CommentML?1:0;} /**\r\n\t * Get node with a multiline comment\r\n\t * @returns {Array} `['commentML', x]` where `x`\r\n\t *      is the comment's text (without `/*` and `* /`).\r\n\t */function getCommentML(){var startPos=pos;var s=tokens[pos].value.substring(2);var l=s.length;var token=tokens[startPos];var line=token.ln;var column=token.col;if(s.charAt(l - 2) === '*' && s.charAt(l - 1) === '/')s = s.substring(0,l - 2);var end=getLastPosition(s,line,column,2);if(end[0] === line)end[1] += 2;pos++;return newNode(NodeType.CommentMLType,s,token.ln,token.col,end);} /**\r\n\t * Check if token is part of a single-line comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a single-line comment, otherwise `0`\r\n\t */function checkCommentSL(i){return i < tokensLength && tokens[i].type === TokenType.CommentSL?1:0;} /**\r\n\t * Get node with a single-line comment.\r\n\t * @returns {Array} `['commentSL', x]` where `x` is comment's message\r\n\t *      (without `//`)\r\n\t */function getCommentSL(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;x = tokens[pos++].value.substring(2);var end=getLastPosition(x,line,column + 2);return newNode(NodeType.CommentSLType,x,token.ln,token.col,end);} /**\r\n\t * Check if token is part of a condition\r\n\t * (e.g. `@if ...`, `@else if ...` or `@else ...`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the condition\r\n\t */function checkCondition(i){var start=i;var l=undefined;var _i=undefined;var s=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(['if','else'].indexOf(tokens[start + 1].value) < 0)return 0;while(i < tokensLength) {if(l = checkBlock(i))break;s = checkSC(i);_i = i + s;if(l = _checkCondition(_i))i += l + s;else break;}return i - start;}function _checkCondition(i){return checkVariable(i) || checkNumber(i) || checkInterpolation(i) || checkIdent(i) || checkOperator(i) || checkCombinator(i) || checkString(i);} /**\r\n\t * Get node with a condition.\r\n\t * @returns {Array} `['condition', x]`\r\n\t */function getCondition(){var startPos=pos;var x=[];var s;var _pos;x.push(getAtkeyword());while(pos < tokensLength) {if(checkBlock(pos))break;s = checkSC(pos);_pos = pos + s;if(!_checkCondition(_pos))break;if(s)x = x.concat(getSC());x.push(_getCondition());}var token=tokens[startPos];return newNode(NodeType.ConditionType,x,token.ln,token.col);}function _getCondition(){if(checkVariable(pos))return getVariable();if(checkNumber(pos))return getNumber();if(checkInterpolation(pos))return getInterpolation();if(checkIdent(pos))return getIdent();if(checkOperator(pos))return getOperator();if(checkCombinator(pos))return getCombinator();if(checkString(pos))return getString();} /**\r\n\t * Check if token is part of a conditional statement\r\n\t * (e.g. `@if ... {} @else if ... {} @else ... {}`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the condition\r\n\t */function checkConditionalStatement(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkCondition(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a condition.\r\n\t * @returns {Array} `['condition', x]`\r\n\t */function getConditionalStatement(){var startPos=pos;var x=[];x.push(getCondition());x = x.concat(getSC());x.push(getBlock());var token=tokens[startPos];return newNode(NodeType.ConditionalStatementType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a declaration (property-value pair)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the declaration\r\n\t */function checkDeclaration(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkProperty(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkPropertyDelim(i))i++;else return 0;if(l = checkSC(i))i += l;if(l = checkValue(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a declaration\r\n\t * @returns {Array} `['declaration', ['property', x], ['propertyDelim'],\r\n\t *       ['value', y]]`\r\n\t */function getDeclaration(){var startPos=pos;var x=[];x.push(getProperty());x = x.concat(getSC());x.push(getPropertyDelim());x = x.concat(getSC());x.push(getValue());var token=tokens[startPos];return newNode(NodeType.DeclarationType,x,token.ln,token.col);} /**\r\n\t * Check if token is a semicolon\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a semicolon, otherwise `0`\r\n\t */function checkDeclDelim(i){return i < tokensLength && tokens[i].type === TokenType.Semicolon?1:0;} /**\r\n\t * Get node with a semicolon\r\n\t * @returns {Array} `['declDelim']`\r\n\t */function getDeclDelim(){var startPos=pos++;var token=tokens[startPos];return newNode(NodeType.DeclDelimType,';',token.ln,token.col);} /**\r\n\t * Check if token if part of `!default` word.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the `!default` word\r\n\t */function checkDefault(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'default'){tokens[start].defaultEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with a `!default` word\r\n\t * @returns {Array} `['default', sc]` where `sc` is optional whitespace\r\n\t */function getDefault(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.defaultEnd);pos = token.defaultEnd + 1;return newNode(NodeType.DefaultType,content,line,column);} /**\r\n\t * Check if token is a comma\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a comma, otherwise `0`\r\n\t */function checkDelim(i){return i < tokensLength && tokens[i].type === TokenType.Comma?1:0;} /**\r\n\t * Get node with a comma\r\n\t * @returns {Array} `['delim']`\r\n\t */function getDelim(){var startPos=pos;pos++;var token=tokens[startPos];return newNode(NodeType.DelimType,',',token.ln,token.col);} /**\r\n\t * Check if token is part of a number with dimension unit (e.g. `10px`)\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */function checkDimension(i){var ln=checkNumber(i);var li=undefined;if(i >= tokensLength || !ln || i + ln >= tokensLength)return 0;return (li = checkUnit(i + ln))?ln + li:0;} /**\r\n\t * Get node of a number with dimension unit\r\n\t * @return {Node}\r\n\t */function getDimension(){var type=NodeType.DimensionType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[getNumber(),getUnit()];return newNode(type,content,line,column);} /**\r\n\t * Check if token is unit\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */function checkUnit(i){var units=['em','ex','ch','rem','vh','vw','vmin','vmax','px','mm','q','cm','in','pt','pc','deg','grad','rad','turn','s','ms','Hz','kHz','dpi','dpcm','dppx'];return units.indexOf(tokens[i].value) !== -1?1:0;} /**\r\n\t * Get unit node of type ident\r\n\t * @return {Node} An ident node containing the unit value\r\n\t */function getUnit(){var type=NodeType.IdentType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=token.value;pos++;return newNode(type,content,line,column);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkExpression(i){var start=i;if(i >= tokensLength || tokens[i++].value !== 'expression' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - start + 1;} /**\r\n\t * @returns {Array}\r\n\t */function getExpression(){var startPos=pos;var e;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;e = joinValues(pos + 1,tokens[pos].right - 1);var end=getLastPosition(e,line,column,1);if(end[0] === line)end[1] += 11;pos = tokens[pos].right + 1;return newNode(NodeType.ExpressionType,e,token.ln,token.col,end);}function checkExtend(i){var l=0;if(l = checkExtend1(i))tokens[i].extend_child = 1;else if(l = checkExtend2(i))tokens[i].extend_child = 2;return l;}function getExtend(){var type=tokens[pos].extend_child;if(type === 1)return getExtend1();else if(type === 2)return getExtend2();} /**\r\n\t * Checks if token is part of an extend with `!optional` flag.\r\n\t * @param {Number} i\r\n\t */function checkExtend1(i){var start=i;var l;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'extend')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkOptional(i))i += l;else return 0;return i - start;}function getExtend1(){var startPos=pos;var x=[].concat([getAtkeyword()],getSC(),getSelectorsGroup(),getSC(),[getOptional()]);var token=tokens[startPos];return newNode(NodeType.ExtendType,x,token.ln,token.col);} /**\r\n\t * Checks if token is part of an extend without `!optional` flag.\r\n\t * @param {Number} i\r\n\t */function checkExtend2(i){var start=i;var l;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'extend')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;return i - start;}function getExtend2(){var startPos=pos;var x=[].concat([getAtkeyword()],getSC(),getSelectorsGroup());var token=tokens[startPos];return newNode(NodeType.ExtendType,x,token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkFunction(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i < tokensLength && tokens[i].type === TokenType.LeftParenthesis?tokens[i].right - start + 1:0;} /**\r\n\t * @returns {Array}\r\n\t */function getFunction(){var startPos=pos;var x=getIdentOrInterpolation();var body=undefined;body = getArguments();x.push(body);var token=tokens[startPos];return newNode(NodeType.FunctionType,x,token.ln,token.col);} /**\r\n\t * @returns {Array}\r\n\t */function getArguments(){var startPos=pos;var x=[];var body=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;while(pos < tokensLength && tokens[pos].type !== TokenType.RightParenthesis) {if(checkDeclaration(pos))x.push(getDeclaration());else if(checkArgument(pos)){body = getArgument();if(typeof body.content === 'string')x.push(body);else x = x.concat(body);}else if(checkClass(pos))x.push(getClass());else throwError();}var end=getLastPosition(x,line,column,1);pos++;return newNode(NodeType.ArgumentsType,x,token.ln,token.col,end);} /**\r\n\t * Check if token is part of an identifier\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the identifier\r\n\t */function checkIdent(i){var start=i;if(i >= tokensLength)return 0; // Check if token is part of a negative number\r\n\tif(tokens[i].type === TokenType.HyphenMinus && tokens[i + 1].type === TokenType.DecimalNumber)return 0;if(tokens[i].type === TokenType.HyphenMinus)i++;if(tokens[i].type === TokenType.LowLine || tokens[i].type === TokenType.Identifier)i++;else return 0;for(;i < tokensLength;i++) {if(tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier && tokens[i].type !== TokenType.DecimalNumber)break;}tokens[start].ident_last = i - 1;return i - start;} /**\r\n\t * Get node with an identifier\r\n\t * @returns {Array} `['ident', x]` where `x` is identifier's name\r\n\t */function getIdent(){var startPos=pos;var x=joinValues(pos,tokens[pos].ident_last);pos = tokens[pos].ident_last + 1;var token=tokens[startPos];return newNode(NodeType.IdentType,x,token.ln,token.col);} /**\r\n\t * @param {number} i Token's index number\r\n\t * @returns {number} Length of the identifier\r\n\t */function checkPartialIdent(i){var start=i;if(i >= tokensLength)return 0;for(;i < tokensLength;i++) {if(tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier && tokens[i].type !== TokenType.DecimalNumber)break;}tokens[start].ident_last = i - 1;return i - start;}function checkIdentOrInterpolation(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkInterpolation(i) || checkIdent(i))i += l;else break;}return i - start;}function getIdentOrInterpolation(){var x=[];while(pos < tokensLength) {if(checkInterpolation(pos))x.push(getInterpolation());else if(checkIdent(pos))x.push(getIdent());else break;}return x;} /**\r\n\t * Check if token is part of `!important` word\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkImportant(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'important'){tokens[start].importantEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with `!important` word\r\n\t * @returns {Array} `['important', sc]` where `sc` is optional whitespace\r\n\t */function getImportant(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.importantEnd);pos = token.importantEnd + 1;return newNode(NodeType.ImportantType,content,line,column);} /**\r\n\t * Check if token is part of an included mixin (`@include` or `@extend`\r\n\t *      directive).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the included mixin\r\n\t */function checkInclude(i){var l;if(i >= tokensLength)return 0;if(l = checkInclude1(i))tokens[i].include_type = 1;else if(l = checkInclude2(i))tokens[i].include_type = 2;else if(l = checkInclude3(i))tokens[i].include_type = 3;else if(l = checkInclude4(i))tokens[i].include_type = 4;else if(l = checkInclude5(i))tokens[i].include_type = 5;return l;} /**\r\n\t * Check if token is part of `!global` word\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkGlobal(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'global'){tokens[start].globalEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with `!global` word\r\n\t */function getGlobal(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.globalEnd);pos = token.globalEnd + 1;return newNode(NodeType.GlobalType,content,line,column);} /**\r\n\t * Get node with included mixin\r\n\t * @returns {Array} `['include', x]`\r\n\t */function getInclude(){switch(tokens[pos].include_type){case 1:return getInclude1();case 2:return getInclude2();case 3:return getInclude3();case 4:return getInclude4();case 5:return getInclude5();}} /**\r\n\t * Get node with included mixin with keyfames selector like\r\n\t * `@include nani(foo) { 0% {}}`\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the include\r\n\t */function checkInclude1(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkKeyframesBlocks(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with included mixin with keyfames selector like\r\n\t * `@include nani(foo) { 0% {}}`\r\n\t * @returns {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,\r\n\t *      ['arguments', z], sc, ['block', q], sc` where `x` is `include` or\r\n\t *      `extend`, `y` is mixin's identifier (selector), `z` are arguments\r\n\t *      passed to the mixin, `q` is block passed to the mixin containing a\r\n\t *      ruleset > selector > keyframesSelector, and `sc` are optional\r\n\t *      whitespaces\r\n\t */function getInclude1(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments(),getSC(),getKeyframesBlocks());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin like `@include nani(foo) {...}`\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the include\r\n\t */function checkInclude2(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with included mixin like `@include nani(foo) {...}`\r\n\t * @returns {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,\r\n\t *      ['arguments', z], sc, ['block', q], sc` where `x` is `include` or\r\n\t *      `extend`, `y` is mixin's identifier (selector), `z` are arguments\r\n\t *      passed to the mixin, `q` is block passed to the mixin and `sc`\r\n\t *      are optional whitespaces\r\n\t */function getInclude2(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin like `@include nani(foo)`\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the include\r\n\t */function checkInclude3(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with included mixin like `@include nani(foo)`\r\n\t * @returns {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,\r\n\t *      ['arguments', z], sc]` where `x` is `include` or `extend`, `y` is\r\n\t *      mixin's identifier (selector), `z` are arguments passed to the\r\n\t *      mixin and `sc` are optional whitespaces\r\n\t */function getInclude3(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an included mixin with a content block passed\r\n\t *      as an argument (e.g. `@include nani {...}`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the mixin\r\n\t */function checkInclude4(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with an included mixin with a content block passed\r\n\t *      as an argument (e.g. `@include nani {...}`)\r\n\t * @returns {Array} `['include', x]`\r\n\t */function getInclude4(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkInclude5(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**\r\n\t * @returns {Array} `['include', x]`\r\n\t */function getInclude5(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of an interpolated variable (e.g. `#{$nani}`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkInterpolation(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.NumberSign || !tokens[i + 1] || tokens[i + 1].type !== TokenType.LeftCurlyBracket)return 0;i += 2;while(tokens[i].type !== TokenType.RightCurlyBracket) {if(l = checkArgument(i))i += l;else return 0;}return tokens[i].type === TokenType.RightCurlyBracket?i - start + 1:0;} /**\r\n\t * Get node with an interpolated variable\r\n\t * @returns {Array} `['interpolation', x]`\r\n\t */function getInterpolation(){var startPos=pos;var x=[];var token=tokens[startPos];var line=token.ln;var column=token.col; // Skip `#{`:\r\n\tpos += 2;while(pos < tokensLength && tokens[pos].type !== TokenType.RightCurlyBracket) {var body=getArgument();if(typeof body.content === 'string')x.push(body);else x = x.concat(body);}var end=getLastPosition(x,line,column,1); // Skip `}`:\r\n\tpos++;return newNode(NodeType.InterpolationType,x,token.ln,token.col,end);} /**\r\n\t * Check a single keyframe block - `5% {}`\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */function checkKeyframesBlock(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkKeyframesSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get a single keyframe block - `5% {}`\r\n\t * @returns {Node}\r\n\t */function getKeyframesBlock(){var type=NodeType.RulesetType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[].concat(getKeyframesSelectorsGroup(),getSC(),[getBlock()]);return newNode(type,content,line,column);} /**\r\n\t * Check all keyframe blocks - `5% {} 100% {}`\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */function checkKeyframesBlocks(i){var start=i;var l=undefined;if(i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket)i++;else return 0;if(l = checkSC(i))i += l;if(l = checkKeyframesBlock(i))i += l;else return 0;while(tokens[i].type !== TokenType.RightCurlyBracket) {if(l = checkSC(i))i += l;else if(l = checkKeyframesBlock(i))i += l;else break;}if(i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket)i++;else return 0;return i - start;} /**\r\n\t * Get all keyframe blocks - `5% {} 100% {}`\r\n\t * @returns {Node}\r\n\t */function getKeyframesBlocks(){var type=NodeType.BlockType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];var keyframesBlocksEnd=token.right; // Skip `{`.\r\n\tpos++;while(pos < keyframesBlocksEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkKeyframesBlock(pos))content.push(getKeyframesBlock());else if(checkAtrule(pos))content.push(getAtrule()); // @content\r\n\telse break;}var end=getLastPosition(content,line,column,1); // Skip `}`.\r\n\tpos++;return newNode(type,content,line,column,end);} /**\r\n\t * Check if token is part of a @keyframes rule.\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number} Length of the @keyframes rule\r\n\t */function checkKeyframesRule(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;var atruleName=joinValues2(i - l,l);if(atruleName.indexOf('keyframes') === -1)return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkKeyframesBlocks(i))i += l;else return 0;return i - start;} /**\r\n\t * @return {Node}\r\n\t */function getKeyframesRule(){var type=NodeType.AtruleType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[].concat([getAtkeyword()],getSC(),getIdentOrInterpolation(),getSC(),[getKeyframesBlocks()]);return newNode(type,content,line,column);} /**\r\n\t * Check a single keyframe selector - `5%`, `from` etc\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */function checkKeyframesSelector(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkIdent(i)){ // Valid selectors are only `from` and `to`.\r\n\tvar selector=joinValues2(i,l);if(selector !== 'from' && selector !== 'to')return 0;i += l;tokens[start].keyframesSelectorType = 1;}else if(l = checkPercentage(i)){i += l;tokens[start].keyframesSelectorType = 2;}else if(l = checkInterpolation(i)){i += l;tokens[start].keyframesSelectorType = 3;}else {return 0;}return i - start;} /**\r\n\t * Get a single keyframe selector\r\n\t * @returns {Node}\r\n\t */function getKeyframesSelector(){var keyframesSelectorType=NodeType.KeyframesSelectorType;var selectorType=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(token.keyframesSelectorType === 1){content.push(getIdent());}else if(token.keyframesSelectorType === 2){content.push(getPercentage());}else if(token.keyframesSelectorType === 3){content.push(getInterpolation());}var keyframesSelector=newNode(keyframesSelectorType,content,line,column);return newNode(selectorType,[keyframesSelector],line,column);} /**\r\n\t * Check the keyframe's selector groups\r\n\t * @param {Number} i\r\n\t * @returns {Number}\r\n\t */function checkKeyframesSelectorsGroup(i){var start=i;var l=undefined;if(l = checkKeyframesSelector(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);var c=checkDelim(i + sb);if(!c)break;var sa=checkSC(i + sb + c);if(l = checkKeyframesSelector(i + sb + c + sa))i += sb + c + sa + l;else break;}tokens[start].selectorsGroupEnd = i;return i - start;} /**\r\n\t * Get the keyframe's selector groups\r\n\t * @returns {Array} An array of keyframe selectors\r\n\t */function getKeyframesSelectorsGroup(){var selectorsGroup=[];var selectorsGroupEnd=tokens[pos].selectorsGroupEnd;selectorsGroup.push(getKeyframesSelector());while(pos < selectorsGroupEnd) {selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getDelim());selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getKeyframesSelector());}return selectorsGroup;} /**\r\n\t * Check if token is part of a loop.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the loop\r\n\t */function checkLoop(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(['for','each','while'].indexOf(tokens[start + 1].value) < 0)return 0;while(i < tokensLength) {if(l = checkBlock(i)){i += l;break;}else if(l = checkVariable(i) || checkNumber(i) || checkInterpolation(i) || checkIdent(i) || checkSC(i) || checkOperator(i) || checkCombinator(i) || checkString(i))i += l;else return 0;}return i - start;} /**\r\n\t * Get node with a loop.\r\n\t * @returns {Array} `['loop', x]`\r\n\t */function getLoop(){var startPos=pos;var x=[];x.push(getAtkeyword());while(pos < tokensLength) {if(checkBlock(pos)){x.push(getBlock());break;}else if(checkVariable(pos))x.push(getVariable());else if(checkNumber(pos))x.push(getNumber());else if(checkInterpolation(pos))x.push(getInterpolation());else if(checkIdent(pos))x.push(getIdent());else if(checkOperator(pos))x.push(getOperator());else if(checkCombinator(pos))x.push(getCombinator());else if(checkSC(pos))x = x.concat(getSC());else if(checkString(pos))x.push(getString());}var token=tokens[startPos];return newNode(NodeType.LoopType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a mixin\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the mixin\r\n\t */function checkMixin(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if((l = checkAtkeyword(i)) && tokens[i + 1].value === 'mixin')i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a mixin\r\n\t * @returns {Array} `['mixin', x]`\r\n\t */function getMixin(){var startPos=pos;var x=[getAtkeyword()];x = x.concat(getSC());if(checkIdentOrInterpolation(pos))x = x.concat(getIdentOrInterpolation());x = x.concat(getSC());if(checkArguments(pos))x.push(getArguments());x = x.concat(getSC());if(checkBlock(pos))x.push(getBlock());var token=tokens[startPos];return newNode(NodeType.MixinType,x,token.ln,token.col);} /**\r\n\t * Check if token is a namespace sign (`|`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is `|`, `0` if not\r\n\t */function checkNamespace(i){return i < tokensLength && tokens[i].type === TokenType.VerticalLine?1:0;} /**\r\n\t * Get node with a namespace sign\r\n\t * @returns {Array} `['namespace']`\r\n\t */function getNamespace(){var startPos=pos;pos++;var token=tokens[startPos];return newNode(NodeType.NamespaceType,'|',token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkNmName2(i){if(tokens[i].type === TokenType.Identifier)return 1;else if(tokens[i].type !== TokenType.DecimalNumber)return 0;i++;return i < tokensLength && tokens[i].type === TokenType.Identifier?2:1;} /**\r\n\t * @returns {String}\r\n\t */function getNmName2(){var s=tokens[pos].value;if(tokens[pos++].type === TokenType.DecimalNumber && pos < tokensLength && tokens[pos].type === TokenType.Identifier)s += tokens[pos++].value;return s;} /**\r\n\t * Check if token is part of a number\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of number\r\n\t */function checkNumber(i){if(i >= tokensLength)return 0;if(tokens[i].number_l)return tokens[i].number_l; // `10`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && (!tokens[i + 1] || tokens[i + 1] && tokens[i + 1].type !== TokenType.FullStop)){tokens[i].number_l = 1;return 1;} // `10.`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && (!tokens[i + 2] || tokens[i + 2].type !== TokenType.DecimalNumber)){tokens[i].number_l = 2;return 2;} // `.10`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.FullStop && tokens[i + 1].type === TokenType.DecimalNumber){tokens[i].number_l = 2;return 2;} // `10.10`:\r\n\tif(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && tokens[i + 2] && tokens[i + 2].type === TokenType.DecimalNumber){tokens[i].number_l = 3;return 3;}return 0;} /**\r\n\t * Get node with number\r\n\t * @returns {Array} `['number', x]` where `x` is a number converted\r\n\t *      to string.\r\n\t */function getNumber(){var s='';var startPos=pos;var l=tokens[pos].number_l;for(var j=0;j < l;j++) {s += tokens[pos + j].value;}pos += l;var token=tokens[startPos];return newNode(NodeType.NumberType,s,token.ln,token.col);} /**\r\n\t * Check if token is an operator (`/`, `%`, `,`, `:` or `=`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is an operator, otherwise `0`\r\n\t */function checkOperator(i){if(i >= tokensLength)return 0;switch(tokens[i].type){case TokenType.Solidus:case TokenType.PercentSign:case TokenType.Comma:case TokenType.Colon:case TokenType.EqualsSign:case TokenType.EqualitySign:case TokenType.InequalitySign:case TokenType.LessThanSign:case TokenType.GreaterThanSign:case TokenType.Asterisk:return 1;}return 0;} /**\r\n\t * Get node with an operator\r\n\t * @returns {Array} `['operator', x]` where `x` is an operator converted\r\n\t *      to string.\r\n\t */function getOperator(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.OperatorType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of `!optional` word\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkOptional(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'optional'){tokens[start].optionalEnd = i;return i - start + 1;}else {return 0;}} /**\r\n\t * Get node with `!optional` word\r\n\t */function getOptional(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.optionalEnd);pos = token.optionalEnd + 1;return newNode(NodeType.OptionalType,content,line,column);} /**\r\n\t * Check if token is part of text inside parentheses, e.g. `(1)`\r\n\t * @param {Number} i Token's index number\r\n\t * @return {Number}\r\n\t */function checkParentheses(i){if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - i + 1;} /**\r\n\t * Get node with text inside parentheses, e.g. `(1)`\r\n\t * @return {Node}\r\n\t */function getParentheses(){var type=NodeType.ParenthesesType;var token=tokens[pos];var line=token.ln;var column=token.col;pos++;var tsets=getTsets();var end=getLastPosition(tsets,line,column,1);pos++;return newNode(type,tsets,line,column,end);} /**\r\n\t * Check if token is a parent selector, e.g. `&`\r\n\t * @param {number} i Token's index number\r\n\t * @return {number}\r\n\t */function checkParentSelector(i){return i < tokensLength && tokens[i].type === TokenType.Ampersand?1:0;} /**\r\n\t * Get node with a parent selector\r\n\t * @return {Node}\r\n\t */function getParentSelector(){var startPos=pos;var token=tokens[startPos];pos++;return newNode(NodeType.ParentSelectorType,'&',token.ln,token.col);} /**\r\n\t * Check if token is a parent selector extension, e.g. `&--foo-bar`\r\n\t * @param {number} i Token's index number\r\n\t * @returns {number} Length of the parent selector extension\r\n\t */function checkParentSelectorExtension(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;while(i < tokensLength) {if(l = checkNumber(i) || checkPartialIdent(i) || checkIdentOrInterpolation(i))i += l;else break;}return i - start;} /**\r\n\t * Get parent selector extension node\r\n\t * @return {Node}\r\n\t */function getParentSelectorExtension(){var type=NodeType.ParentSelectorExtensionType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];while(pos < tokensLength) {if(checkNumber(pos)){content.push(getNumber());}else if(checkPartialIdent(pos)){content.push(getIdent());}else if(checkIdentOrInterpolation(pos)){content = content.concat(getIdentOrInterpolation());}else break;}return newNode(type,content,line,column);} /**\r\n\t * Check if token is a parent selector with an extension or not\r\n\t * @param {number} i Token's index number\r\n\t * @return {number} Length of the parent selector and extension if applicable\r\n\t */function checkParentSelectorWithExtension(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkParentSelector(i))i += l;else return 0;if(l = checkParentSelectorExtension(i))i += l;return i - start;} /**\r\n\t * Get parent selector node and extension node if applicable\r\n\t * @return {Array}\r\n\t */function getParentSelectorWithExtension(){var content=[getParentSelector()];if(checkParentSelectorExtension(pos))content.push(getParentSelectorExtension());return content;} /**\r\n\t * Check if token is part of a number or an interpolation with a percent sign\r\n\t * (e.g. `10%`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkPercentage(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkNumberOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.PercentSign)return 0;return i - start + 1;} /**\r\n\t * Get a percentage node that contains either a number or an interpolation\r\n\t * @returns {Object} The percentage node\r\n\t */function getPercentage(){var startPos=pos;var token=tokens[startPos];var line=token.ln;var column=token.col;var content=getNumberOrInterpolation();var end=getLastPosition(content,line,column,1); // Skip %\r\n\tpos++;return newNode(NodeType.PercentageType,content,token.ln,token.col,end);} /**\r\n\t * Check if token is a number or an interpolation\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkNumberOrInterpolation(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkInterpolation(i) || checkNumber(i))i += l;else break;}return i - start;} /**\r\n\t * Get a number and/or interpolation node\r\n\t * @returns {Array} An array containing a single or multiple nodes\r\n\t */function getNumberOrInterpolation(){var content=[];while(pos < tokensLength) {if(checkInterpolation(pos))content.push(getInterpolation());else if(checkNumber(pos))content.push(getNumber());else break;}return content;} /**\r\n\t * Check if token is part of a placeholder selector (e.g. `%abc`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the selector\r\n\t */function checkPlaceholder(i){var l;if(i >= tokensLength)return 0;if(tokens[i].placeholder_l)return tokens[i].placeholder_l;if(tokens[i].type !== TokenType.PercentSign)return 0;if(l = checkIdentOrInterpolation(i + 1)){tokens[i].placeholder_l = l + 1;return l + 1;}else return 0;} /**\r\n\t * Get node with a placeholder selector\r\n\t * @returns {Array} `['placeholder', ['ident', x]]` where x is a placeholder's\r\n\t *      identifier (without `%`, e.g. `abc`).\r\n\t */function getPlaceholder(){var startPos=pos;pos++;var x=getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.PlaceholderType,x,token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkProgid(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(joinValues2(i,6) === 'progid:DXImageTransform.Microsoft.')i += 6;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(tokens[i].type === TokenType.LeftParenthesis){tokens[start].progid_end = tokens[i].right;i = tokens[i].right + 1;}else return 0;return i - start;} /**\r\n\t * @returns {Array}\r\n\t */function getProgid(){var startPos=pos;var progid_end=tokens[pos].progid_end;var x=joinValues(pos,progid_end);pos = progid_end + 1;var token=tokens[startPos];return newNode(NodeType.ProgidType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a property\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the property\r\n\t */function checkProperty(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkVariable(i) || checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**\r\n\t * Get node with a property\r\n\t * @returns {Array} `['property', x]`\r\n\t */function getProperty(){var startPos=pos;var x=[];if(checkVariable(pos)){x.push(getVariable());}else {x = x.concat(getIdentOrInterpolation());}var token=tokens[startPos];return newNode(NodeType.PropertyType,x,token.ln,token.col);} /**\r\n\t * Check if token is a colon\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is a colon, otherwise `0`\r\n\t */function checkPropertyDelim(i){return i < tokensLength && tokens[i].type === TokenType.Colon?1:0;} /**\r\n\t * Get node with a colon\r\n\t * @returns {Array} `['propertyDelim']`\r\n\t */function getPropertyDelim(){var startPos=pos;pos++;var token=tokens[startPos];return newNode(NodeType.PropertyDelimType,':',token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkPseudo(i){return checkPseudoe(i) || checkPseudoc(i);} /**\r\n\t * @returns {Array}\r\n\t */function getPseudo(){if(checkPseudoe(pos))return getPseudoe();if(checkPseudoc(pos))return getPseudoc();} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkPseudoe(i){var l;if(i >= tokensLength || tokens[i++].type !== TokenType.Colon || i >= tokensLength || tokens[i++].type !== TokenType.Colon)return 0;return (l = checkIdentOrInterpolation(i))?l + 2:0;} /**\r\n\t * @returns {Array}\r\n\t */function getPseudoe(){var startPos=pos;pos += 2;var x=getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.PseudoeType,x,token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkPseudoc(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.Colon)return 0;if(l = checkPseudoClass3(i))tokens[i].pseudoClassType = 3;else if(l = checkPseudoClass4(i))tokens[i].pseudoClassType = 4;else if(l = checkPseudoClass5(i))tokens[i].pseudoClassType = 5;else if(l = checkPseudoClass1(i))tokens[i].pseudoClassType = 1;else if(l = checkPseudoClass2(i))tokens[i].pseudoClassType = 2;else if(l = checkPseudoClass6(i))tokens[i].pseudoClassType = 6;else return 0;return l;} /**\r\n\t * @returns {Array}\r\n\t */function getPseudoc(){var childType=tokens[pos].pseudoClassType;if(childType === 1)return getPseudoClass1();if(childType === 2)return getPseudoClass2();if(childType === 3)return getPseudoClass3();if(childType === 4)return getPseudoClass4();if(childType === 5)return getPseudoClass5();if(childType === 6)return getPseudoClass6();} /**\r\n\t * (-) `:not(panda)`\r\n\t */function checkPseudoClass1(i){var start=i; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;var l=undefined;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSelectorsGroup(i))i += l;else return 0;if(i !== right)return 0;return right - start + 1;} /**\r\n\t * (-) `:not(panda)`\r\n\t */function getPseudoClass1(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `:`.\r\n\tpos++;content = content.concat(getIdentOrInterpolation());{var _type=NodeType.ArgumentsType;var _token=tokens[pos];var _line=_token.ln;var _column=_token.col; // Skip `(`.\r\n\tpos++;var selectors=getSelectorsGroup();var end=getLastPosition(selectors,_line,_column,1);var args=newNode(_type,selectors,_line,_column,end);content.push(args); // Skip `)`.\r\n\tpos++;}return newNode(type,content,line,column);} /**\r\n\t * (1) `:nth-child(odd)`\r\n\t * (2) `:nth-child(even)`\r\n\t * (3) `:lang(de-DE)`\r\n\t */function checkPseudoClass2(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass2(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `:`.\r\n\tpos++;content = content.concat(getIdentOrInterpolation());var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;value = value.concat(getSC()).concat(getIdentOrInterpolation()).concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:nth-child(-3n + 2)`\r\n\t */function checkPseudoClass3(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(l = checkNumberOrInterpolation(i))i += l;if(i >= tokensLength)return 0;if(tokens[i].value === 'n')i++;else return 0;if(l = checkSC(i))i += l;if(i >= tokensLength)return 0;if(tokens[i].type === TokenType.PlusSign || tokens[i].type === TokenType.HyphenMinus)i++;else return 0;if(l = checkSC(i))i += l;if(l = checkNumberOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass3(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;if(checkUnary(pos))value.push(getUnary());if(checkNumberOrInterpolation(pos))value = value.concat(getNumberOrInterpolation());{var _l=tokens[pos].ln;var _c=tokens[pos].col;var _content=tokens[pos].value;var ident=newNode(NodeType.IdentType,_content,_l,_c);value.push(ident);pos++;}value = value.concat(getSC());if(checkUnary(pos))value.push(getUnary());value = value.concat(getSC());if(checkNumberOrInterpolation(pos))value = value.concat(getNumberOrInterpolation());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:nth-child(-3n)`\r\n\t */function checkPseudoClass4(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l; // Check for leading unary `-`\r\n\tif(l = checkUnary(i))i += l; // Check for interpolation `#{i}`\r\n\tif(l = checkInterpolation(i))i += l;if(tokens[i].type === TokenType.DecimalNumber)i++;if(tokens[i].value === 'n')i++;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass4(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;value = value.concat(getSC());if(checkUnary(pos))value.push(getUnary());if(checkInterpolation(pos))value.push(getInterpolation());if(checkNumber(pos))value.push(getNumber());if(checkIdent(pos))value.push(getIdent());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:nth-child(+8)`\r\n\t */function checkPseudoClass5(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.\r\n\ti++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(tokens[i].type === TokenType.DecimalNumber)i++;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass5(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.\r\n\tpos++;if(checkUnary(pos))value.push(getUnary());if(checkNumber(pos))value.push(getNumber());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.\r\n\tpos++;return newNode(type,content,line,column);} /**\r\n\t * (-) `:checked`\r\n\t */function checkPseudoClass6(i){var start=i;var l=0; // Skip `:`.\r\n\ti++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getPseudoClass6(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.\r\n\tpos++;var content=getIdentOrInterpolation();return newNode(type,content,line,column);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkRuleset(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;}function getRuleset(){var type=NodeType.RulesetType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content = content.concat(getSelectorsGroup());content = content.concat(getSC());content.push(getBlock());return newNode(type,content,line,column);} /**\r\n\t * Check if token is marked as a space (if it's a space or a tab\r\n\t *      or a line break).\r\n\t * @param {Number} i\r\n\t * @returns {Number} Number of spaces in a row starting with the given token.\r\n\t */function checkS(i){return i < tokensLength && tokens[i].ws?tokens[i].ws_last - i + 1:0;} /**\r\n\t * Get node with spaces\r\n\t * @returns {Array} `['s', x]` where `x` is a string containing spaces\r\n\t */function getS(){var startPos=pos;var x=joinValues(pos,tokens[pos].ws_last);pos = tokens[pos].ws_last + 1;var token=tokens[startPos];return newNode(NodeType.SType,x,token.ln,token.col);} /**\r\n\t * Check if token is a space or a comment.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Number of similar (space or comment) tokens\r\n\t *      in a row starting with the given token.\r\n\t */function checkSC(i){if(i >= tokensLength)return 0;var l=undefined;var lsc=0;while(i < tokensLength) {if(!(l = checkS(i)) && !(l = checkCommentML(i)) && !(l = checkCommentSL(i)))break;i += l;lsc += l;}return lsc || 0;} /**\r\n\t * Get node with spaces and comments\r\n\t * @returns {Array} Array containing nodes with spaces (if there are any)\r\n\t *      and nodes with comments (if there are any):\r\n\t *      `[['s', x]*, ['comment', y]*]` where `x` is a string of spaces\r\n\t *      and `y` is a comment's text (without `/*` and `* /`).\r\n\t */function getSC(){var sc=[];if(pos >= tokensLength)return sc;while(pos < tokensLength) {if(checkS(pos))sc.push(getS());else if(checkCommentML(pos))sc.push(getCommentML());else if(checkCommentSL(pos))sc.push(getCommentSL());else break;}return sc;} /**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      a simple selector\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkShash(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.NumberSign)return 0;return (l = checkIdentOrInterpolation(i + 1))?l + 1:0;} /**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside a simple\r\n\t *      selector\r\n\t * @returns {Array} `['shash', x]` where `x` is a hexadecimal number\r\n\t *      converted to string (without `#`, e.g. `fff`)\r\n\t */function getShash(){var startPos=pos;var token=tokens[startPos];pos++;var x=getIdentOrInterpolation();return newNode(NodeType.ShashType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a string (text wrapped in quotes)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is part of a string, `0` if not\r\n\t */function checkString(i){if(i >= tokensLength)return 0;if(tokens[i].type === TokenType.StringSQ || tokens[i].type === TokenType.StringDQ){return 1;}return 0;} /**\r\n\t * Get string's node\r\n\t * @returns {Array} `['string', x]` where `x` is a string (including\r\n\t *      quotes).\r\n\t */function getString(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.StringType,x,token.ln,token.col);} /**\r\n\t * Validate stylesheet: it should consist of any number (0 or more) of\r\n\t * rulesets (sets of rules with selectors), @-rules, whitespaces or\r\n\t * comments.\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkStylesheet(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkSC(i) || checkDeclaration(i) || checkDeclDelim(i) || checkInclude(i) || checkExtend(i) || checkMixin(i) || checkLoop(i) || checkConditionalStatement(i) || checkAtrule(i) || checkRuleset(i))i += l;else throwError(i);}return i - start;} /**\r\n\t * @returns {Array} `['stylesheet', x]` where `x` is all stylesheet's\r\n\t *      nodes.\r\n\t */function getStylesheet(){var startPos=pos;var x=[];while(pos < tokensLength) {if(checkSC(pos))x = x.concat(getSC());else if(checkRuleset(pos))x.push(getRuleset());else if(checkInclude(pos))x.push(getInclude());else if(checkExtend(pos))x.push(getExtend());else if(checkMixin(pos))x.push(getMixin());else if(checkLoop(pos))x.push(getLoop());else if(checkConditionalStatement(pos))x.push(getConditionalStatement());else if(checkAtrule(pos))x.push(getAtrule());else if(checkDeclaration(pos))x.push(getDeclaration());else if(checkDeclDelim(pos))x.push(getDeclDelim());else throwError();}var token=tokens[startPos];return newNode(NodeType.StylesheetType,x,token.ln,token.col);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkTset(i){return checkVhash(i) || checkOperator(i) || checkAny(i) || checkSC(i) || checkInterpolation(i);} /**\r\n\t * @returns {Array}\r\n\t */function getTset(){if(checkVhash(pos))return getVhash();else if(checkOperator(pos))return getOperator();else if(checkAny(pos))return getAny();else if(checkSC(pos))return getSC();else if(checkInterpolation(pos))return getInterpolation();} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkTsets(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;while(l = checkTset(i)) {i += l;}return i - start;} /**\r\n\t * @returns {Array}\r\n\t */function getTsets(){var x=[];var t=undefined;while(t = getTset()) {if(typeof t.content === 'string')x.push(t);else x = x.concat(t);}return x;} /**\r\n\t * Check if token is an unary (arithmetical) sign (`+` or `-`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} `1` if token is an unary sign, `0` if not\r\n\t */function checkUnary(i){if(i >= tokensLength){return 0;}if(tokens[i].type === TokenType.HyphenMinus || tokens[i].type === TokenType.PlusSign){return 1;}return 0;} /**\r\n\t * Get node with an unary (arithmetical) sign (`+` or `-`)\r\n\t * @returns {Array} `['unary', x]` where `x` is an unary sign\r\n\t *      converted to string.\r\n\t */function getUnary(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.OperatorType,x,token.ln,token.col);} /**\r\n\t * Check if token is a unicode range (single or multiple <urange> nodes)\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Unicode range node's length\r\n\t */function checkUnicodeRange(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkUrange(i))i += l;else return 0;while(i < tokensLength) {var spaceBefore=checkSC(i);var comma=checkDelim(i + spaceBefore);if(!comma)break;var spaceAfter=checkSC(i + spaceBefore + comma);if(l = checkUrange(i + spaceBefore + comma + spaceAfter)){i += spaceBefore + comma + spaceAfter + l;}else break;}return i - start;} /**\r\n\t * Get a unicode range node\r\n\t * @return {Node}\r\n\t */function getUnicodeRange(){var type=NodeType.UnicodeRangeType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];while(pos < tokensLength) {if(checkSC(pos))content = content.concat(getSC());else if(checkDelim(pos))content.push(getDelim());else if(checkUrange(pos))content.push(getUrange());else break;}return newNode(type,content,line,column);} /**\r\n\t * Check if token is a u-range (part of a unicode-range)\r\n\t * (1) `U+416`\r\n\t * (2) `U+400-4ff`\r\n\t * (3) `U+4??`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Urange node's length\r\n\t */function checkUrange(i){var start=i;var l=undefined;if(i >= tokensLength)return 0; // Check for unicode prefix (u+ or U+)\r\n\tif(tokens[i].value === 'U' || tokens[i].value === 'u')i += 1;else return 0;if(i >= tokensLength)return 0;if(tokens[i].value === '+')i += 1;else return 0;while(i < tokensLength) {if(l = checkIdent(i))i += l;else if(l = checkNumber(i))i += l;else if(l = checkUnary(i))i += l;else if(l = _checkUnicodeWildcard(i))i += l;else break;}tokens[start].urangeEnd = i - 1;return i - start;} /**\r\n\t * Get a u-range node (part of a unicode-range)\r\n\t * @return {Node}\r\n\t */function getUrange(){var startPos=pos;var type=NodeType.UrangeType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content = joinValues(startPos,tokens[startPos].urangeEnd);pos = tokens[startPos].urangeEnd + 1;return newNode(type,content,line,column);} /**\r\n\t * Check for unicode wildcard characters `?`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Wildcard length\r\n\t */function _checkUnicodeWildcard(i){var start=i;if(i >= tokensLength)return 0;while(i < tokensLength) {if(tokens[i].type === TokenType.QuestionMark)i += 1;else break;}return i - start;} /**\r\n\t * Check if token is part of URI (e.g. `url('/css/styles.css')`)\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of URI\r\n\t */function checkUri(i){var start=i;if(i >= tokensLength || tokens[i++].value !== 'url' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - start + 1;} /**\r\n\t * Get node with URI\r\n\t * @returns {Array} `['uri', x]` where `x` is URI's nodes (without `url`\r\n\t *      and braces, e.g. `['string', ''/css/styles.css'']`).\r\n\t */function getUri(){var startPos=pos;var uriExcluding={};var uri=undefined;var token=undefined;var l=undefined;var raw=undefined;pos += 2;uriExcluding[TokenType.Space] = 1;uriExcluding[TokenType.Tab] = 1;uriExcluding[TokenType.Newline] = 1;uriExcluding[TokenType.LeftParenthesis] = 1;uriExcluding[TokenType.RightParenthesis] = 1;if(checkUriContent(pos)){uri = [].concat(getSC()).concat(getUriContent()).concat(getSC());}else {uri = [].concat(getSC());l = checkExcluding(uriExcluding,pos);token = tokens[pos];raw = newNode(NodeType.RawType,joinValues(pos,pos + l),token.ln,token.col);uri.push(raw);pos += l + 1;uri = uri.concat(getSC());}token = tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition(uri,line,column,1);pos++;return newNode(NodeType.UriType,uri,token.ln,token.col,end);} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkUriContent(i){return checkUri1(i) || checkFunction(i);} /**\r\n\t * @returns {Array}\r\n\t */function getUriContent(){if(checkUri1(pos))return getString();else if(checkFunction(pos))return getFunction();} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkUri1(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkSC(i))i += l;if(tokens[i].type !== TokenType.StringDQ && tokens[i].type !== TokenType.StringSQ)return 0;i++;if(l = checkSC(i))i += l;return i - start;} /**\r\n\t * Check if token is part of a value\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the value\r\n\t */function checkValue(i){var start=i;var l=undefined;var s=undefined;var _i=undefined;while(i < tokensLength) {if(checkDeclDelim(i))break;s = checkSC(i);_i = i + s;if(l = _checkValue(_i))i += l + s;if(!l || checkBlock(i - l))break;}return i - start;} /**\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function _checkValue(i){return checkInterpolation(i) || checkVariable(i) || checkVhash(i) || checkBlock(i) || checkAtkeyword(i) || checkOperator(i) || checkImportant(i) || checkGlobal(i) || checkDefault(i) || checkProgid(i) || checkAny(i) || checkParentSelector(i);} /**\r\n\t * @returns {Array}\r\n\t */function getValue(){var startPos=pos;var x=[];var _pos=undefined;var s=undefined;while(pos < tokensLength) {s = checkSC(pos);_pos = pos + s;if(checkDeclDelim(_pos))break;if(!_checkValue(_pos))break;if(s)x = x.concat(getSC());x.push(_getValue());if(checkBlock(_pos))break;}var token=tokens[startPos];return newNode(NodeType.ValueType,x,token.ln,token.col);} /**\r\n\t * @returns {Array}\r\n\t */function _getValue(){if(checkInterpolation(pos))return getInterpolation();else if(checkVariable(pos))return getVariable();else if(checkVhash(pos))return getVhash();else if(checkBlock(pos))return getBlock();else if(checkAtkeyword(pos))return getAtkeyword();else if(checkOperator(pos))return getOperator();else if(checkImportant(pos))return getImportant();else if(checkGlobal(pos))return getGlobal();else if(checkDefault(pos))return getDefault();else if(checkProgid(pos))return getProgid();else if(checkAny(pos))return getAny();else if(checkParentSelector(pos))return getParentSelector();} /**\r\n\t * Check if token is part of a variable\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number} Length of the variable\r\n\t */function checkVariable(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.DollarSign)return 0;return (l = checkIdent(i + 1))?l + 1:0;} /**\r\n\t * Get node with a variable\r\n\t * @returns {Array} `['variable', ['ident', x]]` where `x` is\r\n\t *      a variable name.\r\n\t */function getVariable(){var startPos=pos;var x=[];pos++;x.push(getIdent());var token=tokens[startPos];return newNode(NodeType.VariableType,x,token.ln,token.col);} /**\r\n\t * Check if token is part of a variables list (e.g. `$values...`).\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkVariablesList(i){var d=0; // Number of dots\r\n\tvar l=undefined;if(i >= tokensLength)return 0;if(l = checkVariable(i))i += l;else return 0;while(i < tokensLength && tokens[i].type === TokenType.FullStop) {d++;i++;}return d === 3?l + d:0;} /**\r\n\t * Get node with a variables list\r\n\t * @returns {Array} `['variableslist', ['variable', ['ident', x]]]` where\r\n\t *      `x` is a variable name.\r\n\t */function getVariablesList(){var startPos=pos;var x=getVariable();var token=tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition([x],line,column,3);pos += 3;return newNode(NodeType.VariablesListType,[x],token.ln,token.col,end);} /**\r\n\t * Check if token is part of a hexadecimal number (e.g. `#fff`) inside\r\n\t *      some value\r\n\t * @param {Number} i Token's index number\r\n\t * @returns {Number}\r\n\t */function checkVhash(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.NumberSign)return 0;return (l = checkNmName2(i + 1))?l + 1:0;} /**\r\n\t * Get node with a hexadecimal number (e.g. `#fff`) inside some value\r\n\t * @returns {Array} `['vhash', x]` where `x` is a hexadecimal number\r\n\t *      converted to string (without `#`, e.g. `'fff'`).\r\n\t */function getVhash(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;x = getNmName2();var end=getLastPosition(x,line,column + 1);return newNode(NodeType.VhashType,x,token.ln,token.col,end);}module.exports = function(_tokens,context){tokens = _tokens;tokensLength = tokens.length;pos = 0;return contexts[context]();};function checkSelectorsGroup(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkSelector(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);var c=checkDelim(i + sb);if(!c)break;var sa=checkSC(i + sb + c);if(l = checkSelector(i + sb + c + sa))i += sb + c + sa + l;else break;}tokens[start].selectorsGroupEnd = i;return i - start;}function getSelectorsGroup(){var selectorsGroup=[];var selectorsGroupEnd=tokens[pos].selectorsGroupEnd;selectorsGroup.push(getSelector());while(pos < selectorsGroupEnd) {selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getDelim());selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getSelector());}return selectorsGroup;}function checkSelector(i){var l;if(l = checkSelector1(i))tokens[i].selectorType = 1;else if(l = checkSelector2(i))tokens[i].selectorType = 2;return l;}function getSelector(){var selectorType=tokens[pos].selectorType;if(selectorType === 1)return getSelector1();else return getSelector2();} /**\r\n\t * Checks for selector which starts with a compound selector.\r\n\t */function checkSelector1(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkCompoundSelector(i))i += l;else return 0;while(i < tokensLength) {var s=checkSC(i);var c=checkCombinator(i + s);if(!s && !c)break;if(c){i += s + c;s = checkSC(i);}if(l = checkCompoundSelector(i + s))i += s + l;else break;}tokens[start].selectorEnd = i;return i - start;}function getSelector1(){var type=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var selectorEnd=token.selectorEnd;var content=getCompoundSelector();while(pos < selectorEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkCombinator(pos))content.push(getCombinator());else if(checkCompoundSelector(pos))content = content.concat(getCompoundSelector());}return newNode(type,content,line,column);} /**\r\n\t * Checks for a selector that starts with a combinator.\r\n\t */function checkSelector2(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkCombinator(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);if(l = checkCompoundSelector(i + sb))i += sb + l;else break;var sa=checkSC(i);var c=checkCombinator(i + sa);if(!sa && !c)break;if(c){i += sa + c;}}tokens[start].selectorEnd = i;return i - start;}function getSelector2(){var type=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var selectorEnd=token.selectorEnd;var content=[getCombinator()];while(pos < selectorEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkCombinator(pos))content.push(getCombinator());else if(checkCompoundSelector(pos))content = content.concat(getCompoundSelector());}return newNode(type,content,line,column);}function checkCompoundSelector(i){var l=undefined;if(l = checkCompoundSelector1(i)){tokens[i].compoundSelectorType = 1;}else if(l = checkCompoundSelector2(i)){tokens[i].compoundSelectorType = 2;}return l;}function getCompoundSelector(){var type=tokens[pos].compoundSelectorType;if(type === 1)return getCompoundSelector1();if(type === 2)return getCompoundSelector2();} /**\r\n\t * Check for compound selectors that start with either a type selector,\r\n\t * placeholder or parent selector with extension\r\n\t * (1) `foo.bar`\r\n\t * (2) `foo[attr=val]`\r\n\t * (3) `foo:first-of-type`\r\n\t * (4) `foo%bar`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Compound selector's length\r\n\t */function checkCompoundSelector1(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkTypeSelector(i) || checkPlaceholder(i) || checkParentSelectorWithExtension(i))i += l;else return 0;while(i < tokensLength) {var _l2=checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i) || checkPlaceholder(i);if(_l2)i += _l2;else break;}tokens[start].compoundSelectorEnd = i;return i - start;} /**\r\n\t * @return {Array} An array of nodes that make up the compound selector\r\n\t */function getCompoundSelector1(){var sequence=[];var compoundSelectorEnd=tokens[pos].compoundSelectorEnd;if(checkTypeSelector(pos))sequence.push(getTypeSelector());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());else if(checkParentSelectorWithExtension(pos))sequence = sequence.concat(getParentSelectorWithExtension());while(pos < compoundSelectorEnd) {if(checkShash(pos))sequence.push(getShash());else if(checkClass(pos))sequence.push(getClass());else if(checkAttributeSelector(pos))sequence.push(getAttributeSelector());else if(checkPseudo(pos))sequence.push(getPseudo());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());else break;}return sequence;} /**\r\n\t * Check for all other compound selectors\r\n\t * (1) `.foo.bar`\r\n\t * (2) `.foo[attr=val]`\r\n\t * (3) `.foo:first-of-type`\r\n\t * (4) `.foo%bar`\r\n\t * (5) `.foo#{$bar}`\r\n\t * @param {number} i Token's index\r\n\t * @return {number} Compound selector's length\r\n\t */function checkCompoundSelector2(i){if(i >= tokensLength)return 0;var start=i;while(i < tokensLength) {var l=checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i) || checkPlaceholder(i) || checkInterpolation(i);if(l)i += l;else break;}tokens[start].compoundSelectorEnd = i;return i - start;} /**\r\n\t * @return {Array} An array of nodes that make up the compound selector\r\n\t */function getCompoundSelector2(){var sequence=[];var compoundSelectorEnd=tokens[pos].compoundSelectorEnd;while(pos < compoundSelectorEnd) {if(checkShash(pos))sequence.push(getShash());else if(checkClass(pos))sequence.push(getClass());else if(checkAttributeSelector(pos))sequence.push(getAttributeSelector());else if(checkPseudo(pos))sequence.push(getPseudo());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());else if(checkInterpolation(pos))sequence.push(getInterpolation());else break;}return sequence;}function checkTypeSelector(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkNamePrefix(i))i += l;if(tokens[i].type === TokenType.Asterisk)i++;else if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getTypeSelector(){var type=NodeType.TypeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkNamePrefix(pos))content.push(getNamePrefix());token = tokens[pos];if(token.type === TokenType.Asterisk){var asteriskNode=newNode(NodeType.IdentType,'*',token.ln,token.col);content.push(asteriskNode);pos++;}else if(checkIdentOrInterpolation(pos))content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeSelector(i){var l=undefined;if(l = checkAttributeSelector1(i))tokens[i].attributeSelectorType = 1;else if(l = checkAttributeSelector2(i))tokens[i].attributeSelectorType = 2;return l;}function getAttributeSelector(){var type=tokens[pos].attributeSelectorType;if(type === 1)return getAttributeSelector1();else return getAttributeSelector2();} /**\r\n\t * (1) `[panda=nani]`\r\n\t * (2) `[panda='nani']`\r\n\t * (3) `[panda='nani' i]`\r\n\t *\r\n\t */function checkAttributeSelector1(i){var start=i;if(tokens[i].type === TokenType.LeftSquareBracket)i++;else return 0;var l=undefined;if(l = checkSC(i))i += l;if(l = checkAttributeName(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeMatch(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeValue(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeFlags(i)){i += l;if(l = checkSC(i))i += l;}if(tokens[i].type === TokenType.RightSquareBracket)i++;else return 0;return i - start;}function getAttributeSelector1(){var type=NodeType.AttributeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `[`.\r\n\tpos++;content = content.concat(getSC());content.push(getAttributeName());content = content.concat(getSC());content.push(getAttributeMatch());content = content.concat(getSC());content.push(getAttributeValue());content = content.concat(getSC());if(checkAttributeFlags(pos)){content.push(getAttributeFlags());content = content.concat(getSC());} // Skip `]`.\r\n\tpos++;var end=getLastPosition(content,line,column,1);return newNode(type,content,line,column,end);} /**\r\n\t * (1) `[panda]`\r\n\t */function checkAttributeSelector2(i){var start=i;if(tokens[i].type === TokenType.LeftSquareBracket)i++;else return 0;var l=undefined;if(l = checkSC(i))i += l;if(l = checkAttributeName(i))i += l;else return 0;if(l = checkSC(i))i += l;if(tokens[i].type === TokenType.RightSquareBracket)i++;else return 0;return i - start;}function getAttributeSelector2(){var type=NodeType.AttributeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `[`.\r\n\tpos++;content = content.concat(getSC());content.push(getAttributeName());content = content.concat(getSC()); // Skip `]`.\r\n\tpos++;var end=getLastPosition(content,line,column,1);return newNode(type,content,line,column,end);}function checkAttributeName(i){var start=i;var l=undefined;if(l = checkNamePrefix(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getAttributeName(){var type=NodeType.AttributeNameType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkNamePrefix(pos))content.push(getNamePrefix());content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeMatch(i){var l=undefined;if(l = checkAttributeMatch1(i))tokens[i].attributeMatchType = 1;else if(l = checkAttributeMatch2(i))tokens[i].attributeMatchType = 2;return l;}function getAttributeMatch(){var type=tokens[pos].attributeMatchType;if(type === 1)return getAttributeMatch1();else return getAttributeMatch2();}function checkAttributeMatch1(i){var start=i;var type=tokens[i].type;if(type === TokenType.Tilde || type === TokenType.VerticalLine || type === TokenType.CircumflexAccent || type === TokenType.DollarSign || type === TokenType.Asterisk)i++;else return 0;if(tokens[i].type === TokenType.EqualsSign)i++;else return 0;return i - start;}function getAttributeMatch1(){var type=NodeType.AttributeMatchType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=tokens[pos].value + tokens[pos + 1].value;pos += 2;return newNode(type,content,line,column);}function checkAttributeMatch2(i){if(tokens[i].type === TokenType.EqualsSign)return 1;else return 0;}function getAttributeMatch2(){var type=NodeType.AttributeMatchType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='=';pos++;return newNode(type,content,line,column);}function checkAttributeValue(i){return checkString(i) || checkIdentOrInterpolation(i);}function getAttributeValue(){var type=NodeType.AttributeValueType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkString(pos))content.push(getString());else content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeFlags(i){return checkIdentOrInterpolation(i);}function getAttributeFlags(){var type=NodeType.AttributeFlagsType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=getIdentOrInterpolation();return newNode(type,content,line,column);}function checkNamePrefix(i){if(i >= tokensLength)return 0;var l=undefined;if(l = checkNamePrefix1(i))tokens[i].namePrefixType = 1;else if(l = checkNamePrefix2(i))tokens[i].namePrefixType = 2;return l;}function getNamePrefix(){var type=tokens[pos].namePrefixType;if(type === 1)return getNamePrefix1();else return getNamePrefix2();} /**\r\n\t * (1) `panda|`\r\n\t * (2) `panda<comment>|`\r\n\t */function checkNamePrefix1(i){var start=i;var l=undefined;if(l = checkNamespacePrefix(i))i += l;else return 0;if(l = checkCommentML(i))i += l;if(l = checkNamespaceSeparator(i))i += l;else return 0;return i - start;}function getNamePrefix1(){var type=NodeType.NamePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content.push(getNamespacePrefix());if(checkCommentML(pos))content.push(getCommentML());content.push(getNamespaceSeparator());return newNode(type,content,line,column);} /**\r\n\t * (1) `|`\r\n\t */function checkNamePrefix2(i){return checkNamespaceSeparator(i);}function getNamePrefix2(){var type=NodeType.NamePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[getNamespaceSeparator()];return newNode(type,content,line,column);} /**\r\n\t * (1) `*`\r\n\t * (2) `panda`\r\n\t */function checkNamespacePrefix(i){if(i >= tokensLength)return 0;var l=undefined;if(tokens[i].type === TokenType.Asterisk)return 1;else if(l = checkIdentOrInterpolation(i))return l;else return 0;}function getNamespacePrefix(){var type=NodeType.NamespacePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(token.type === TokenType.Asterisk){var asteriskNode=newNode(NodeType.IdentType,'*',token.ln,token.col);content.push(asteriskNode);pos++;}else if(checkIdentOrInterpolation(pos))content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);} /**\r\n\t * (1) `|`\r\n\t */function checkNamespaceSeparator(i){if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.VerticalLine)return 0; // Return false if `|=` - [attr|=value]\r\n\tif(tokens[i + 1] && tokens[i + 1].type === TokenType.EqualsSign)return 0;return 1;}function getNamespaceSeparator(){var type=NodeType.NamespaceSeparatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='|';pos++;return newNode(type,content,line,column);}\r\n\r\n/***/ },\r\n/* 28 */\r\n/***/ function(module, exports, __nested_webpack_require_524557__) {\r\n\r\n\t'use strict';\r\n\r\n\tmodule.exports = function (css, tabSize) {\r\n\t  var TokenType = __nested_webpack_require_524557__(13);\r\n\r\n\t  var tokens = [];\r\n\t  var urlMode = false;\r\n\t  var c = undefined; // Current character\r\n\t  var cn = undefined; // Next character\r\n\t  var pos = 0;\r\n\t  var tn = 0;\r\n\t  var ln = 1;\r\n\t  var col = 1;\r\n\r\n\t  var Punctuation = {\r\n\t    ' ': TokenType.Space,\r\n\t    '\\n': TokenType.Newline,\r\n\t    '\\r': TokenType.Newline,\r\n\t    '\\t': TokenType.Tab,\r\n\t    '!': TokenType.ExclamationMark,\r\n\t    '\"': TokenType.QuotationMark,\r\n\t    '#': TokenType.NumberSign,\r\n\t    '$': TokenType.DollarSign,\r\n\t    '%': TokenType.PercentSign,\r\n\t    '&': TokenType.Ampersand,\r\n\t    '\\'': TokenType.Apostrophe,\r\n\t    '(': TokenType.LeftParenthesis,\r\n\t    ')': TokenType.RightParenthesis,\r\n\t    '*': TokenType.Asterisk,\r\n\t    '+': TokenType.PlusSign,\r\n\t    ',': TokenType.Comma,\r\n\t    '-': TokenType.HyphenMinus,\r\n\t    '.': TokenType.FullStop,\r\n\t    '/': TokenType.Solidus,\r\n\t    ':': TokenType.Colon,\r\n\t    ';': TokenType.Semicolon,\r\n\t    '<': TokenType.LessThanSign,\r\n\t    '=': TokenType.EqualsSign,\r\n\t    '==': TokenType.EqualitySign,\r\n\t    '!=': TokenType.InequalitySign,\r\n\t    '>': TokenType.GreaterThanSign,\r\n\t    '?': TokenType.QuestionMark,\r\n\t    '@': TokenType.CommercialAt,\r\n\t    '[': TokenType.LeftSquareBracket,\r\n\t    ']': TokenType.RightSquareBracket,\r\n\t    '^': TokenType.CircumflexAccent,\r\n\t    '_': TokenType.LowLine,\r\n\t    '{': TokenType.LeftCurlyBracket,\r\n\t    '|': TokenType.VerticalLine,\r\n\t    '}': TokenType.RightCurlyBracket,\r\n\t    '~': TokenType.Tilde\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Add a token to the token list\r\n\t   * @param {string} type\r\n\t   * @param {string} value\r\n\t   */\r\n\t  function pushToken(type, value, column) {\r\n\t    tokens.push({\r\n\t      tn: tn++,\r\n\t      ln: ln,\r\n\t      col: column,\r\n\t      type: type,\r\n\t      value: value\r\n\t    });\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Check if a character is a decimal digit\r\n\t   * @param {string} c Character\r\n\t   * @returns {boolean}\r\n\t   */\r\n\t  function isDecimalDigit(c) {\r\n\t    return '0123456789'.indexOf(c) >= 0;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse spaces\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseSpaces(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a non-space character:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) !== ' ') break;\r\n\t    }\r\n\r\n\t    // Add a substring containing only spaces to tokens:\r\n\t    pushToken(TokenType.Space, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse a string within quotes\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   * @param {string} q Quote (either `'` or `\"`)\r\n\t   */\r\n\t  function parseString(css, q) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a matching quote:\r\n\t    for (pos++; pos < css.length; pos++) {\r\n\t      // Skip escaped quotes:\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (css.charAt(pos) === q) break;\r\n\t    }\r\n\r\n\t    // Add the string (including quotes) to tokens:\r\n\t    var type = q === '\"' ? TokenType.StringDQ : TokenType.StringSQ;\r\n\t    pushToken(type, css.substring(start, pos + 1), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse numbers\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseDecimalNumber(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet a character that's not a digit:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      if (!isDecimalDigit(css.charAt(pos))) break;\r\n\t    }\r\n\r\n\t    // Add the number to tokens:\r\n\t    pushToken(TokenType.DecimalNumber, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse identifier\r\n\t   * @param {string} css Unparsed part of CSS string\r\n\t   */\r\n\t  function parseIdentifier(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Skip all opening slashes:\r\n\t    while (css.charAt(pos) === '/') pos++;\r\n\r\n\t    // Read the string until we meet a punctuation mark:\r\n\t    for (; pos < css.length; pos++) {\r\n\t      // Skip all '\\':\r\n\t      if (css.charAt(pos) === '\\\\') pos++;else if (css.charAt(pos) in Punctuation) break;\r\n\t    }\r\n\r\n\t    var ident = css.substring(start, pos--);\r\n\r\n\t    // Enter url mode if parsed substring is `url`:\r\n\t    if (!urlMode && ident === 'url' && css.charAt(pos + 1) === '(') {\r\n\t      urlMode = true;\r\n\t    }\r\n\r\n\t    // Add identifier to tokens:\r\n\t    pushToken(TokenType.Identifier, ident, col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse equality sign\r\n\t   */\r\n\t  function parseEquality() {\r\n\t    pushToken(TokenType.EqualitySign, '==', col);\r\n\t    pos++;\r\n\t    col++;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Parse inequality sign\r\n\t   */\r\n\t  function parseInequality() {\r\n\t    pushToken(TokenType.InequalitySign, '!=', col);\r\n\t    pos++;\r\n\t    col++;\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Parse a multiline comment\r\n\t  * @param {string} css Unparsed part of CSS string\r\n\t  */\r\n\t  function parseMLComment(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet `*/`.\r\n\t    // Since we already know first 2 characters (`/*`), start reading\r\n\t    // from `pos + 2`:\r\n\t    for (pos += 2; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) === '*' && css.charAt(pos + 1) === '/') {\r\n\t        pos++;\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Add full comment (including `/*` and `*/`) to the list of tokens:\r\n\t    var comment = css.substring(start, pos + 1);\r\n\t    pushToken(TokenType.CommentML, comment, col);\r\n\r\n\t    var newlines = comment.split('\\n');\r\n\t    if (newlines.length > 1) {\r\n\t      ln += newlines.length - 1;\r\n\t      col = newlines[newlines.length - 1].length;\r\n\t    } else {\r\n\t      col += pos - start;\r\n\t    }\r\n\t  }\r\n\r\n\t  /**\r\n\t  * Parse a single line comment\r\n\t  * @param {string} css Unparsed part of CSS string\r\n\t  */\r\n\t  function parseSLComment(css) {\r\n\t    var start = pos;\r\n\r\n\t    // Read the string until we meet line break.\r\n\t    // Since we already know first 2 characters (`//`), start reading\r\n\t    // from `pos + 2`:\r\n\t    for (pos += 2; pos < css.length; pos++) {\r\n\t      if (css.charAt(pos) === '\\n' || css.charAt(pos) === '\\r') {\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    // Add comment (including `//` and line break) to the list of tokens:\r\n\t    pushToken(TokenType.CommentSL, css.substring(start, pos--), col);\r\n\t    col += pos - start;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Convert a CSS string to a list of tokens\r\n\t   * @param {string} css CSS string\r\n\t   * @returns {Array} List of tokens\r\n\t   * @private\r\n\t   */\r\n\t  function getTokens(css) {\r\n\t    // Parse string, character by character:\r\n\t    for (pos = 0; pos < css.length; col++, pos++) {\r\n\t      c = css.charAt(pos);\r\n\t      cn = css.charAt(pos + 1);\r\n\r\n\t      // If we meet `/*`, it's a start of a multiline comment.\r\n\t      // Parse following characters as a multiline comment:\r\n\t      if (c === '/' && cn === '*') {\r\n\t        parseMLComment(css);\r\n\t      }\r\n\r\n\t      // If we meet `//` and it is not a part of url:\r\n\t      else if (!urlMode && c === '/' && cn === '/') {\r\n\t          // If we're currently inside a block, treat `//` as a start\r\n\t          // of identifier. Else treat `//` as a start of a single-line\r\n\t          // comment:\r\n\t          parseSLComment(css);\r\n\t        }\r\n\r\n\t        // If current character is a double or single quote, it's a start\r\n\t        // of a string:\r\n\t        else if (c === '\"' || c === \"'\") {\r\n\t            parseString(css, c);\r\n\t          }\r\n\r\n\t          // If current character is a space:\r\n\t          else if (c === ' ') {\r\n\t              parseSpaces(css);\r\n\t            }\r\n\r\n\t            // If current character is `=`, it must be combined with next `=`\r\n\t            else if (c === '=' && cn === '=') {\r\n\t                parseEquality(css);\r\n\t              }\r\n\r\n\t              // If we meet `!=`, this must be inequality\r\n\t              else if (c === '!' && cn === '=') {\r\n\t                  parseInequality(css);\r\n\t                }\r\n\r\n\t                // If current character is a punctuation mark:\r\n\t                else if (c in Punctuation) {\r\n\t                    // Check for CRLF here or just LF\r\n\t                    if (c === '\\r' && cn === '\\n' || c === '\\n') {\r\n\t                      // If \\r we know the next character is \\n due to statement above\r\n\t                      // so we push a CRLF token type to the token list and importantly\r\n\t                      // skip the next character so as not to double count newlines or\r\n\t                      // columns etc\r\n\t                      if (c === '\\r') {\r\n\t                        pushToken(TokenType.Newline, '\\r\\n', col);\r\n\t                        pos++; // If CRLF skip the next character and push crlf token\r\n\t                      } else if (c === '\\n') {\r\n\t                          // If just a LF newline and not part of CRLF newline we can just\r\n\t                          // push punctuation as usual\r\n\t                          pushToken(Punctuation[c], c, col);\r\n\t                        }\r\n\r\n\t                      ln++; // Go to next line\r\n\t                      col = 0; // Reset the column count\r\n\t                    } else if (c !== '\\r' && c !== '\\n') {\r\n\t                        // Handle all other punctuation and add to list of tokens\r\n\t                        pushToken(Punctuation[c], c, col);\r\n\t                      } // Go to next line\r\n\t                    if (c === ')') urlMode = false; // Exit url mode\r\n\t                    else if (c === '\\t' && tabSize > 1) col += tabSize - 1;\r\n\t                  }\r\n\r\n\t                  // If current character is a decimal digit:\r\n\t                  else if (isDecimalDigit(c)) {\r\n\t                      parseDecimalNumber(css);\r\n\t                    }\r\n\r\n\t                    // If current character is anything else:\r\n\t                    else {\r\n\t                        parseIdentifier(css);\r\n\t                      }\r\n\t    }\r\n\r\n\t    return tokens;\r\n\t  }\r\n\r\n\t  return getTokens(css);\r\n\t};\r\n\r\n/***/ },\r\n/* 29 */\r\n/***/ function(module, exports, __nested_webpack_require_534522__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar Node = __nested_webpack_require_534522__(1);\r\n\tvar NodeTypes = __nested_webpack_require_534522__(15);\r\n\r\n\tmodule.exports = function () {\r\n\t  return new Node({\r\n\t    type: NodeTypes.StylesheetType,\r\n\t    content: [],\r\n\t    start: [0, 0],\r\n\t    end: [0, 0]\r\n\t  });\r\n\t};\r\n\r\n/***/ }\r\n/******/ ])\r\n});\r\n;\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __nested_webpack_require_534899__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\nvar groot = __nested_webpack_require_534899__(11);\r\nvar helpers = __nested_webpack_require_534899__(0);\r\nvar slRules = __nested_webpack_require_534899__(13);\r\nvar ruleToggler = __nested_webpack_require_534899__(12);\r\nvar getToggledRules = ruleToggler.getToggledRules;\r\nvar isResultEnabled = ruleToggler.isResultEnabled;\r\n\r\nvar defaultConfig = {\r\n    \"rules\": {\r\n        \"extends-before-mixins\": 2,\r\n        \"hex-notation\": [2, {\r\n            \"style\": \"uppercase\"\r\n        }],\r\n        \"placeholder-in-extend\": 2,\r\n        \"no-warn\": 1,\r\n        \"no-important\": 2,\r\n        \"no-ids\": 2,\r\n        \"property-sort-order\": [1, {\r\n            \"ignore-custom-properties\": true,\r\n            \"order\": [\"display\", \"margin\"]\r\n        }],\r\n        \"mixins-before-declarations\": [2, {\r\n            \"exclude\": [\"breakpoint\", \"mq\"]\r\n        }],\r\n        \"no-debug\": 1,\r\n        \"indentation\": [2, {\r\n            \"size\": 2\r\n        }],\r\n        \"extends-before-declarations\": 2,\r\n        \"variable-for-property\": [2, {\r\n            \"properties\": [\"margin\", \"content\"]\r\n        }]\r\n    },\r\n    \"options\": {\r\n        \"output-file\": \"linters/sass-lint.html\",\r\n        \"formatter\": \"html\",\r\n        \"max-warnings\": 50,\r\n        \"merge-default-rules\": false\r\n    }\r\n};\r\n\r\nfunction verify(text, options) {\r\n    var baseConfig = JSON.parse(JSON.stringify(defaultConfig));\r\n    if (options) {\r\n        if (options.rules) {\r\n            for (var i in options.rules) {\r\n                baseConfig.rules[i] = options.rules[i];\r\n            }\r\n        }\r\n        if (options.options) {\r\n            for (var _i in options.options) {\r\n                baseConfig.options[_i] = options.options[_i];\r\n            }\r\n        }\r\n    }\r\n    var rules = slRules(baseConfig),\r\n        ast = {},\r\n        detects,\r\n        results = [],\r\n        errors = 0,\r\n        warnings = 0,\r\n        ruleToggles = null,\r\n        isEnabledFilter = null;\r\n\r\n    try {\r\n        ast = groot(text, 'scss');\r\n    } catch (e) {\r\n        var line = e.line || 1;\r\n        errors++;\r\n\r\n        results = [{\r\n            ruleId: 'Fatal',\r\n            line: line,\r\n            column: 1,\r\n            message: e.message,\r\n            severity: 2\r\n        }];\r\n    }\r\n\r\n    if (ast.content && ast.content.length > 0) {\r\n        ruleToggles = getToggledRules(ast);\r\n        isEnabledFilter = isResultEnabled(ruleToggles);\r\n\r\n        rules.forEach(function (rule) {\r\n            detects = rule.rule.detect(ast, rule).filter(isEnabledFilter);\r\n            if (detects.length) {\r\n                detects.forEach(function (detect) {\r\n                    detect.message += \" (\" + detect.ruleId + \")\";\r\n                });\r\n                if (rule.severity === 1) {\r\n                    warnings += detects.length;\r\n                    detects.forEach(function (detect) {\r\n                        detect.type = \"warning\";\r\n                    });\r\n                } else if (rule.severity === 2) {\r\n                    errors += detects.length;\r\n                    detects.forEach(function (detect) {\r\n                        detect.type = \"error\";\r\n                    });\r\n                }\r\n            }\r\n            results = results.concat(detects);\r\n        });\r\n    }\r\n    results.sort(helpers.sortDetects);\r\n    return {\r\n        'warningCount': warnings,\r\n        'errorCount': errors,\r\n        'messages': results\r\n    };\r\n}\r\nexports.default = { verify: verify };\r\n//modules.exports={verify};\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __nested_webpack_require_538454__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _sassLint = __nested_webpack_require_538454__(9);\r\n\r\nvar _sassLint2 = _interopRequireDefault(_sassLint);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nwindow.SCSSLint = _sassLint2.default;\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __nested_webpack_require_538791__) {\r\n\r\n\"use strict\";\r\n//////////////////////////////\r\n// Tree Abstraction\r\n//////////////////////////////\r\n\r\n\r\nvar gonzales = __nested_webpack_require_538791__(8);\r\n//var fm = require('front-matter');\r\nvar helpers = __nested_webpack_require_538791__(0);\r\n\r\nmodule.exports = function (text, syntax, filename) {\r\n  var tree;\r\n\r\n  // Run `.toString()` to allow Buffers to be passed in\r\n  text = helpers.stripBom(text.toString());\r\n\r\n  // if we're skipping front matter do it here, fall back to just our text in case it fails\r\n  //  if (fm.test(text)) {\r\n  //    text = fm(text).body || text;\r\n  //  }\r\n\r\n  try {\r\n    tree = gonzales.parse(text, {\r\n      'syntax': syntax\r\n    });\r\n  } catch (e) {\r\n    throw {\r\n      message: e.message,\r\n      file: filename,\r\n      line: e.line\r\n    };\r\n  }\r\n\r\n  if (typeof tree === 'undefined') {\r\n    throw {\r\n      message: 'Undefined tree',\r\n      file: filename,\r\n      text: text.toString(),\r\n      tree: tree.toString()\r\n    };\r\n  }\r\n\r\n  return tree;\r\n};\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n/**\r\n * Adds each rule in our array of rules in a disable comment into the toggledRules object\r\n * under the correct rule name along with the line and column number where the disable comment\r\n * was encountered\r\n *\r\n * @param {Object} toggledRules - Contains the information about each rule disable/enable\r\n                                  encountered and and what line/column it occurred on\r\n * @param {Array} rules - An array of rule names\r\n * @param {number} line - The line number the disable appeared on\r\n * @param {number} column - The column number the disable appeared on\r\n */\r\n\r\nvar addDisable = function addDisable(toggledRules, rules, line, column) {\r\n  rules.map(function (rule) {\r\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\r\n    toggledRules.ruleEnable[rule].push([false, line, column]);\r\n  });\r\n};\r\n\r\n/**\r\n * Adds each rule in our array of rules in a enable comment into the toggledRules object\r\n * under the correct rule name along with the line and column number where the enable comment\r\n * was encountered\r\n *\r\n * @param {Object} toggledRules - Contains the information about each rule enable\r\n                                  encountered and and what line/column it occurred on\r\n * @param {Array} rules - An array of rule names\r\n * @param {number} line - The line number the enable appeared on\r\n * @param {number} column - The column number the enable appeared on\r\n */\r\nvar addEnable = function addEnable(toggledRules, rules, line, column) {\r\n  rules.map(function (rule) {\r\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\r\n    toggledRules.ruleEnable[rule].push([true, line, column]);\r\n  });\r\n};\r\n\r\n/**\r\n * Adds each rule in our array of rules in a disable block comment into the toggledRules object\r\n * under the correct rule name along with the line and column number where the disable block comment\r\n * was encountered\r\n *\r\n * @param {Object} toggledRules - Contains the information about each rule enable\r\n                                  encountered and and what line/column that block occurred on\r\n * @param {Array} rules - An array of rule names\r\n * @param {Object} block - The block that is to be disabled\r\n */\r\nvar addDisableBlock = function addDisableBlock(toggledRules, rules, block) {\r\n  rules.map(function (rule) {\r\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\r\n    toggledRules.ruleEnable[rule].push([false, block.start.line, block.start.column]);\r\n    toggledRules.ruleEnable[rule].push([true, block.end.line, block.end.column]);\r\n  });\r\n};\r\n\r\n/**\r\n * Adds a globally disabled flag to the toggled rules globalEnable property including the line and column\r\n * that this comment was encountered on.\r\n *\r\n * @param {Object} toggledRules - Contains the information about the global disable comment\r\n                                  encountered and and what line/column it occurred on\r\n * @param {number} line - The line number the disable appeared on\r\n * @param {number} column - The column number the disable appeared on\r\n */\r\nvar addDisableAll = function addDisableAll(toggledRules, line, column) {\r\n  toggledRules.globalEnable.push([false, line, column]);\r\n};\r\n\r\n/**\r\n * Adds a globally enabled flag to the toggled rules globalEnable property including the line and column\r\n * that this comment was encountered on.\r\n *\r\n * @param {Object} toggledRules - Contains the information about the global enable comment\r\n                                  encountered and and what line/column it occurred on\r\n * @param {number} line - The line number the enable appeared on\r\n * @param {number} column - The column number the enable appeared on\r\n */\r\nvar addEnableAll = function addEnableAll(toggledRules, line, column) {\r\n  toggledRules.globalEnable.push([true, line, column]);\r\n};\r\n\r\n/**\r\n * Adds a line disabled flag to the ruleEnable property of the toggledRules object for each rule name\r\n * encountered in the comment and which line this comment was discovered on / refers to\r\n *\r\n * @param {Object} toggledRules - Contains the information about the line disable comment encountered, the rules\r\n *                              it relates to and which line it was encountered on\r\n * @param {Array} rules - An array of rule names to apply\r\n * @param {number} line - The line number that this disable should refer to\r\n */\r\nvar addDisableLine = function addDisableLine(toggledRules, rules, line) {\r\n  rules.map(function (rule) {\r\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\r\n    // NOTE: corner case not handled here: a 2nd disable inside an ignored line, which is unrealistically pathological.\r\n    toggledRules.ruleEnable[rule].push([false, line, 1]);\r\n    toggledRules.ruleEnable[rule].push([true, line + 1, 1]);\r\n  });\r\n};\r\n\r\n/**\r\n * This is the sorting function we use to sort the toggle stacks in our getToggledRules method\r\n * First sorts by line and then by column if the lines are identical\r\n *\r\n * @param {Array} toggleRangeA - The first rule to sort\r\n * @param {Array} toggleRangeB - The second rule to sort\r\n *\r\n * @returns {number} A pointer to signify to the sort method how the currently in focus value should be sorted\r\n */\r\nvar sortRange = function sortRange(toggleRangeA, toggleRangeB) {\r\n  var aLine = toggleRangeA[1],\r\n      aCol = toggleRangeA[2],\r\n      bLine = toggleRangeB[1],\r\n      bCol = toggleRangeB[2];\r\n  if (aLine < bLine) {\r\n    return -1;\r\n  }\r\n  if (aLine > bLine) {\r\n    return 1;\r\n  }\r\n  if (aCol < bCol) {\r\n    return -1;\r\n  }\r\n  if (aCol > bCol) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n};\r\n\r\n/**\r\n * Checks if line number A is before line number B, if it's the same then it checks if the column of A\r\n * is before the column of B\r\n *\r\n * @param {number} x - The line number of A\r\n * @param {number} y - The column number of A\r\n * @param {number} x2 - The line number of B\r\n * @param {number} y2 - The column number of B\r\n *\r\n * @returns {Boolean} Whether the current line/column A is before or the same as B\r\n */\r\nvar isBeforeOrSame = function isBeforeOrSame(x, y, x2, y2) {\r\n  return x < x2 || x === x2 && y < y2;\r\n};\r\n\r\n/**\r\n * Traverses the AST looking for sass-lint disable/enable comments and then builds an Object/node representation\r\n * of any it encounters\r\n *\r\n * @param {Object} ast - Gonzales PE abstract syntax tree\r\n *\r\n * @returns {Object} The toggledRules object containing all of our rule enable/disable information\r\n */\r\nmodule.exports.getToggledRules = function (ast) {\r\n  var toggledRules = {\r\n    ruleEnable: {\r\n      // Format in here is [isEnabled, line, column]\r\n    },\r\n    globalEnable: []\r\n  };\r\n  if (!ast.traverseByTypes) {\r\n    return toggledRules;\r\n  }\r\n  ast.traverseByTypes(['multilineComment', 'singlelineComment'], function (comment, i, parent) {\r\n    var content = comment.content;\r\n    if (!content) {\r\n      return;\r\n    }\r\n    var tokens = content.split(/[\\s,]+/).filter(function (s) {\r\n      return s.trim().length > 0;\r\n    });\r\n    if (!tokens.length) {\r\n      return;\r\n    }\r\n    var first = tokens[0],\r\n        rules = tokens.slice(1);\r\n    switch (first) {\r\n      case 'sass-lint:disable':\r\n        addDisable(toggledRules, rules, comment.start.line, comment.start.column);\r\n        break;\r\n      case 'sass-lint:enable':\r\n        addEnable(toggledRules, rules, comment.start.line, comment.start.column);\r\n        break;\r\n      case 'sass-lint:disable-block':\r\n        // future ref: not sure what the appropriate behavior is if there is no parent block; currently NPEs\r\n        addDisableBlock(toggledRules, rules, parent);\r\n        break;\r\n      case 'sass-lint:disable-all':\r\n        addDisableAll(toggledRules, comment.start.line, comment.start.column);\r\n        break;\r\n      case 'sass-lint:enable-all':\r\n        addEnableAll(toggledRules, comment.start.line, comment.start.column);\r\n        break;\r\n      case 'sass-lint:disable-line':\r\n        addDisableLine(toggledRules, rules, comment.start.line);\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n  });\r\n  // Sort these toggle stacks so reading them is easier (algorithmically).\r\n  // Usually already sorted but since it's not guaranteed by the contract with gonzales-pe, ensuring it is.\r\n  toggledRules.globalEnable.sort(sortRange);\r\n  Object.keys(toggledRules.ruleEnable).map(function (ruleId) {\r\n    toggledRules.ruleEnable[ruleId].sort(sortRange);\r\n  });\r\n  return toggledRules;\r\n};\r\n\r\n/**\r\n * Filters our rule results by checking the lint result and its line/column against our\r\n * toggledRules object to see whether we should still be reporting this lint.\r\n *\r\n * @param {Object} toggledRules - The toggledRules object containing all of our rule enable/disable information\r\n *\r\n * @returns {Boolean} Whether the current rule is disabled for this lint report\r\n */\r\nmodule.exports.isResultEnabled = function (toggledRules) {\r\n  return function (ruleResult) {\r\n    var ruleId = ruleResult.ruleId;\r\n    // Convention: if no column or line, assume rule is targetting 1.\r\n    var line = ruleResult.line || 1;\r\n    var column = ruleResult.column || 1;\r\n    var isGloballyEnabled = toggledRules.globalEnable.reduce(function (acc, toggleRange) {\r\n      return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2]) ? acc : toggleRange[0];\r\n    }, true);\r\n    if (!isGloballyEnabled) {\r\n      return false;\r\n    }\r\n    if (!toggledRules.ruleEnable[ruleId]) {\r\n      return true;\r\n    }\r\n    var isRuleEnabled = toggledRules.ruleEnable[ruleId].reduce(function (acc, toggleRange) {\r\n      return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2]) ? acc : toggleRange[0];\r\n    }, true);\r\n    if (!isRuleEnabled) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __nested_webpack_require_549601__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar merge = __nested_webpack_require_549601__(99);\r\nvar searchArray = function searchArray(haystack, needle) {\r\n    var i;\r\n    for (i = 0; i < haystack.length; i++) {\r\n        if (haystack[i].indexOf(needle) >= 0) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n\r\nfunction requireAll(requireContext) {\r\n    return requireContext.keys().map(requireContext);\r\n}\r\n// requires and returns all modules that match\r\n\r\nvar rules = requireAll(__nested_webpack_require_549601__(98));\r\n\r\nmodule.exports = function (config) {\r\n    var handlers = [],\r\n        i;\r\n    //\r\n    //  rules = fs.readdirSync(path.join(__dirname, 'rules'));\r\n    //  for (i = 0; i < rules.length; i++) {\r\n    //    rules[i] = path.join(__dirname, 'rules', rules[i]);\r\n    //  }\r\n    //    rules=modules;\r\n    Object.keys(config.rules).forEach(function (ruleName) {\r\n        var fullRule = config.rules[ruleName],\r\n            loadRule,\r\n            severity,\r\n            options,\r\n            ruleSearch;\r\n\r\n        if (typeof fullRule === 'number') {\r\n            severity = fullRule;\r\n            options = {};\r\n        } else {\r\n            severity = fullRule[0];\r\n            options = fullRule[1];\r\n        }\r\n\r\n        // Only seek out rules that are enabled\r\n        if (severity !== 0) {\r\n            //      var fileName = path.normalize(path.join('/', rule + '.js'));\r\n\r\n            //      ruleSearch = searchArray(rules, fileName);\r\n            loadRule = rules.find(function (rule) {\r\n                return rule.name === ruleName;\r\n            });\r\n            if (loadRule) {\r\n\r\n                options = merge.recursive(true, loadRule.defaults, options);\r\n\r\n                handlers.push({\r\n                    'rule': loadRule,\r\n                    'severity': severity,\r\n                    'options': options\r\n                });\r\n            } else {\r\n                throw new Error('Rule `' + ruleName + '` could not be found!');\r\n            }\r\n        }\r\n    });\r\n\r\n    return handlers;\r\n};\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_551673__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_551673__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'attribute-quotes',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('attributeValue', function (item) {\r\n      if (item.content[0].is('string') && !parser.options.include) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': item.start.line,\r\n          'column': item.start.column,\r\n          'message': 'Attribute values should not be surrounded by quotes',\r\n          'severity': parser.severity\r\n        });\r\n      } else if (item.content[0].is('ident') && parser.options.include) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': item.start.line,\r\n          'column': item.start.column,\r\n          'message': 'Attribute values should be surrounded by quotes',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __nested_webpack_require_552808__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_552808__(0);\r\nvar selectorHelpers = __nested_webpack_require_552808__(1);\r\n\r\n/**\r\n * Get number of BEM elements in\r\n * @param   {string}  str String representing a class selector\r\n * @returns {integer}     Number of BEM elements in str\r\n */\r\nvar bemDepth = function bemDepth(str) {\r\n  var elements = str.split('__').length;\r\n\r\n  if (elements >= 2) {\r\n    return elements - 1;\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'bem-depth',\r\n  'defaults': {\r\n    'max-depth': 1\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['ruleset', 'placeholder'], function (node) {\r\n      var name,\r\n          depth,\r\n          selectorAndExtensions,\r\n          maxDepth = parser.options['max-depth'];\r\n\r\n      if (node.is('placeholder')) {\r\n        name = selectorHelpers.constructSelector(node);\r\n        if (name) {\r\n          depth = bemDepth(name);\r\n          if (depth > maxDepth) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': node.start.line,\r\n              'column': node.start.column,\r\n              'message': ['Placeholder \\'%', name, '\\' should have ', maxDepth, ' or fewer BEM elements, but ', depth, ' were found.'].join(''),\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      } else {\r\n        selectorAndExtensions = helpers.collectSuffixExtensions(node, 'class');\r\n\r\n        selectorAndExtensions.forEach(function (selector) {\r\n          name = selector.content;\r\n          depth = bemDepth(name);\r\n\r\n          if (depth > maxDepth) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': selector.start.line,\r\n              'column': selector.start.column,\r\n              'message': ['Selector \\'.', name, '\\' should have ', maxDepth, ' or fewer BEM elements, but ', depth, ' were found.'].join(''),\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __nested_webpack_require_554994__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_554994__(0);\r\n\r\nvar borders = ['border', 'border-top', 'border-right', 'border-bottom', 'border-left'];\r\nvar allowedConventions = ['0', 'none'];\r\n\r\nmodule.exports = {\r\n  'name': 'border-zero',\r\n  'defaults': {\r\n    'convention': '0'\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n    var userConvention = parser.options.convention.toString();\r\n    var convention = allowedConventions.indexOf(userConvention) !== -1 ? userConvention : allowedConventions[0];\r\n    var invalidConvention = convention !== userConvention;\r\n\r\n    ast.traverseByType('declaration', function (declaration) {\r\n      var isBorder = false;\r\n\r\n      declaration.traverse(function (item) {\r\n        if (item.type === 'property') {\r\n          item.traverse(function (child) {\r\n            if (borders.indexOf(child.content) !== -1) {\r\n              isBorder = true;\r\n            }\r\n          });\r\n        }\r\n\r\n        if (isBorder) {\r\n          if (item.type === 'value') {\r\n            var node = item.content[0];\r\n            if (node.type === 'number' || node.type === 'ident') {\r\n              if (node.content === '0' || node.content === 'none') {\r\n                if (convention !== node.content) {\r\n                  if (invalidConvention) {\r\n                    invalidConvention = false;\r\n                    result = helpers.addUnique(result, {\r\n                      'ruleId': parser.rule.name,\r\n                      'line': 1,\r\n                      'column': 1,\r\n                      'message': 'The border-zero convention `' + userConvention + ' in your config file is not valid. Defaulted to convention \\'0\\'',\r\n                      'severity': parser.severity\r\n                    });\r\n                  }\r\n                  result = helpers.addUnique(result, {\r\n                    'ruleId': parser.rule.name,\r\n                    'line': node.start.line,\r\n                    'column': node.start.column,\r\n                    'message': 'A value of `' + node.content + '` is not allowed. `' + convention + '` must be used.',\r\n                    'severity': parser.severity\r\n                  });\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_557360__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_557360__(0);\r\n\r\n/**\r\n * Get the current block within a node\r\n *\r\n * @param {Object} node - The node containing our desired block\r\n * @returns {Object} The current block of the node\r\n */\r\nvar getCurrentNode = function getCurrentNode(node) {\r\n  return node.contains('block') ? node.first('block') : false;\r\n};\r\n\r\n/**\r\n * Get the previous node\r\n *\r\n * @param {Object} node - Our current node\r\n * @returns {Object|bool} The previous node or false if not found\r\n */\r\nvar getPreviousNode = function getPreviousNode(node) {\r\n  // Rulesets\r\n  if (node.is('ruleset')) {\r\n    return node.contains('selector') ? node.last('selector') : false;\r\n  }\r\n\r\n  // Conditonal statements\r\n  if (node.is('conditionalStatement')) {\r\n    var previousParent = node.contains('condition') ? node.last('condition') : false;\r\n    return previousParent && previousParent.contains('atkeyword') ? previousParent.last('atkeyword') : false;\r\n  }\r\n\r\n  // Loops\r\n  if (node.is('loop')) {\r\n    return node.contains('atkeyword') ? node.last('atkeyword') : false;\r\n  }\r\n\r\n  // Mixins and atrules (functions etc)\r\n  if (node.is('mixin') || node.is('atrule')) {\r\n    if (node.contains('function')) {\r\n      return node.last('function');\r\n    }\r\n\r\n    if (node.contains('arguments')) {\r\n      return node.last('arguments');\r\n    }\r\n    return node.contains('atkeyword') ? node.last('atkeyword') : false;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if current node is an exception and end checks if it is\r\n * If we've picked up a return @rule ignore it\r\n *\r\n * @param {Object} node - The original node\r\n * @param {object} currentNode - The current node block\r\n * @param {Object} previousNode - The node previous to our current node\r\n * @returns {bool} Whether or not the it is an exception\r\n */\r\nvar isException = function isException(node, currentNode, previousNode) {\r\n  if (node.is('atrule')) {\r\n    if (previousNode.contains('ident') && previousNode.first('ident').content === 'return') {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if statement is a single line statement\r\n *\r\n * @param {Object} node - The statement to check\r\n * @returns {bool} True or false\r\n */\r\nvar isSingleLineStatement = function isSingleLineStatement(node) {\r\n  return node.start.line === node.end.line;\r\n};\r\n\r\n/**\r\n * Determine if opening brace of statement is on a new line\r\n *\r\n * @param {Object} nodeA - The previous block\r\n * @param {Object} nodeB - The current block\r\n * @returns {bool} True or false\r\n */\r\nvar isOpeningBraceOnNewLine = function isOpeningBraceOnNewLine(nodeA, nodeB) {\r\n  return nodeA.end.line === nodeB.start.line;\r\n};\r\n\r\n/**\r\n * Determine if closing brace of statement is on new line\r\n *\r\n * @param {Object} node - The current block\r\n * @returns {bool|null} True or false if relevant else null\r\n */\r\nvar isClosingBraceOnNewLine = function isClosingBraceOnNewLine(node) {\r\n  if (node.contains('block')) {\r\n    var content = node.first('block'),\r\n        contentLength = content.length - 1,\r\n        lastNode = content.get(contentLength);\r\n\r\n    if (lastNode && lastNode.is('space') && helpers.hasEOL(lastNode.content)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Determine if condition starts on a new line by checking the leading node for\r\n * an end-of-line\r\n *\r\n * @param {Object} node - The node that is our condition\r\n * @param {Object} parentNode - The condition node's parent\r\n * @param {Number} j - The index of our node in the context of the parent's children\r\n * @returns {bool|null} True or false if relevant else null\r\n */\r\nvar isConditionOnNewLine = function isConditionOnNewLine(node, parentNode, j) {\r\n  var currentNode = node;\r\n\r\n  // Check node is part of an `else if` and if it is, use the else node instead\r\n  if (node.first('ident').content === 'if') {\r\n    var initialNode = parentNode.get(j);\r\n    currentNode = initialNode.contains('atkeyword') ? initialNode.first('atkeyword') : false;\r\n  }\r\n\r\n  // Only check if it's an @else condition\r\n  if (currentNode && currentNode.contains('ident') && currentNode.first('ident').content === 'else') {\r\n    // Reverse back up tree\r\n    var previousChild = parentNode.get(--j) || false;\r\n    if (previousChild) {\r\n      // Determine if we have a leading new line\r\n      if (previousChild.is('space') && helpers.hasEOL(previousChild.content)) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    return false;\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Run the rule checks and return their results\r\n *\r\n * @param {Object} node - The original node\r\n * @param {Object} currentNode - The current node block\r\n * @param {Object} previousNode - The node previous to our current node\r\n * @param {Object} parentNode - The parent of the original node\r\n * @param {int} index - The index of the original node\r\n * @returns {Object} The results of the rule checks\r\n */\r\nvar runRuleChecks = function runRuleChecks(node, currentNode, previousNode, parentNode, index) {\r\n  var checks = {};\r\n\r\n  // Determine if single line statement\r\n  checks.singleLineStatement = isSingleLineStatement(node);\r\n\r\n  // Determine if condition is on a new line\r\n  if (node.is('atrule') || node.is('conditionalStatement')) {\r\n    checks.conditionOnNewLine = isConditionOnNewLine(previousNode, parentNode, index);\r\n  }\r\n\r\n  // Determine if opening brace is on new line\r\n  if (previousNode && currentNode) {\r\n    checks.openingBraceOnNewLine = isOpeningBraceOnNewLine(previousNode, currentNode);\r\n  }\r\n\r\n  // Determine if closing brace is on new line\r\n  checks.closingBraceOnNewLine = isClosingBraceOnNewLine(node);\r\n\r\n  return checks;\r\n};\r\n\r\n/**\r\n * Filter at-rules\r\n *\r\n * @param {Object} node - The node to filter\r\n * @param {Array} accepted - The array of accepted at-rule types\r\n * @returns {bool} true if we should ignore, false to continue\r\n */\r\nvar filterAtrule = function filterAtrule(node, accepted) {\r\n  if (node.is('atrule')) {\r\n    if (node.contains('atkeyword') && node.first('atkeyword').contains('ident')) {\r\n      if (accepted.indexOf(node.first('atkeyword').first('ident').content) === -1) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Create an issue using the supplied information\r\n *\r\n * @param {Object} parser - The parser\r\n * @param {Object} node - The node with the issue\r\n * @param {string} message - The message to display\r\n * @returns {Object} An object containing an issue\r\n */\r\nvar createIssue = function createIssue(parser, node, message) {\r\n  return {\r\n    'ruleId': parser.rule.name,\r\n    'line': node.line,\r\n    'column': node.column,\r\n    'message': message,\r\n    'severity': parser.severity\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'brace-style',\r\n  'defaults': {\r\n    'style': '1tbs',\r\n    'allow-single-line': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        acceptedAtrules = ['function', 'if', 'else'];\r\n\r\n    ast.traverseByTypes(['conditionalStatement', 'atrule', 'ruleset', 'mixin', 'loop'], function (node, i, parent) {\r\n      var currentNode = false,\r\n          previousNode = false,\r\n          checks = {\r\n        singleLineStatement: null,\r\n        openingBraceOnNewLine: null,\r\n        closingBraceOnNewLine: null,\r\n        conditionOnNewLine: null\r\n      },\r\n          messages = ['Single line statements are not allowed', 'Opening brace must be on the same line as condition', 'Brace must be on a new line', 'Statement must start on the same line as the closing brace of the previous statement', 'Statement must begin on a new line', 'Closing brace must be on a new line'];\r\n\r\n      // SCSS syntax only rule\r\n      if (ast.syntax === 'sass') {\r\n        return false;\r\n      }\r\n\r\n      // Filter at-rule types\r\n      if (filterAtrule(node, acceptedAtrules)) {\r\n        return false;\r\n      }\r\n\r\n      // Assign current & previous nodes based on node type\r\n      currentNode = getCurrentNode(node);\r\n      previousNode = getPreviousNode(node);\r\n\r\n      // If not an exception carry on\r\n      if (!isException(node, currentNode, previousNode)) {\r\n\r\n        // Run and store rule check results\r\n        checks = runRuleChecks(node, currentNode, previousNode, parent, i);\r\n\r\n        // Build single-line statement results\r\n        if (checks.singleLineStatement === false && checks.closingBraceOnNewLine === false) {\r\n          result = helpers.addUnique(result, createIssue(parser, {\r\n            line: currentNode.end.line,\r\n            column: currentNode.end.column\r\n          }, messages[5]));\r\n        }\r\n\r\n        if (checks.singleLineStatement === true) {\r\n          if (parser.options['allow-single-line'] === false) {\r\n            result = helpers.addUnique(result, createIssue(parser, {\r\n              line: node.start.line,\r\n              column: node.start.column\r\n            }, messages[0]));\r\n          }\r\n          return false;\r\n        }\r\n\r\n        // Build brace-style results\r\n        if (previousNode && currentNode) {\r\n          if (parser.options.style === '1tbs') {\r\n            if (checks.openingBraceOnNewLine === false) {\r\n              result = helpers.addUnique(result, createIssue(parser, {\r\n                line: currentNode.start.line,\r\n                column: currentNode.start.column\r\n              }, messages[1]));\r\n            }\r\n            if (checks.conditionOnNewLine === true) {\r\n              result = helpers.addUnique(result, createIssue(parser, {\r\n                line: previousNode.start.line,\r\n                column: previousNode.start.column\r\n              }, messages[3]));\r\n            }\r\n          }\r\n\r\n          if (parser.options.style === 'stroustrup') {\r\n            if (checks.openingBraceOnNewLine === false) {\r\n              result = helpers.addUnique(result, createIssue(parser, {\r\n                line: currentNode.start.line,\r\n                column: currentNode.start.column\r\n              }, messages[1]));\r\n            }\r\n            if (checks.conditionOnNewLine === false) {\r\n              result = helpers.addUnique(result, createIssue(parser, {\r\n                line: previousNode.start.line,\r\n                column: previousNode.start.column\r\n              }, messages[4]));\r\n            }\r\n          }\r\n\r\n          if (parser.options.style === 'allman') {\r\n            if (checks.openingBraceOnNewLine === true) {\r\n              result = helpers.addUnique(result, createIssue(parser, {\r\n                line: currentNode.end.line,\r\n                column: currentNode.end.column\r\n              }, messages[2]));\r\n            }\r\n            if (checks.conditionOnNewLine === false) {\r\n              result = helpers.addUnique(result, createIssue(parser, {\r\n                line: previousNode.start.line,\r\n                column: previousNode.start.column\r\n              }, messages[4]));\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __nested_webpack_require_568334__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_568334__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'class-name-format',\r\n  'defaults': {\r\n    'allow-leading-underscore': true,\r\n    'convention': 'hyphenatedlowercase',\r\n    'convention-explanation': false,\r\n    'ignore': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('ruleset', function (ruleset) {\r\n      var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, 'class');\r\n\r\n      selectorAndExtensions.forEach(function (node) {\r\n        var name = node.content,\r\n            strippedName,\r\n            violationMessage = false;\r\n\r\n        if (parser.options.ignore.indexOf(name) !== -1) {\r\n          return;\r\n        }\r\n\r\n        strippedName = name;\r\n\r\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\r\n          strippedName = name.slice(1);\r\n        }\r\n\r\n        switch (parser.options.convention) {\r\n          case 'hyphenatedlowercase':\r\n            if (!helpers.isHyphenatedLowercase(strippedName)) {\r\n              violationMessage = 'Class \\'.' + name + '\\' should be written in lowercase with hyphens';\r\n            }\r\n            break;\r\n          case 'camelcase':\r\n            if (!helpers.isCamelCase(strippedName)) {\r\n              violationMessage = 'Class \\'.' + name + '\\' should be written in camelCase';\r\n            }\r\n            break;\r\n          case 'pascalcase':\r\n            if (!helpers.isPascalCase(strippedName)) {\r\n              violationMessage = 'Class \\'.' + name + '\\' should be written in PascalCase';\r\n            }\r\n            break;\r\n          case 'snakecase':\r\n            if (!helpers.isSnakeCase(strippedName)) {\r\n              violationMessage = 'Class \\'.' + name + '\\' should be written in snake_case';\r\n            }\r\n            break;\r\n          case 'strictbem':\r\n            if (!helpers.isStrictBEM(strippedName)) {\r\n              violationMessage = 'Class \\'.' + name + '\\' should be written in BEM (Block Element Modifier) format';\r\n            }\r\n            break;\r\n          case 'hyphenatedbem':\r\n            if (!helpers.isHyphenatedBEM(strippedName)) {\r\n              violationMessage = 'Class \\'.' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\r\n            }\r\n            break;\r\n          default:\r\n            if (!new RegExp(parser.options.convention).test(strippedName)) {\r\n              violationMessage = 'Class \\'.' + name + '\\' should match regular expression /' + parser.options.convention + '/';\r\n\r\n              // convention-message overrides violationMessage\r\n              if (parser.options['convention-explanation']) {\r\n                violationMessage = parser.options['convention-explanation'];\r\n              }\r\n            }\r\n        }\r\n\r\n        if (violationMessage) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': violationMessage,\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __nested_webpack_require_571573__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_571573__(0),\r\n    path = __nested_webpack_require_571573__(87);\r\n\r\nvar getImportPath = function getImportPath(parent, syntax) {\r\n  if (parent.first('uri')) {\r\n    return parent.first('uri');\r\n  }\r\n\r\n  if (parent.first('string')) {\r\n    return helpers.stripQuotes(parent.first('string').content);\r\n  }\r\n\r\n  if (parent.first('ident')) {\r\n\r\n    if (syntax === 'sass') {\r\n      var output = '',\r\n          isFinished = false;\r\n\r\n      parent.forEach(function (item) {\r\n        // Force an end if we've appended a 'class'.. aka file extension\r\n        if (!isFinished) {\r\n          // Since we don't have quotes, gonzales-pe will parse file path as\r\n          // multiple different types\r\n          if (item.type === 'string' || item.type === 'operator' || item.type === 'ident') {\r\n            output += item.content;\r\n          }\r\n\r\n          // Gonzales-pe parses file extensions as classes if they are not\r\n          // wrapped in quotes...\r\n          if (item.type === 'class') {\r\n            if (item.first('ident')) {\r\n              output += '.' + item.first('ident').content;\r\n            }\r\n\r\n            isFinished = true;\r\n          }\r\n        }\r\n      });\r\n\r\n      return output.trim();\r\n    }\r\n\r\n    return parent.first('ident');\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'clean-import-paths',\r\n  'defaults': {\r\n    'leading-underscore': false,\r\n    'filename-extension': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('atkeyword', function (keyword, i, parent) {\r\n      keyword.forEach(function (item) {\r\n        if (item.content === 'import') {\r\n          var importPath = getImportPath(parent, keyword.syntax);\r\n\r\n          if (importPath) {\r\n            if (typeof importPath === 'string') {\r\n              var filename = path.basename(importPath),\r\n                  fileExtension = path.extname(filename);\r\n\r\n              if (fileExtension === '.sass' || fileExtension === '.scss' || fileExtension === '') {\r\n                if (filename.charAt(0) === '_') {\r\n                  if (!parser.options['leading-underscore']) {\r\n                    result = helpers.addUnique(result, {\r\n                      'ruleId': parser.rule.name,\r\n                      'line': item.start.line,\r\n                      'column': item.start.column,\r\n                      'message': 'Leading underscores are not allowed',\r\n                      'severity': parser.severity\r\n                    });\r\n                  }\r\n                } else {\r\n                  if (parser.options['leading-underscore']) {\r\n                    result = helpers.addUnique(result, {\r\n                      'ruleId': parser.rule.name,\r\n                      'line': item.start.line,\r\n                      'column': item.start.column,\r\n                      'message': 'Leading underscores are required',\r\n                      'severity': parser.severity\r\n                    });\r\n                  }\r\n                }\r\n\r\n                if (fileExtension) {\r\n                  if (!parser.options['filename-extension']) {\r\n                    result = helpers.addUnique(result, {\r\n                      'ruleId': parser.rule.name,\r\n                      'line': item.start.line,\r\n                      'column': item.start.column,\r\n                      'message': 'File extensions are not allowed',\r\n                      'severity': parser.severity\r\n                    });\r\n                  }\r\n                } else {\r\n                  if (parser.options['filename-extension']) {\r\n                    result = helpers.addUnique(result, {\r\n                      'ruleId': parser.rule.name,\r\n                      'line': item.start.line,\r\n                      'column': item.start.column,\r\n                      'message': 'File extensions are required',\r\n                      'severity': parser.severity\r\n                    });\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __nested_webpack_require_575730__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_575730__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'declarations-before-nesting',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        error;\r\n\r\n    ast.traverseByType('block', function (block) {\r\n      if (block.contains('ruleset') && block.contains('declaration')) {\r\n        var rulesetIndex;\r\n\r\n        block.forEach(function (item, j) {\r\n          var declarationIndex;\r\n          var declaration;\r\n\r\n          if (item.is('ruleset') && rulesetIndex === void 0) {\r\n            rulesetIndex = j;\r\n          }\r\n\r\n          if (item.is('declaration')) {\r\n            var property = item.content[0];\r\n\r\n            if (property && property.is('property')) {\r\n              if (property.content[0] && property.content[0].is('variable')) {\r\n                return;\r\n              }\r\n            }\r\n\r\n            declarationIndex = j;\r\n            declaration = item;\r\n          }\r\n\r\n          if (rulesetIndex < declarationIndex && declaration) {\r\n            error = {\r\n              'ruleId': parser.rule.name,\r\n              'line': declaration.start.line,\r\n              'column': declaration.start.column,\r\n              'message': 'Declarations should come before nestings',\r\n              'severity': parser.severity\r\n            };\r\n            result = helpers.addUnique(result, error);\r\n          }\r\n        });\r\n\r\n        rulesetIndex = null;\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __nested_webpack_require_577295__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_577295__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'empty-args',\r\n  'defaults': {\r\n    'include': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['mixin', 'include'], function (item) {\r\n      if (item.contains('arguments')) {\r\n        item.traverse(function (node) {\r\n          if (node.type === 'arguments') {\r\n            if (node.content.length === 0) {\r\n              if (!parser.options.include) {\r\n                result = helpers.addUnique(result, {\r\n                  'ruleId': parser.rule.name,\r\n                  'line': node.start.line,\r\n                  'column': node.start.column,\r\n                  'message': 'Parenthesis should be removed.',\r\n                  'severity': parser.severity\r\n                });\r\n              }\r\n            }\r\n          }\r\n        });\r\n      } else {\r\n        if (parser.options.include) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': item.start.line,\r\n            'column': item.start.column,\r\n            'message': 'Parenthesis are required.',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __nested_webpack_require_578654__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_578654__(0);\r\n\r\nvar counter, syntax;\r\n\r\nvar findNearestReturnSCSS = function findNearestReturnSCSS(parent, i) {\r\n  var previous, doublePrevious, space;\r\n\r\n  if (parent.content[i - 1]) {\r\n    previous = parent.content[i - 1];\r\n\r\n    if (i >= 2) {\r\n      doublePrevious = parent.content[i - 2];\r\n\r\n      // First check to see that the previous line is not a new line as if it is\r\n      // we don't want to recursively run the function again\r\n\r\n      if (!helpers.isEmptyLine(previous.content)) {\r\n        if (doublePrevious.type.indexOf('Comment') !== -1) {\r\n          return findNearestReturnSCSS(parent, i - 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (i >= 1) {\r\n      if (previous.type.indexOf('Comment') !== -1) {\r\n        return findNearestReturnSCSS(parent, i - 1);\r\n      }\r\n\r\n      if (previous.type === 'space') {\r\n        space = helpers.isEmptyLine(previous.content);\r\n\r\n        // If there's not a new line and it's the first within the block, ignore\r\n        if (!space && i - 1 === 0) {\r\n          return false;\r\n        }\r\n\r\n        return {\r\n          'space': space,\r\n          'previous': previous\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nvar findNearestReturnSass = function findNearestReturnSass(parent, i) {\r\n  var previous;\r\n\r\n  if (parent.content[i - 1]) {\r\n    previous = parent.content[i - 1];\r\n\r\n    if (counter === 2) {\r\n      return {\r\n        space: true,\r\n        previous: previous\r\n      };\r\n    }\r\n\r\n    if (previous.is('space') || previous.is('declarationDelimiter')) {\r\n      if (helpers.hasEOL(previous.content)) {\r\n        counter++;\r\n      }\r\n\r\n      return findNearestReturnSass(parent, i - 1);\r\n    }\r\n\r\n    // If ruleset, we must reset the parent to be the previous node and\r\n    // loop through that\r\n    else if (previous.is('ruleset') || previous.is('include')) {\r\n        var previousNode = previous.content[previous.content.length - 1];\r\n\r\n        // Set the i parameter for findNearestReturn to be the length of the\r\n        // content array in order to get the last one\r\n        return findNearestReturnSass(previousNode, previousNode.content.length);\r\n      } else {\r\n        counter = 0;\r\n\r\n        if (previous.type.indexOf('Comment') !== -1) {\r\n\r\n          // If it's the first line\r\n          if (previous.start.line === 1) {\r\n            return {\r\n              space: true,\r\n              previous: previous\r\n            };\r\n          }\r\n\r\n          return findNearestReturnSass(parent, i - 1);\r\n        }\r\n      }\r\n  }\r\n\r\n  return {\r\n    space: false,\r\n    previous: previous\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'empty-line-between-blocks',\r\n  'defaults': {\r\n    'include': true,\r\n    'allow-single-line-rulesets': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n    syntax = ast.syntax;\r\n\r\n    ast.traverseByType('ruleset', function (node, j, p) {\r\n      var space;\r\n\r\n      if (node.start.line === node.end.line && parser.options['allow-single-line-rulesets']) {\r\n        return false;\r\n      }\r\n\r\n      if (syntax === 'scss') {\r\n        space = findNearestReturnSCSS(p, j);\r\n\r\n        if (space) {\r\n          if (parser.options.include && !space.space && j !== 1) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': space.previous.end.line,\r\n              'column': 1,\r\n              'message': 'Space expected between blocks',\r\n              'severity': parser.severity\r\n            });\r\n          } else if (!parser.options.include && space.space) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': space.previous.end.line,\r\n              'column': 1,\r\n              'message': 'Space not allowed between blocks',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      } else if (syntax === 'sass') {\r\n        // Reset the counter for each ruleset\r\n        counter = 0;\r\n\r\n        if (node.is('ruleset')) {\r\n\r\n          node.forEach('block', function (block, i, parent) {\r\n            var previous;\r\n\r\n            // Capture the previous node\r\n            if (parent.content[i - 1]) {\r\n              previous = parent.content[i - 1];\r\n            } else {\r\n              // Else set the block to act as the previous node\r\n              previous = block;\r\n            }\r\n\r\n            // If it's a new line, lets go back up to the selector\r\n            if (previous.is('space') && helpers.hasEOL(previous.content)) {\r\n              space = findNearestReturnSass(p, j);\r\n            }\r\n          });\r\n        }\r\n\r\n        if (space && space.previous) {\r\n          if (space.previous.start.line !== 1) {\r\n            if (parser.options.include && !space.space) {\r\n              result = helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'line': space.previous.end.line + 1,\r\n                'column': 1,\r\n                'message': 'Space expected between blocks',\r\n                'severity': parser.severity\r\n              });\r\n            } else if (!parser.options.include && space.space) {\r\n              result = helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'line': space.previous.end.line + 1,\r\n                'column': 1,\r\n                'message': 'Space not allowed between blocks',\r\n                'severity': parser.severity\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __nested_webpack_require_584309__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_584309__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'extends-before-declarations',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        error;\r\n\r\n    ast.traverseByType('block', function (block) {\r\n      var lastDeclaration = null;\r\n\r\n      block.forEach(function (item, j) {\r\n        if (item.is('include') || item.is('extend')) {\r\n          if (item.contains('atkeyword')) {\r\n            var atkeyword = item.first('atkeyword');\r\n\r\n            if (atkeyword.contains('ident')) {\r\n              var ident = atkeyword.first('ident');\r\n\r\n              if (ident.content === 'extend') {\r\n                if (j > lastDeclaration && lastDeclaration !== null) {\r\n                  error = {\r\n                    'ruleId': parser.rule.name,\r\n                    'line': item.start.line,\r\n                    'column': item.start.column,\r\n                    'message': 'Extends should come before declarations',\r\n                    'severity': parser.severity\r\n                  };\r\n                  result = helpers.addUnique(result, error);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        if (item.is('declaration')) {\r\n          lastDeclaration = j;\r\n        }\r\n      });\r\n      lastDeclaration = null;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __nested_webpack_require_585751__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_585751__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'extends-before-mixins',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('block', function (block) {\r\n      var lastMixin = null;\r\n\r\n      block.forEach(function (item, j) {\r\n        if (item.is('include') || item.is('extend')) {\r\n          if (item.contains('atkeyword')) {\r\n            var atkeyword = item.first('atkeyword');\r\n\r\n            if (atkeyword.contains('ident')) {\r\n              var ident = atkeyword.first('ident');\r\n\r\n              if (ident.content === 'extend') {\r\n                if (j > lastMixin && lastMixin !== null) {\r\n                  result = helpers.addUnique(result, {\r\n                    'ruleId': parser.rule.name,\r\n                    'line': item.start.line,\r\n                    'column': item.start.column,\r\n                    'message': 'Extends should come before mixins',\r\n                    'severity': parser.severity\r\n                  });\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        if (item.is('include')) {\r\n          lastMixin = j;\r\n        }\r\n      });\r\n\r\n      lastMixin = null;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __nested_webpack_require_587099__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_587099__(0);\r\n\r\n/**\r\n * Get the 'last' node of the tree to test for an EOL\r\n *\r\n * @param {Object} node - The node whose last child we want to return\r\n * @returns {Object} The last node\r\n */\r\nvar getLastNode = function getLastNode(node) {\r\n  var last = node.last();\r\n\r\n  return last ? getLastNode(last) : node;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'final-newline',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        last,\r\n        error = {\r\n      'ruleId': parser.rule.name,\r\n      'severity': parser.severity\r\n    };\r\n\r\n    // If the syntax is Sass we must recursively loop to determine the last node.\r\n    // This is not required for SCSS which will always use the last node in the\r\n    // content of the parent stylesheet node\r\n    if (ast.syntax === 'sass') {\r\n      last = getLastNode(ast);\r\n    } else {\r\n      last = ast.content[ast.content.length - 1];\r\n    }\r\n\r\n    if (!last.is('space') && !last.is('declarationDelimiter')) {\r\n      if (parser.options.include) {\r\n        error.line = last.end.line;\r\n        error.column = last.end.column;\r\n        error.message = 'Files must end with a new line';\r\n        result = helpers.addUnique(result, error);\r\n      }\r\n    } else if (last.is('space') || last.is('declarationDelimiter')) {\r\n      if (!helpers.hasEOL(last.content) && parser.options.include) {\r\n        error.line = last.start.line;\r\n        error.column = last.start.column;\r\n        error.message = 'Files must end with a new line';\r\n        result = helpers.addUnique(result, error);\r\n      } else if (helpers.hasEOL(last.content) && !parser.options.include) {\r\n        error.line = last.start.line;\r\n        error.column = last.start.column;\r\n        error.message = 'Files must not end with a new line';\r\n        result = helpers.addUnique(result, error);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __nested_webpack_require_589121__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_589121__(0),\r\n    capitalize = __nested_webpack_require_589121__(4),\r\n    kebabcase = __nested_webpack_require_589121__(5);\r\n\r\n// Our nestable selector types, separated by type for ease of use with rules\r\n// we replace ident with 'selector' for readability'\r\nvar nestableElements = ['selector', 'class', 'id', 'typeSelector', 'parentSelectorExtension'],\r\n    nestableAttributes = ['attributeSelector'],\r\n    nestablePseudo = ['pseudoClass', 'pseudoElement', 'nth', 'nthSelector'];\r\n\r\n/**\r\n * Formats a string from camelCase to hyphens and capitalizes\r\n * @param {string} str - The string to be formatted\r\n * @returns {string} A hyphenated and capitalized string\r\n */\r\nvar formatOutput = function formatOutput(str) {\r\n  return capitalize(kebabcase(str));\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'force-attribute-nesting',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        elements = nestableElements.concat(nestableAttributes, nestablePseudo);\r\n\r\n    ast.traverseByType('ruleset', function (ruleset) {\r\n\r\n      ruleset.forEach('selector', function (selector) {\r\n        var previousVal;\r\n        selector.forEach(function (item) {\r\n          if (previousVal) {\r\n            if (helpers.isNestable(item.type, previousVal.type, elements, nestableAttributes)) {\r\n              helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'line': selector.start.line,\r\n                'column': selector.start.column,\r\n                'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),\r\n                'severity': parser.severity\r\n              });\r\n            }\r\n          }\r\n          previousVal = item;\r\n        });\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __nested_webpack_require_591017__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_591017__(0),\r\n    capitalize = __nested_webpack_require_591017__(4),\r\n    kebabcase = __nested_webpack_require_591017__(5);\r\n\r\n// Our nestable selector types, separated by type for ease of use with rules\r\n// we replace ident with 'selector' for readability'\r\nvar nestableElements = ['selector', 'class', 'id', 'typeSelector', 'parentSelectorExtension'],\r\n    nestableAttributes = ['attributeSelector'],\r\n    nestablePseudo = ['pseudoClass', 'pseudoElement', 'nth', 'nthSelector'];\r\n\r\n/**\r\n * Formats a string from camelCase to hyphens and capitalizes\r\n * @param {string} str - The string to be formatted\r\n * @returns {string} A hyphenated and capitalized string\r\n */\r\nvar formatOutput = function formatOutput(str) {\r\n  return capitalize(kebabcase(str));\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'force-element-nesting',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        elements = nestableElements.concat(nestableAttributes, nestablePseudo);\r\n\r\n    ast.traverseByType('ruleset', function (ruleset) {\r\n      ruleset.forEach(function (selector) {\r\n\r\n        var previousVal;\r\n        selector.forEach(function (item) {\r\n          if (previousVal) {\r\n            if (helpers.isNestable(item.type, previousVal.type, elements, nestableElements)) {\r\n              helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'line': selector.start.line,\r\n                'column': selector.start.column,\r\n                'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),\r\n                'severity': parser.severity\r\n              });\r\n            }\r\n          }\r\n          if (!item.is('space')) {\r\n            previousVal = item;\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __nested_webpack_require_592948__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_592948__(0),\r\n    capitalize = __nested_webpack_require_592948__(4),\r\n    kebabcase = __nested_webpack_require_592948__(5);\r\n\r\n// Our nestable selector types, separated by type for ease of use with rules\r\n// we replace ident with 'selector' for readability'\r\nvar nestableElements = ['selector', 'class', 'id', 'typeSelector', 'parentSelectorExtension'],\r\n    nestableAttributes = ['attributeSelector'],\r\n    nestablePseudo = ['pseudoClass', 'pseudoElement', 'nth', 'nthSelector'];\r\n\r\n/**\r\n * Formats a string from camelCase to hyphens and capitalizes when not\r\n * nth related\r\n * @param {string} str - The string to be formatted\r\n * @returns {string} A hyphenated (and possibly capitalized) string\r\n */\r\nvar formatOutput = function formatOutput(str) {\r\n  str = kebabcase(str);\r\n\r\n  if (str.indexOf('nth') === -1) {\r\n    str = capitalize(str);\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'force-pseudo-nesting',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        elements = nestableElements.concat(nestableAttributes, nestablePseudo);\r\n\r\n    ast.traverseByType('ruleset', function (ruleset) {\r\n\r\n      ruleset.forEach('selector', function (selector) {\r\n        var previousVal;\r\n        selector.forEach(function (item) {\r\n          if (previousVal) {\r\n            if (helpers.isNestable(item.type, previousVal.type, elements, nestablePseudo)) {\r\n              helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'line': selector.start.line,\r\n                'column': selector.start.column,\r\n                'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),\r\n                'severity': parser.severity\r\n              });\r\n            }\r\n          }\r\n          previousVal = item;\r\n        });\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __nested_webpack_require_594948__) {\r\n\r\n\"use strict\";\r\n// Note that this file is nearly identical to mixin-name-format.js, placeholder-name-format.js, and variable-name-format.js\r\n\r\n\r\nvar helpers = __nested_webpack_require_594948__(0);\r\n\r\nvar whitelist = __nested_webpack_require_594948__(95);\r\n\r\nmodule.exports = {\r\n  'name': 'function-name-format',\r\n  'defaults': {\r\n    'allow-leading-underscore': true,\r\n    'convention': 'hyphenatedlowercase',\r\n    'convention-explanation': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('function', function (node) {\r\n      var name = node.first('ident').content,\r\n          strippedName,\r\n          violationMessage = false;\r\n\r\n      // ignore functions on whitelist - css3 transforms\r\n      if (whitelist.indexOf(name) !== -1) {\r\n        return;\r\n      }\r\n\r\n      strippedName = name;\r\n\r\n      if (parser.options['allow-leading-underscore'] && name[0] === '_') {\r\n        strippedName = name.slice(1);\r\n      }\r\n\r\n      switch (parser.options.convention) {\r\n        case 'hyphenatedlowercase':\r\n          if (!helpers.isHyphenatedLowercase(strippedName)) {\r\n            violationMessage = 'Function \\'' + name + '\\' should be written in lowercase with hyphens';\r\n          }\r\n          break;\r\n        case 'camelcase':\r\n          if (!helpers.isCamelCase(strippedName)) {\r\n            violationMessage = 'Function \\'' + name + '\\' should be written in camelCase';\r\n          }\r\n          break;\r\n        case 'pascalcase':\r\n          if (!helpers.isPascalCase(strippedName)) {\r\n            violationMessage = 'Function \\'' + name + '\\' should be written in PascalCase';\r\n          }\r\n          break;\r\n        case 'snakecase':\r\n          if (!helpers.isSnakeCase(strippedName)) {\r\n            violationMessage = 'Function \\'' + name + '\\' should be written in snake_case';\r\n          }\r\n          break;\r\n        case 'strictbem':\r\n          if (!helpers.isStrictBEM(strippedName)) {\r\n            violationMessage = 'Function \\'' + name + '\\' should be written in BEM (Block Element Modifier) format';\r\n          }\r\n          break;\r\n        case 'hyphenatedbem':\r\n          if (!helpers.isHyphenatedBEM(strippedName)) {\r\n            violationMessage = 'Function \\'' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\r\n          }\r\n          break;\r\n        default:\r\n          if (!new RegExp(parser.options.convention).test(strippedName)) {\r\n            violationMessage = 'Function \\'' + name + '\\' should match regular expression /' + parser.options.convention + '/';\r\n\r\n            // convention-message overrides violationMessage\r\n            if (parser.options['convention-explanation']) {\r\n              violationMessage = parser.options['convention-explanation'];\r\n            }\r\n          }\r\n      }\r\n\r\n      if (violationMessage) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': node.start.line,\r\n          'column': node.start.column,\r\n          'message': violationMessage,\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_598141__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_598141__(0);\r\nvar lengths = {\r\n  short: 3,\r\n  long: 6\r\n};\r\nvar canShorten = function canShorten(hex) {\r\n  return hex.length === lengths.long && hex[0] === hex[1] && hex[2] === hex[3] && hex[4] === hex[5];\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'hex-length',\r\n  'defaults': {\r\n    'style': 'short'\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('color', function (value) {\r\n      if (parser.options.style === 'short' && canShorten(value.content)) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': value.start.line,\r\n          'column': value.start.column,\r\n          'message': 'Hex values should use the shorthand format - 3 characters where possible',\r\n          'severity': parser.severity\r\n        });\r\n      } else if (parser.options.style === 'long') {\r\n        if (value.content.length !== lengths.long) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': value.start.line,\r\n            'column': value.start.column,\r\n            'message': 'Hex values should use the long-form format - 6 characters',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __nested_webpack_require_599557__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_599557__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'hex-notation',\r\n  'defaults': {\r\n    'style': 'lowercase'\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('color', function (value) {\r\n      if (value.content.match(/[a-z]/i)) {\r\n        if (parser.options.style === 'lowercase') {\r\n          if (!helpers.isLowerCase(value.content)) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': value.start.line,\r\n              'column': value.start.column,\r\n              'message': 'Hex notation should all be lower case',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        } else if (parser.options.style === 'uppercase') {\r\n          if (!helpers.isUpperCase(value.content)) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': value.start.line,\r\n              'column': value.start.column,\r\n              'message': 'Hex notation should all be upper case',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __nested_webpack_require_600878__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_600878__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'id-name-format',\r\n  'defaults': {\r\n    'allow-leading-underscore': true,\r\n    'convention': 'hyphenatedlowercase',\r\n    'convention-explanation': false,\r\n    'ignore': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('ruleset', function (ruleset) {\r\n      var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, 'id');\r\n\r\n      selectorAndExtensions.forEach(function (node) {\r\n        var name = node.content,\r\n            strippedName,\r\n            violationMessage = false;\r\n\r\n        if (parser.options.ignore.indexOf(name) !== -1) {\r\n          return;\r\n        }\r\n\r\n        strippedName = name;\r\n\r\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\r\n          strippedName = name.slice(1);\r\n        }\r\n\r\n        switch (parser.options.convention) {\r\n          case 'hyphenatedlowercase':\r\n            if (!helpers.isHyphenatedLowercase(strippedName)) {\r\n              violationMessage = 'ID \\'#' + name + '\\' should be written in lowercase with hyphens';\r\n            }\r\n            break;\r\n          case 'camelcase':\r\n            if (!helpers.isCamelCase(strippedName)) {\r\n              violationMessage = 'ID \\'#' + name + '\\' should be written in camelCase';\r\n            }\r\n            break;\r\n          case 'pascalcase':\r\n            if (!helpers.isPascalCase(strippedName)) {\r\n              violationMessage = 'ID \\'#' + name + '\\' should be written in PascalCase';\r\n            }\r\n            break;\r\n          case 'snakecase':\r\n            if (!helpers.isSnakeCase(strippedName)) {\r\n              violationMessage = 'ID \\'#' + name + '\\' should be written in snake_case';\r\n            }\r\n            break;\r\n          default:\r\n            if (!new RegExp(parser.options.convention).test(strippedName)) {\r\n              violationMessage = 'ID \\'#' + name + '\\' should match regular expression /' + parser.options.convention + '/';\r\n\r\n              // convention-message overrides violationMessage\r\n              if (parser.options['convention-explanation']) {\r\n                violationMessage = parser.options['convention-explanation'];\r\n              }\r\n            }\r\n        }\r\n\r\n        if (violationMessage) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': violationMessage,\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_603603__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_603603__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'indentation',\r\n  'defaults': {\r\n    'size': 2\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        inAtRule = false,\r\n        inProps = false,\r\n        inBlock = false,\r\n        lintSize = parser.options.size,\r\n        lintType = 'space',\r\n        plural = '',\r\n        detected = [lintType];\r\n\r\n    // Prepare to check for mixed spaces or tabs depending on what the user has specified\r\n    if (parser.options.size === 'tab') {\r\n      lintSize = 1;\r\n      lintType = 'tab';\r\n      detected[0] = lintType;\r\n    }\r\n\r\n    var processNode = function processNode(node, level) {\r\n      var i, n, prevNode, nextNode, sassNextNode, reportNode, reportCondition, space, spaceLength, newlineLength, spaceCount, tabCount, mixedWarning;\r\n\r\n      level = level || 0;\r\n\r\n      if (node.is('braces')) {\r\n        return;\r\n      }\r\n\r\n      for (i = 0; i < node.length; i++) {\r\n        n = node.get(i);\r\n        prevNode = node.get(i - 1);\r\n        nextNode = node.get(i + 1) || false;\r\n        // Due to the Sass structure in gonzales we sometimes need to check 2 ahead\r\n        sassNextNode = node.get(i + 2) || false;\r\n        reportNode = null;\r\n\r\n        if (!n) {\r\n          continue;\r\n        }\r\n\r\n        if (n.syntax === 'scss') {\r\n          if (n.type === 'space') {\r\n\r\n            // Test for CRLF first, since it includes LF\r\n            space = n.content.lastIndexOf('\\r\\n');\r\n            newlineLength = 2;\r\n\r\n            if (space === -1) {\r\n              // Test for LF\r\n              space = n.content.lastIndexOf('\\n');\r\n              newlineLength = 1;\r\n            }\r\n\r\n            if (space >= 0) {\r\n              // Check how many spaces or tabs we have and set our plural character if necessary for\r\n              // our lint reporting message\r\n              spaceLength = n.content.slice(space + newlineLength).length;\r\n              spaceCount = n.content.slice(space + newlineLength).match(/ /g);\r\n              tabCount = n.content.slice(space + newlineLength).match(/\\t/g);\r\n              plural = level > 1 ? 's' : '';\r\n              reportNode = nextNode;\r\n              reportCondition = i !== node.length - 1;\r\n            }\r\n          }\r\n        } else if (n.syntax === 'sass') {\r\n          if (n.is('declarationDelimiter') || helpers.isNewLine(n)) {\r\n            // Due to the way gonzales handles line endings in Sass we don't care if it's CRLF or just LF\r\n            if (nextNode && nextNode.is('space') && nextNode.content.indexOf('\\n') === -1) {\r\n              spaceLength = nextNode.content.length;\r\n              spaceCount = nextNode.content.match(/ /g);\r\n              tabCount = nextNode.content.match(/\\t/g);\r\n              plural = level > 1 ? 's' : '';\r\n\r\n              // if we're at the end of a block we want to drop the level here for Sass\r\n              if (!node.get(i + 2)) {\r\n                level--;\r\n              }\r\n\r\n              reportNode = sassNextNode;\r\n              reportCondition = true;\r\n            }\r\n          }\r\n          // Check all the spaces in Sass that aren't newlines\r\n          else if (helpers.isSpace(n)) {\r\n              // This is a special condition for the first property in a block with Sass as it usually\r\n              // doesn't have a previous node before the space appears so we need to check this is\r\n              // valid and then we can rely on the declarationDelimiter check above.\r\n              if (inBlock && (!prevNode || prevNode.is('space'))) {\r\n                inBlock = false;\r\n                spaceLength = n.content.length;\r\n                spaceCount = n.content.match(/ /g);\r\n                tabCount = n.content.match(/\\t/g);\r\n                plural = level > 1 ? 's' : '';\r\n                reportNode = nextNode;\r\n                reportCondition = true;\r\n              }\r\n              // A extra check for tabs when using spaces as single tab characters aren't highlighted\r\n              // as mixed spaces and tabs without this. Spaces on the other hand are fine. Gonzales\r\n              // reports them a little differently.\r\n              else if (n.type === 'space' && lintType === 'space') {\r\n                  tabCount = n.content.match(/\\t/g);\r\n                  reportNode = nextNode;\r\n                  // we dont want to check the lint levels here as it could be a tab between a prop and\r\n                  // value, totally unrealistic I know but we still want to report it.\r\n                  reportCondition = false;\r\n                }\r\n            }\r\n        }\r\n        if (reportNode) {\r\n          // if we've encountered a space check if we have before if not save a reference\r\n          if (spaceCount !== null && detected.indexOf('space') === -1) {\r\n            detected.push('space');\r\n          }\r\n\r\n          // if we've encountered a tab check if we have before if not save a reference\r\n          if (tabCount !== null && detected.indexOf('tab') === -1) {\r\n            detected.push('tab');\r\n          }\r\n\r\n          if (detected.length > 1) {\r\n            // Indicates we've told the user about mixed tabs and spaces in their file\r\n            mixedWarning = true;\r\n            // Remove the last detected type from our detected array,\r\n            // if we encounter a mix again we'll output again but all the while keep a reference\r\n            // to the first space character (tab or space) that we encountered so as to be\r\n            // consistent with our warnings\r\n            detected.pop();\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': reportNode.start.line,\r\n              'column': reportNode.start.column,\r\n              'message': 'Mixed tabs and spaces',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n          if (reportCondition && !mixedWarning && spaceLength / lintSize !== level) {\r\n            // Check if expected indentation matches what it should be\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': reportNode.start.line,\r\n              'column': reportNode.start.column,\r\n              'message': 'Expected indentation of ' + level * lintSize + ' ' + lintType + plural + ' but found ' + spaceLength + '.',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n          mixedWarning = false;\r\n        }\r\n        // if we're in an atrule make we need to possibly handle multiline arguments\r\n        if (n.is('atrule') && n.contains('block')) {\r\n          inAtRule = true;\r\n          inBlock = false;\r\n        }\r\n\r\n        // if a delimeter is encountered we check if it's directly after a parenthesis node\r\n        // if it is we know next node will be the same level of indentation\r\n        if (n.is('operator')) {\r\n          if (n.content === ',' && prevNode.is('parentheses') && helpers.isNewLine(nextNode)) {\r\n            if (inAtRule && !inProps) {\r\n              level++;\r\n              inProps = true;\r\n            } else if (!inProps) {\r\n              level--;\r\n            }\r\n          }\r\n        }\r\n\r\n        // if a block node is encountered we first check to see if it's within an include/function\r\n        // by checking if the node also contains arguments, if it does we skip the block as we add a level\r\n        // for arguments anyway. If not the the block is a usual ruleset block and should be treated accordingly\r\n        // The other checks are kept from 1.0 and work for their respective types.\r\n        if (n.is('block') && !node.contains('arguments') || n.is('arguments') || n.is('parentheses') && !node.is('atrule')) {\r\n          level++;\r\n        }\r\n\r\n        if (n.is('block')) {\r\n          inAtRule = false;\r\n          inProps = false;\r\n          inBlock = true;\r\n        }\r\n        processNode(n, level);\r\n      }\r\n    };\r\n\r\n    processNode(ast);\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __nested_webpack_require_611635__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_611635__(0);\r\n\r\nvar leadingZeroRegex = /^0\\.\\d+$/,\r\n    noLeadingZeroRegex = /^\\.\\d+$/;\r\n\r\nmodule.exports = {\r\n  'name': 'leading-zero',\r\n  'defaults': {\r\n    'include': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('number', function (num) {\r\n      if (num.content.match(/^-?(0?\\.\\d+)/)) {\r\n        if (num.content.match(leadingZeroRegex)) {\r\n          if (!parser.options.include) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': num.start.line,\r\n              'column': num.start.column,\r\n              'message': 'Don\\'t include leading zeros on numbers',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n        if (num.content.match(noLeadingZeroRegex)) {\r\n          if (parser.options.include) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': num.start.line,\r\n              'column': num.start.column - 1,\r\n              'message': 'Include leading zeros on numbers',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __nested_webpack_require_613002__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_613002__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'max-file-line-count',\r\n  'defaults': {\r\n    length: 300\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    if (ast.end.line > parser.options.length) {\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': ast.end.line,\r\n        'column': 0,\r\n        'message': 'This file has ' + ast.end.line + ' lines, which exceeds the maximum of ' + parser.options.length + ' lines allowed.',\r\n        'severity': parser.severity\r\n      });\r\n    }\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_613714__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_613714__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'max-line-length',\r\n  'defaults': {\r\n    length: 80\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('space', function (space) {\r\n      var lineLength = 0;\r\n      if (helpers.hasEOL(space.content)) {\r\n        lineLength = space.start.column - 1;\r\n      }\r\n\r\n      if (lineLength > parser.options.length) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'severity': parser.severity,\r\n          'line': space.start.line,\r\n          'column': 0,\r\n          'message': 'line ' + space.start.line + ' exceeds the maximum line length of ' + parser.options.length\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __nested_webpack_require_614604__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_614604__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'mixin-name-format',\r\n  'defaults': {\r\n    'allow-leading-underscore': true,\r\n    'convention': 'hyphenatedlowercase',\r\n    'convention-explanation': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['mixin', 'include'], function (node) {\r\n      var name,\r\n          strippedName,\r\n          violationMessage = false;\r\n\r\n      if (node.is('mixin')) {\r\n        if (node.contains('ident')) {\r\n          name = node.first('ident').content;\r\n        }\r\n      } else {\r\n        // We're not linting extends here\r\n        if (node.contains('atkeyword')) {\r\n          if (node.first('atkeyword').contains('ident')) {\r\n            if (node.first('atkeyword').first('ident').content === 'extend') {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (node.contains('ident')) {\r\n          name = node.first('ident').content;\r\n        }\r\n      }\r\n\r\n      if (name) {\r\n        strippedName = name;\r\n\r\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\r\n          strippedName = name.slice(1);\r\n        }\r\n\r\n        switch (parser.options.convention) {\r\n          case 'hyphenatedlowercase':\r\n            if (!helpers.isHyphenatedLowercase(strippedName)) {\r\n              violationMessage = 'Mixin \\'' + name + '\\' should be written in lowercase with hyphens';\r\n            }\r\n            break;\r\n          case 'camelcase':\r\n            if (!helpers.isCamelCase(strippedName)) {\r\n              violationMessage = 'Mixin \\'' + name + '\\' should be written in camelCase';\r\n            }\r\n            break;\r\n          case 'pascalcase':\r\n            if (!helpers.isPascalCase(strippedName)) {\r\n              violationMessage = 'Mixin \\'' + name + '\\' should be written in PascalCase';\r\n            }\r\n            break;\r\n          case 'snakecase':\r\n            if (!helpers.isSnakeCase(strippedName)) {\r\n              violationMessage = 'Mixin \\'' + name + '\\' should be written in snake_case';\r\n            }\r\n            break;\r\n          case 'strictbem':\r\n            if (!helpers.isStrictBEM(strippedName)) {\r\n              violationMessage = 'Mixin \\'' + name + '\\' should be written in BEM (Block Element Modifier) format';\r\n            }\r\n            break;\r\n          case 'hyphenatedbem':\r\n            if (!helpers.isHyphenatedBEM(strippedName)) {\r\n              violationMessage = 'Mixin \\'' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\r\n            }\r\n            break;\r\n          default:\r\n            if (!new RegExp(parser.options.convention).test(strippedName)) {\r\n              violationMessage = 'Mixin \\'' + name + '\\' should match regular expression /' + parser.options.convention + '/';\r\n\r\n              // convention-message overrides violationMessage\r\n              if (parser.options['convention-explanation']) {\r\n                violationMessage = parser.options['convention-explanation'];\r\n              }\r\n            }\r\n        }\r\n\r\n        if (violationMessage) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': violationMessage,\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n      return true;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __nested_webpack_require_618156__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_618156__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'mixins-before-declarations',\r\n  'defaults': {\r\n    'exclude': ['breakpoint', 'mq']\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        error;\r\n\r\n    ast.traverseByType('include', function (node, i, parent) {\r\n      var depth = 0,\r\n          declarationCount = [depth];\r\n\r\n      parent.forEach(function (item) {\r\n        if (item.is('ruleset')) {\r\n          depth++;\r\n          declarationCount[depth] = 0;\r\n        } else if (item.is('declaration')) {\r\n          if (item.first().is('property')) {\r\n            var prop = item.first();\r\n\r\n            if (prop.first().is('ident')) {\r\n              declarationCount[depth]++;\r\n            }\r\n          }\r\n        } else if (item.is('include')) {\r\n          item.forEach('ident', function (name) {\r\n            if (parser.options.exclude.indexOf(name.content) === -1 && declarationCount[depth] > 0) {\r\n              error = {\r\n                'ruleId': parser.rule.name,\r\n                'line': item.start.line,\r\n                'column': item.start.column,\r\n                'message': 'Mixins should come before declarations',\r\n                'severity': parser.severity\r\n              };\r\n              result = helpers.addUnique(result, error);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __nested_webpack_require_619647__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_619647__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'nesting-depth',\r\n  'defaults': {\r\n    'max-depth': 2\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        nodes = {},\r\n        depth = 0;\r\n\r\n    var recursiveSearch = function recursiveSearch(node) {\r\n      if (node.contains('block')) {\r\n        node.forEach('block', function (block) {\r\n          if (block.contains('ruleset')) {\r\n            depth++;\r\n            block.forEach('ruleset', function (ruleset) {\r\n              var selector = ruleset.first('selector');\r\n\r\n              if (depth > parser.options['max-depth']) {\r\n                var nodeLineColumn = selector.start.line + ':' + selector.start.column;\r\n\r\n                if (nodes[nodeLineColumn]) {\r\n                  if (depth > nodes[nodeLineColumn].depth) {\r\n                    nodes[nodeLineColumn].depth = depth;\r\n                  }\r\n                } else {\r\n                  nodes[nodeLineColumn] = {\r\n                    'line': selector.start.line,\r\n                    'column': selector.start.column,\r\n                    'depth': depth\r\n                  };\r\n                }\r\n              } else {\r\n                recursiveSearch(ruleset);\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n      depth--;\r\n    };\r\n\r\n    ast.traverseByType('selector', function (selector, i, parent) {\r\n      recursiveSearch(parent);\r\n      depth = 0;\r\n    });\r\n\r\n    Object.keys(nodes).forEach(function (node) {\r\n      node = nodes[node];\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': node.line,\r\n        'column': node.column,\r\n        'message': 'Nesting depth ' + node.depth + ' greater than max of ' + parser.options['max-depth'],\r\n        'severity': parser.severity\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __nested_webpack_require_621613__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_621613__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-attribute-selectors',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('attributeSelector', function (item) {\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': item.start.line,\r\n        'column': item.start.column,\r\n        'message': 'Attribute selectors are not allowed',\r\n        'severity': parser.severity\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __nested_webpack_require_622262__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_622262__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-color-hex',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('color', function (value) {\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': value.start.line,\r\n        'column': value.start.column,\r\n        'message': 'Hexadecimal colors should not be used',\r\n        'severity': parser.severity\r\n      });\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __nested_webpack_require_622892__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_622892__(0);\r\n\r\nvar cssColors = __nested_webpack_require_622892__(7);\r\n\r\n/**\r\n * Checks if a node's parent is a valid type as we dont want to apply\r\n * this rule to function names or variable names\r\n *\r\n * @param {Object} node - The parent node to test\r\n * @returns {boolean} Whether the node is a valid type or not\r\n */\r\nvar checkValidParentType = function checkValidParentType(node) {\r\n  if (node) {\r\n    return node.type === 'function' || node.type === 'variable';\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'no-color-keywords',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('value', function (node) {\r\n      node.traverse(function (elem, i, parent) {\r\n        if (elem.type === 'ident' && !checkValidParentType(parent)) {\r\n          var index = cssColors.indexOf(elem.content.toLowerCase());\r\n\r\n          if (index !== -1) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': elem.start.line,\r\n              'column': elem.start.column,\r\n              'message': 'Color \\'' + elem.content + '\\' should be written in its hexadecimal form #' + cssColors[index + 1],\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __nested_webpack_require_624354__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_624354__(0);\r\n\r\nvar colorFunctions = ['rgb', 'rgba', 'hsl', 'hsla'],\r\n    cssColors = __nested_webpack_require_624354__(7);\r\n\r\n/**\r\n * Returns a copy of the colour functions array\r\n *\r\n * @param {Array} colorFunctionsArr - The color functions array we wish to clone\r\n * @returns {Array} A copy of the color functions array.\r\n */\r\nvar getColorFunctionsCopy = function getColorFunctionsCopy(colorFunctionsArr) {\r\n  return colorFunctionsArr.slice();\r\n};\r\n\r\n/**\r\n * Checks if the next node along is an operator of type ':'\r\n *\r\n * @param {Object} parent - The parent node\r\n * @param {number} i - The current child position in the parent node\r\n * @returns {boolean} If the sibling node is the correct type of operator\r\n */\r\nvar checkNextIsOperator = function checkNextIsOperator(parent, i) {\r\n  var next = parent.content[i + 1] && parent.content[i + 1].type === 'operator' && parent.content[i + 1].content === ':';\r\n  var spacedNext = parent.content[i + 2] && parent.content[i + 2].type === 'operator' && parent.content[i + 2].content === ':';\r\n\r\n  return next || spacedNext;\r\n};\r\n\r\n/**\r\n * Check nested function arguments for colors/idents or further nested functions\r\n *\r\n * @param {Object} node - The node we're checking\r\n * @returns {boolean} Whether the node matches the specified types\r\n */\r\nvar checkForNestedFuncArgs = function checkForNestedFuncArgs(node) {\r\n  return node.type === 'color' || node.type === 'ident' || node.type === 'function';\r\n};\r\n\r\n/**\r\n * Check if the value is a color literal\r\n *\r\n * @param {Object} node - The node we're checking\r\n * @param {Array} validColorFunctions - The array of valid color function types to check against\r\n * @returns {boolean} Whether the node matches the specified types\r\n */\r\nvar checkIsLiteral = function checkIsLiteral(node, validColorFunctions) {\r\n  return cssColors.indexOf(node.content) !== -1 || helpers.isValidHex(node.content) || validColorFunctions.indexOf(node.content) !== -1;\r\n};\r\n\r\n/**\r\n * Checks the see if the node type is a hex value if so return the correct prefix\r\n *\r\n * @param {String} nodeType - The node type identifier\r\n * @returns {String} Either a '#' or an empty string\r\n */\r\nvar checkHexPrefix = function checkHexPrefix(nodeType) {\r\n  return nodeType === 'color' ? '#' : '';\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'no-color-literals',\r\n  'defaults': {\r\n    'allow-map-identifiers': true,\r\n    'allow-rgba': false,\r\n    'allow-variable-identifiers': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        validColorFunctions = getColorFunctionsCopy(colorFunctions);\r\n\r\n    if (parser.options['allow-rgba'] && validColorFunctions.indexOf('rgba') !== -1) {\r\n      validColorFunctions.splice(validColorFunctions.indexOf('rgba'), 1);\r\n    }\r\n\r\n    ast.traverseByTypes(['value', 'variable'], function (node, i, parent) {\r\n\r\n      // If we don't literals as variable names then check each variable name\r\n      if (node.is('variable') && !parser.options['allow-variable-identifiers']) {\r\n        if (cssColors.indexOf(node.content[0].content) !== -1) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': 'Color literals should not be used as variable names',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n      // check the value nodes\r\n      else if (node.is('value')) {\r\n          node.forEach(function (valElem) {\r\n            var declarationType = parent.content[0].content[0].type;\r\n            // check type is color, content isn't a css color literal\r\n            if (valElem.type === 'color' || cssColors.indexOf(valElem.content) !== -1) {\r\n              if (declarationType === 'ident') {\r\n                result = helpers.addUnique(result, {\r\n                  'ruleId': parser.rule.name,\r\n                  'line': valElem.start.line,\r\n                  'column': valElem.start.column,\r\n                  'message': 'Color literals such as \\'' + checkHexPrefix(valElem.type) + valElem.content + '\\' should only be used in variable declarations',\r\n                  'severity': parser.severity\r\n                });\r\n              }\r\n            }\r\n\r\n            // if not a color value or a variable then check if it's a function\r\n            else if (valElem.type === 'function') {\r\n                var funcType = valElem.content[0].content;\r\n\r\n                // check it's not a blacklisted color function and even if it is that it's not assigned to a variable\r\n                if (validColorFunctions.indexOf(funcType) !== -1 && declarationType !== 'variable') {\r\n                  result = helpers.addUnique(result, {\r\n                    'ruleId': parser.rule.name,\r\n                    'line': valElem.start.line,\r\n                    'column': valElem.start.column,\r\n                    'message': 'Color functions such as \\'' + funcType + '\\' should only be used in variable declarations',\r\n                    'severity': parser.severity\r\n                  });\r\n                }\r\n\r\n                // if rgba usage is allowed we need to make sure only variables are being passed to it.\r\n                else if (parser.options['allow-rgba'] && funcType === 'rgba' && valElem.content[1].content[0].type !== 'variable' && declarationType !== 'variable') {\r\n                    result = helpers.addUnique(result, {\r\n                      'ruleId': parser.rule.name,\r\n                      'line': valElem.start.line,\r\n                      'column': valElem.start.column,\r\n                      'message': 'A color in variable form must be passed to rgba, literals are restricted',\r\n                      'severity': parser.severity\r\n                    });\r\n                  }\r\n\r\n                  // if a non color function we should check its arguments\r\n                  else {\r\n                      valElem.content.forEach(function (funcContent) {\r\n                        if (funcContent.type === 'arguments') {\r\n                          funcContent.forEach(function (funcArgs) {\r\n                            // if the arguments are not functions themselves\r\n                            if (funcArgs.type !== 'function') {\r\n                              // check if the argument types are therefore color literals\r\n                              if ((funcArgs.type === 'color' || funcArgs.type === 'ident') && (cssColors.indexOf(funcArgs.content) !== -1 || helpers.isValidHex(funcArgs.content))) {\r\n                                result = helpers.addUnique(result, {\r\n                                  'ruleId': parser.rule.name,\r\n                                  'line': funcArgs.start.line,\r\n                                  'column': funcArgs.start.column,\r\n                                  'message': 'Color literals such as \\'' + checkHexPrefix(funcArgs.type) + funcArgs.content + '\\' should not be passed to functions, use variables',\r\n                                  'severity': parser.severity\r\n                                });\r\n                              }\r\n                            }\r\n\r\n                            // if the argument is a function itself\r\n                            else {\r\n                                // loop its arguments\r\n                                funcArgs.forEach(function (nestedFuncArgs) {\r\n                                  // check again for color literals or blacklisted color functions\r\n                                  if (checkForNestedFuncArgs(nestedFuncArgs) && checkIsLiteral(nestedFuncArgs, validColorFunctions)) {\r\n                                    result = helpers.addUnique(result, {\r\n                                      'ruleId': parser.rule.name,\r\n                                      'line': nestedFuncArgs.start.line,\r\n                                      'column': nestedFuncArgs.start.column,\r\n                                      'message': 'Color functions such as \\'' + nestedFuncArgs.content + '\\' should not be passed to functions, use variables',\r\n                                      'severity': parser.severity\r\n                                    });\r\n                                  }\r\n                                });\r\n                              }\r\n                          });\r\n                        }\r\n                      });\r\n                    }\r\n              }\r\n\r\n              // if not allowing literals as map identifiers check to see if the property names\r\n              // are the same as color literals - this is bad\r\n              else if (valElem.type === 'parentheses' && !parser.options['allow-map-identifiers']) {\r\n                  valElem.traverse(function (mapVals, idx, mapValsParent) {\r\n                    // check if the parent is a variable to allow variables named after CSS colors, e.g. `$black`\r\n                    if (mapVals.type === 'ident' && checkNextIsOperator(mapValsParent, idx) && cssColors.indexOf(mapVals.content) !== -1) {\r\n                      result = helpers.addUnique(result, {\r\n                        'ruleId': parser.rule.name,\r\n                        'line': mapVals.start.line,\r\n                        'column': mapVals.start.column,\r\n                        'message': 'Color literals should not be used as map identifiers',\r\n                        'severity': parser.severity\r\n                      });\r\n                    }\r\n                  });\r\n                }\r\n          });\r\n        }\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_633966__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_633966__(0);\r\n\r\n/**\r\n * Check if it's an exception (combinator or a parent selector before or after a space)\r\n *\r\n * @param {Object} node - The node to check\r\n * @param {Object} next - The next node\r\n * @param {Object} previous - The previous node\r\n * @returns {Boolean} True if exception\r\n */\r\nvar isException = function isException(node, next, previous) {\r\n  if (node.is('space')) {\r\n    if (next && next.is('combinator') || next.is('parentSelector')) {\r\n      return true;\r\n    }\r\n\r\n    if (previous && previous.is('combinator') || previous.is('parentSelector')) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'no-combinators',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('selector', function (selector) {\r\n      selector.forEach(function (item, i) {\r\n        var previous = selector.content[i - 1] || false,\r\n            next = selector.content[i + 1] || false;\r\n\r\n        if (isException(item, next, previous)) {\r\n          return false;\r\n        }\r\n\r\n        if (item.is('combinator') || item.is('space')) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': item.start.line,\r\n            'column': item.start.column,\r\n            'message': 'Combinators are not allowed',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n        return false;\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __nested_webpack_require_635582__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_635582__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-css-comments',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('multilineComment', function (node) {\r\n      if (node.content.charAt(0) !== '!') {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': node.start.line,\r\n          'column': node.start.column,\r\n          'message': 'Multiline style comments should not be used',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports, __nested_webpack_require_636297__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_636297__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-debug',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('atkeyword', function (keyword) {\r\n      keyword.traverse(function (item) {\r\n        if (item.content === 'debug') {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': item.start.line,\r\n            'column': item.start.column,\r\n            'message': '@debug not allowed',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __nested_webpack_require_637043__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_637043__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-disallowed-properties',\r\n  'defaults': {\r\n    'properties': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('property', function (node) {\r\n      var first = node.first();\r\n      if (!first.is('ident') || parser.options.properties.indexOf(first.content) === -1) {\r\n        return;\r\n      }\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': node.start.line,\r\n        'column': node.start.column,\r\n        'message': 'Property `' + first.content + '` should not be used',\r\n        'severity': parser.severity\r\n      });\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __nested_webpack_require_637876__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_637876__(0);\r\nvar selectorHelpers = __nested_webpack_require_637876__(1);\r\n\r\nmodule.exports = {\r\n  'name': 'no-duplicate-properties',\r\n  'defaults': {\r\n    'exclude': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('block', function (block) {\r\n      var properties = [],\r\n          items = [],\r\n          warnMessage = false;\r\n\r\n      block.eachFor('declaration', function (declaration) {\r\n        items.push(declaration);\r\n      });\r\n\r\n      items.reverse();\r\n\r\n      items.forEach(function (declaration) {\r\n        warnMessage = false;\r\n\r\n        declaration.eachFor('property', function (item) {\r\n          var property = '';\r\n\r\n          // Check if declaration is actually a variable declaration\r\n          if (item.content[0] && item.content[0].is('variable')) {\r\n            return;\r\n          }\r\n\r\n          item.forEach(function (subItem) {\r\n            // Although not a selector the method here helps us construct the proper property name\r\n            // taking into account any interpolation etc\r\n            property += selectorHelpers.constructSelector(subItem);\r\n          });\r\n\r\n          if (properties.indexOf(property) !== -1 && properties.length >= 1) {\r\n            if (parser.options.exclude.indexOf(property) !== -1 && properties[properties.length - 1] !== property) {\r\n              warnMessage = 'Excluded duplicate properties must directly follow each other.';\r\n            } else if (parser.options.exclude.indexOf(property) === -1) {\r\n              warnMessage = 'Duplicate properties are not allowed within a block';\r\n            }\r\n          }\r\n\r\n          properties.push(property);\r\n\r\n          if (warnMessage) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': item.start.line,\r\n              'column': item.start.column,\r\n              'message': warnMessage,\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 49 */\r\n/***/ (function(module, exports, __nested_webpack_require_640041__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_640041__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-empty-rulesets',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('block', function (block) {\r\n      var nonSpaceCount = 0,\r\n          empty = false;\r\n\r\n      if (block.content.length === 0) {\r\n        empty = true;\r\n      } else {\r\n        block.traverse(function (item) {\r\n          if (!helpers.isEqual(block, item)) {\r\n            if (item.type !== 'space') {\r\n              nonSpaceCount++;\r\n            }\r\n          }\r\n        });\r\n        if (nonSpaceCount === 0) {\r\n          empty = true;\r\n        }\r\n      }\r\n\r\n      if (empty) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'severity': parser.severity,\r\n          'line': block.start.line,\r\n          'column': block.start.column,\r\n          'message': 'No empty blocks allowed'\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 50 */\r\n/***/ (function(module, exports, __nested_webpack_require_641133__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_641133__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-extends',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('atkeyword', function (keyword) {\r\n      keyword.traverse(function (item) {\r\n        if (item.content === 'extend') {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': item.start.line,\r\n            'column': item.start.column,\r\n            'message': '@extend not allowed',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 51 */\r\n/***/ (function(module, exports, __nested_webpack_require_641883__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_641883__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-ids',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('id', function (id) {\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': id.start.line,\r\n        'column': id.start.column,\r\n        'message': 'ID selectors not allowed',\r\n        'severity': parser.severity\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 52 */\r\n/***/ (function(module, exports, __nested_webpack_require_642484__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_642484__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-important',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('important', function (item) {\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': item.start.line,\r\n        'column': item.start.column,\r\n        'message': '!important not allowed',\r\n        'severity': parser.severity\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 53 */\r\n/***/ (function(module, exports, __nested_webpack_require_643102__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_643102__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-invalid-hex',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('color', function (value) {\r\n      if (!helpers.isValidHex(value.content)) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': value.start.line,\r\n          'column': value.start.column,\r\n          'message': 'Hexadecimal values must be a valid format',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 54 */\r\n/***/ (function(module, exports, __nested_webpack_require_643810__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_643810__(0),\r\n    selectorHelpers = __nested_webpack_require_643810__(1);\r\n\r\nvar mergeableNodes = ['atrule', 'include', 'ruleset'],\r\n    validAtRules = ['media'],\r\n    curLevel = 0,\r\n    curSelector = [],\r\n    parentSelector = [],\r\n    selectorList = [],\r\n    syntax = '';\r\n\r\n/**\r\n * Traverses a block and calls our callback function for each block encountered\r\n *\r\n * @param {object} block - The current node / part of our selector\r\n * @param {object} cb - The callback function we wish to apply to each block\r\n * @returns {undefined}\r\n */\r\nvar traverseBlock = function traverseBlock(block, cb) {\r\n  block.forEach(function (contentItem) {\r\n    cb(contentItem);\r\n  });\r\n};\r\n\r\n/**\r\n * Traverses a block and calls our callback function for each block encountered\r\n *\r\n * @param {string} ruleSet - The current selector\r\n * @param {boolean} isAtRule - Whether the ruleSet is an atRule\r\n * @param {string} line - The line that the ruleset starts\r\n * @param {string} col - The column that the ruleset starts\r\n * @returns {undefined}\r\n */\r\nvar updateList = function updateList(ruleSet, isAtRule, line, col) {\r\n  parentSelector[curLevel] = ruleSet;\r\n  curSelector = {\r\n    selector: helpers.stripLastSpace(parentSelector.join('')),\r\n    line: line,\r\n    column: col\r\n  };\r\n  if (!isAtRule) {\r\n    selectorList.push(curSelector);\r\n  }\r\n};\r\n\r\n/**\r\n * Checks a rulesets contents for selectors and calls our consstructSelector method\r\n *\r\n * @param {object} ruleNode - The current node / part of our selector\r\n * @returns {undefined}\r\n */\r\nvar checkRuleset = function checkRuleset(ruleNode) {\r\n  var ruleSet = '';\r\n  ruleNode.forEach(function (ruleNodeItem) {\r\n    if (!ruleNodeItem.is('block')) {\r\n      if (ruleNodeItem.is('selector')) {\r\n        ruleNodeItem.forEach(function (selectorContent) {\r\n          ruleSet += selectorHelpers.constructSelector(selectorContent);\r\n        });\r\n      } else if (ruleNodeItem.is('delimiter') || ruleNodeItem.is('space')) {\r\n        ruleSet += selectorHelpers.constructSelector(ruleNodeItem);\r\n      }\r\n    }\r\n  });\r\n  if (ruleSet !== '') {\r\n    updateList(ruleSet, false, ruleNode.start.line, ruleNode.start.column);\r\n  }\r\n};\r\n\r\n/**\r\n * Checks an atRule contents for selectors and calls our consstructSelector method\r\n *\r\n * @param {object} atRule - The current node / atRule part of our selector\r\n * @returns {undefined}\r\n */\r\nvar checkAtRule = function checkAtRule(atRule) {\r\n  var test = '';\r\n  atRule.forEach(function (atRuleItem) {\r\n    if (!atRuleItem.is('block')) {\r\n      test += selectorHelpers.constructSelector(atRuleItem);\r\n    }\r\n  });\r\n  updateList(test, true, atRule.start.line, atRule.start.column);\r\n};\r\n\r\n/**\r\n * Checks an atRule to see if if it's part of our mergeable at rule list.\r\n * It also checks for Sass syntax as gonzales currently has issues with the syntax\r\n *\r\n * @param {object} node - The current node / atRule part of our selector\r\n * @returns {boolean} Whether this atRule should be merged or not\r\n */\r\nvar isMergeableAtRule = function isMergeableAtRule(node) {\r\n  var isMergeable = false;\r\n  node.forEach(function (item) {\r\n    // TODO Check back when Gonzales updates to fix this\r\n    // Gonzales has issues with nest levels in media queries :(\r\n    if (item.is('atkeyword') && validAtRules.indexOf(item.first('ident').content) !== -1 && syntax !== 'sass') {\r\n      isMergeable = true;\r\n    }\r\n  });\r\n\r\n  return isMergeable;\r\n};\r\n\r\n/**\r\n * Checks if a node contains a block and if so calls our traverseBlock method. Also\r\n * handles our current level counter.\r\n *\r\n * @param {object} node - The current node / atRule part of our selector\r\n * @param {object} cb - The callback function we wish to pass through\r\n * @returns {undefined}\r\n */\r\nvar checkForBlock = function checkForBlock(node, cb) {\r\n  if (node.contains('block')) {\r\n    curLevel += 1;\r\n    node.forEach('block', function (block) {\r\n      traverseBlock(block.content, cb);\r\n    });\r\n    curLevel -= 1;\r\n    parentSelector.pop();\r\n  }\r\n};\r\n\r\n/**\r\n * Traverses a node and checks for rulesets and at rules and then fires off to the\r\n * respective method for them to be handled\r\n *\r\n * @param {object} node - The current node / atRule part of our selector\r\n * @returns {undefined}\r\n */\r\nvar traverseNode = function traverseNode(node) {\r\n  if (mergeableNodes.indexOf(node.type) !== -1) {\r\n    if (node.is('ruleset')) {\r\n      checkRuleset(node);\r\n      checkForBlock(node, traverseNode);\r\n    } else if (node.is('atrule')) {\r\n      if (isMergeableAtRule(node)) {\r\n        checkAtRule(node);\r\n        checkForBlock(node, traverseNode);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Checks our selector list for mergeable selectors and reports errors where needed\r\n *\r\n * @param {object} parser - The parser object\r\n * @returns {array} Array of result objects\r\n */\r\nvar checkMergeable = function checkMergeable(parser) {\r\n  var result = [];\r\n  selectorList.forEach(function (item, index, arr) {\r\n    var pos = helpers.propertySearch(arr, item.selector, 'selector');\r\n    if (pos !== index && parser.options.whitelist.indexOf(item.selector) === -1) {\r\n      result = helpers.addUnique(result, {\r\n        'ruleId': parser.rule.name,\r\n        'line': item.line,\r\n        'column': item.column,\r\n        'message': 'Rule `' + item.selector + '` should be merged with the rule on line ' + selectorList[pos].line,\r\n        'severity': parser.severity\r\n      });\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'no-mergeable-selectors',\r\n  'defaults': {\r\n    'whitelist': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    curLevel = 0;\r\n    curSelector = [];\r\n    parentSelector = [];\r\n    selectorList = [];\r\n    syntax = ast.syntax;\r\n    ast.traverseByType('stylesheet', function (styleSheet) {\r\n      traverseBlock(styleSheet, traverseNode);\r\n    });\r\n    return checkMergeable(parser);\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 55 */\r\n/***/ (function(module, exports, __nested_webpack_require_649754__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_649754__(0);\r\n\r\nvar properties = __nested_webpack_require_649754__(3);\r\n\r\n/**\r\n * Combine the valid property array and the array of extras into a new array\r\n *\r\n * @param {Array} props - The list of default valid properties\r\n * @param {Array} extras - The user specified list of valid properties\r\n * @returns {Array} Combined list\r\n */\r\nvar getCombinedList = function getCombinedList(props, extras) {\r\n  return props.concat(extras);\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'no-misspelled-properties',\r\n  'defaults': {\r\n    'extra-properties': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('property', function (node) {\r\n      if (node.first().is('ident')) {\r\n        var curProperty = node.first().content,\r\n            propertyList = getCombinedList(properties, parser.options['extra-properties']);\r\n\r\n        if (curProperty.charAt(0) === '-') {\r\n          curProperty = helpers.stripPrefix(curProperty);\r\n        }\r\n\r\n        if (helpers.isPartialStringMatch(curProperty, propertyList)) {\r\n          return false;\r\n        }\r\n\r\n        if (curProperty.length > 0) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': 'Property `' + curProperty + '` appears to be spelled incorrectly',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n\r\n      return false;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 56 */\r\n/***/ (function(module, exports, __nested_webpack_require_651388__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_651388__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-qualifying-elements',\r\n  'defaults': {\r\n    'allow-element-with-attribute': false,\r\n    'allow-element-with-class': false,\r\n    'allow-element-with-id': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('selector', function (selector) {\r\n      selector.forEach(function (item, i) {\r\n        if (item.is('attributeSelector') || item.is('class') || item.is('id')) {\r\n          var previous = selector.content[i - 1] || false;\r\n\r\n          if (previous && previous.is('typeSelector')) {\r\n            if (previous.contains('ident')) {\r\n              var type = null;\r\n\r\n              if (item.is('attributeSelector')) {\r\n                type = 'attribute';\r\n              }\r\n\r\n              if (item.is('class')) {\r\n                type = 'class';\r\n              }\r\n\r\n              if (item.is('id')) {\r\n                type = 'id';\r\n              }\r\n\r\n              if (type && !parser.options['allow-element-with-' + type]) {\r\n                result = helpers.addUnique(result, {\r\n                  'ruleId': parser.rule.name,\r\n                  'line': item.start.line,\r\n                  'column': item.start.column,\r\n                  'message': 'Qualifying elements are not allowed for ' + type + ' selectors',\r\n                  'severity': parser.severity\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 57 */\r\n/***/ (function(module, exports, __nested_webpack_require_653007__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_653007__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-trailing-whitespace',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n    var trailing = /( |\\t)+\\n/;\r\n    var trailingCRLF = /( |\\t)+\\r\\n/;\r\n\r\n    ast.traverseByType('space', function (space, i, parent) {\r\n      var content = space.content;\r\n      var nextIndex = i + 1;\r\n      var next = parent.content[nextIndex];\r\n\r\n      while (next && (next.is('space') || next.is('declarationDelimiter'))) {\r\n        content += next.content;\r\n        nextIndex++;\r\n        next = parent.content[nextIndex];\r\n      }\r\n\r\n      if (trailing.test(content) || trailingCRLF.test(content)) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'severity': parser.severity,\r\n          'line': space.start.line,\r\n          'column': space.start.column,\r\n          'message': 'No trailing whitespace allowed'\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 58 */\r\n/***/ (function(module, exports, __nested_webpack_require_654117__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_654117__(0);\r\n\r\nvar trailingZeroRegex = /^(\\d+\\.|\\.)+(\\d*?)0+$/;\r\n\r\nmodule.exports = {\r\n  'name': 'no-trailing-zero',\r\n  'defaults': {\r\n    'include': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('number', function (num) {\r\n\r\n      if (num.content.match(trailingZeroRegex)) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': num.start.line,\r\n          'column': num.start.column,\r\n          'message': 'Don\\'t include trailing zeros on numbers',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 59 */\r\n/***/ (function(module, exports, __nested_webpack_require_654905__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_654905__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-transition-all',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('declaration', function (declaration) {\r\n\r\n      if (declaration.first('property')) {\r\n        if (declaration.first('property').first('ident')) {\r\n          var propertyName = declaration.first('property').first('ident').content;\r\n\r\n          if (propertyName.charAt(0) === '-') {\r\n            propertyName = helpers.stripPrefix(propertyName);\r\n          }\r\n\r\n          if (propertyName === 'transition' || propertyName === 'transition-property') {\r\n            declaration.forEach('value', function (val) {\r\n              val.forEach('ident', function (ident) {\r\n                if (ident.content === 'all') {\r\n                  result = helpers.addUnique(result, {\r\n                    'ruleId': parser.rule.name,\r\n                    'line': declaration.start.line,\r\n                    'column': declaration.start.column,\r\n                    'message': 'The keyword `all` should not be used with the property `' + propertyName + '`',\r\n                    'severity': parser.severity\r\n                  });\r\n                }\r\n              });\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 60 */\r\n/***/ (function(module, exports, __nested_webpack_require_656348__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_656348__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-universal-selectors',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('typeSelector', function (typeSelector) {\r\n      typeSelector.traverse(function (item) {\r\n        if (item.is('ident') && item.content === '*') {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': item.start.line,\r\n            'column': item.start.column,\r\n            'message': '* (universal) selectors are not allowed',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 61 */\r\n/***/ (function(module, exports, __nested_webpack_require_657158__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_657158__(0),\r\n    url = __nested_webpack_require_657158__(93);\r\n\r\nmodule.exports = {\r\n  'name': 'no-url-domains',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('uri', function (uri) {\r\n      uri.traverse(function (item) {\r\n        if (item.is('string')) {\r\n          var stripped = helpers.stripQuotes(item.content),\r\n              parsedUrl = url.parse(stripped, false, true);\r\n\r\n          if (parsedUrl.host && parsedUrl.protocol !== 'data:') {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'severity': parser.severity,\r\n              'line': item.end.line,\r\n              'column': item.end.column,\r\n              'message': 'Domains in URLs are disallowed'\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 62 */\r\n/***/ (function(module, exports, __nested_webpack_require_658151__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_658151__(0);\r\n\r\nvar isUrlRegex = /^(https?:)?\\/\\//,\r\n    protocolRelativeRegex = /^(https?:)\\/\\//;\r\n\r\nmodule.exports = {\r\n  'name': 'no-url-protocols',\r\n  'defaults': {\r\n    'allow-protocol-relative-urls': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('uri', function (uri) {\r\n      uri.traverse(function (item) {\r\n        if (item.is('string')) {\r\n          var stripped = helpers.stripQuotes(item.content),\r\n              regexSelector = !parser.options['allow-protocol-relative-urls'] ? isUrlRegex : protocolRelativeRegex,\r\n              message = !parser.options['allow-protocol-relative-urls'] ? 'Protocols and domains in URLs are disallowed' : 'Protocols in URLS are disallowed';\r\n\r\n          if (stripped.match(regexSelector)) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'severity': parser.severity,\r\n              'line': item.end.line,\r\n              'column': item.end.column,\r\n              'message': message\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 63 */\r\n/***/ (function(module, exports, __nested_webpack_require_659415__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_659415__(0);\r\n\r\nvar properties = __nested_webpack_require_659415__(3),\r\n    prefixes = ['webkit', 'moz', 'ms'];\r\n\r\n/**\r\n * Returns a copy of the prefixes array so that it can be safely modified\r\n *\r\n * @param {Array} prefixArr - The array of prefixes\r\n * @returns {Array} A copy of the prefixes array\r\n */\r\nvar getPrefixCopy = function getPrefixCopy(prefixArr) {\r\n  return prefixArr.slice();\r\n};\r\n\r\n/**\r\n * Removes specified vendor prefixes from the prefixes array\r\n *\r\n * @param {Array} prefixArr - The array of prefixes\r\n * @param {Array} excludes - An array of prefixes to exclude\r\n * @returns {Array} The prefixes array minus any excluded prefixes\r\n */\r\nvar handleExcludes = function handleExcludes(prefixArr, excludes) {\r\n  excludes.forEach(function (item) {\r\n    var index = prefixArr.indexOf(item);\r\n\r\n    if (index > -1) {\r\n      prefixArr.splice(index, 1);\r\n    }\r\n  });\r\n\r\n  return prefixArr;\r\n};\r\n\r\n/**\r\n * Adds specified vendor prefixes to the prefixes array\r\n *\r\n * @param {Array} prefixArr - The array of prefixes\r\n * @param {Array} includes - An array of prefixes to include\r\n * @returns {Array} The prefixes array plus any extra included prefixes\r\n */\r\nvar handleIncludes = function handleIncludes(prefixArr, includes) {\r\n  includes.forEach(function (item) {\r\n    if (prefixArr.indexOf(item) === -1) {\r\n      prefixArr.push(item);\r\n    }\r\n  });\r\n\r\n  return prefixArr;\r\n};\r\n\r\n/**\r\n * Creates and returns a regex pattern based on all the included prefixes so that\r\n * we can test our values against it.\r\n *\r\n * @param {Array} prefixArr - The array of prefixes\r\n * @param {Array} includes - An array of prefixes to include\r\n * @param {Array} excludes - An array of prefixes to exclude\r\n * @returns {RegExp} The regex pattern for us to test values against\r\n */\r\nvar precompileRegEx = function precompileRegEx(prefixArr, includes, excludes) {\r\n  if (includes.length) {\r\n    prefixArr = handleIncludes(prefixArr, includes);\r\n  }\r\n\r\n  if (excludes.length) {\r\n    prefixArr = handleExcludes(prefixArr, excludes);\r\n  }\r\n\r\n  return new RegExp('-(' + prefixArr.join('|') + ')-');\r\n};\r\n\r\n/**\r\n * Checks to see if the property is a standard property or a browser specific one\r\n *\r\n * @param {string} property - The property string we want to test\r\n * @returns {boolean} Whether the property is standard or not\r\n */\r\nvar isStandardProperty = function isStandardProperty(property) {\r\n  return properties.indexOf(helpers.stripPrefix(property)) !== -1;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'no-vendor-prefixes',\r\n  'defaults': {\r\n    'additional-identifiers': [],\r\n    'excluded-identifiers': [],\r\n    'ignore-non-standard': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n\r\n    var result = [],\r\n        validPrefixes = getPrefixCopy(prefixes),\r\n        statement = precompileRegEx(validPrefixes, parser.options['additional-identifiers'], parser.options['excluded-identifiers']);\r\n\r\n    ast.traverseByType('ident', function (value) {\r\n      if (statement.test(value.content)) {\r\n        if (!isStandardProperty(value.content) && parser.options['ignore-non-standard']) {\r\n          return;\r\n        }\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': value.start.line,\r\n          'column': value.start.column,\r\n          'message': 'Vendor prefixes should not be used',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 64 */\r\n/***/ (function(module, exports, __nested_webpack_require_662959__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_662959__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'no-warn',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('atkeyword', function (keyword) {\r\n      keyword.traverse(function (item) {\r\n        if (item.content === 'warn') {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': item.start.line,\r\n            'column': item.start.column,\r\n            'message': '@warn not allowed',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 65 */\r\n/***/ (function(module, exports, __nested_webpack_require_663702__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_663702__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'one-declaration-per-line',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        lastLine = {};\r\n\r\n    ast.traverseByType('declaration', function (declaration, i, parent) {\r\n\r\n      if (declaration.start.line === lastLine.start || declaration.start.line === lastLine.end) {\r\n        if (parent.type !== 'arguments') {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': declaration.start.line,\r\n            'column': declaration.start.column,\r\n            'message': 'Only one declaration allowed per line',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n\r\n      lastLine.start = declaration.start.line;\r\n      lastLine.end = declaration.end.line;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 66 */\r\n/***/ (function(module, exports, __nested_webpack_require_664692__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_664692__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'placeholder-in-extend',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('atkeyword', function (keyword, i, parent) {\r\n      keyword.forEach(function (item) {\r\n        if (item.content === 'extend') {\r\n\r\n          parent.forEach('selector', function (selector) {\r\n            var placeholder = false;\r\n\r\n            selector.content.forEach(function (selectorPiece) {\r\n              if (selectorPiece.type === 'placeholder') {\r\n                placeholder = true;\r\n              }\r\n            });\r\n\r\n            if (!placeholder) {\r\n              result = helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'line': selector.start.line,\r\n                'column': selector.start.column,\r\n                'message': '@extend must be used with a %placeholder',\r\n                'severity': parser.severity\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 67 */\r\n/***/ (function(module, exports, __nested_webpack_require_665882__) {\r\n\r\n\"use strict\";\r\n// Note that this file is nearly identical to function-name-format.js, mixin-name-format.js, and variable-name-format.js\r\n\r\n\r\nvar helpers = __nested_webpack_require_665882__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'placeholder-name-format',\r\n  'defaults': {\r\n    'allow-leading-underscore': true,\r\n    'convention': 'hyphenatedlowercase',\r\n    'convention-explanation': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('placeholder', function (node) {\r\n      var name = node.first().content,\r\n          strippedName,\r\n          violationMessage = false;\r\n\r\n      if (node.first().is('ident')) {\r\n        strippedName = name;\r\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\r\n          strippedName = name.slice(1);\r\n        }\r\n\r\n        switch (parser.options.convention) {\r\n          case 'hyphenatedlowercase':\r\n            if (!helpers.isHyphenatedLowercase(strippedName)) {\r\n              violationMessage = 'Placeholder \\'%' + name + '\\' should be written in lowercase with hyphens';\r\n            }\r\n            break;\r\n          case 'camelcase':\r\n            if (!helpers.isCamelCase(strippedName)) {\r\n              violationMessage = 'Placeholder \\'%' + name + '\\' should be written in camelCase';\r\n            }\r\n            break;\r\n          case 'pascalcase':\r\n            if (!helpers.isPascalCase(strippedName)) {\r\n              violationMessage = 'Placeholder \\'%' + name + '\\' should be written in PascalCase';\r\n            }\r\n            break;\r\n          case 'snakecase':\r\n            if (!helpers.isSnakeCase(strippedName)) {\r\n              violationMessage = 'Placeholder \\'%' + name + '\\' should be written in snake_case';\r\n            }\r\n            break;\r\n          case 'strictbem':\r\n            if (!helpers.isStrictBEM(strippedName)) {\r\n              violationMessage = 'Placeholder \\'%' + name + '\\' should be written in BEM (Block Element Modifier) format';\r\n            }\r\n            break;\r\n          case 'hyphenatedbem':\r\n            if (!helpers.isHyphenatedBEM(strippedName)) {\r\n              violationMessage = 'Placeholder \\'%' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\r\n            }\r\n            break;\r\n          default:\r\n            if (!new RegExp(parser.options.convention).test(strippedName)) {\r\n              violationMessage = 'Placeholder \\'%' + name + '\\' should match regular expression /' + parser.options.convention + '/';\r\n\r\n              // convention-message overrides violationMessage\r\n              if (parser.options['convention-explanation']) {\r\n                violationMessage = parser.options['convention-explanation'];\r\n              }\r\n            }\r\n        }\r\n\r\n        if (violationMessage) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': violationMessage,\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 68 */\r\n/***/ (function(module, exports, __nested_webpack_require_669074__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar helpers = __nested_webpack_require_669074__(0);\r\n\r\nvar propertyCheckList = __nested_webpack_require_669074__(3);\r\n\r\nvar orderPresets = {\r\n  'recess': 'recess.yml',\r\n  'smacss': 'smacss.yml',\r\n  'concentric': 'concentric.yml'\r\n};\r\n\r\nvar getOrderConfig = function getOrderConfig(order) {\r\n  if (typeof order === 'string') {\r\n    if (orderPresets.hasOwnProperty(order)) {\r\n      var filename = orderPresets[order],\r\n          orderConfig = helpers.loadConfigFile('property-sort-orders/' + filename);\r\n\r\n      return orderConfig.order;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nvar sortProperties = function sortProperties(obj, order) {\r\n  var keys = Object.keys(obj),\r\n      unknown = [],\r\n      sorted = {},\r\n      i;\r\n\r\n  if (typeof order === 'string') {\r\n    if (order === 'alphabetical') {\r\n      keys = keys.sort();\r\n    }\r\n  } else if ((typeof order === 'undefined' ? 'undefined' : _typeof(order)) === 'object') {\r\n    var orderedKeys = [];\r\n\r\n    for (i = 0; i < order.length; i++) {\r\n      if (keys.indexOf(order[i]) !== -1) {\r\n        orderedKeys.push(order[i]);\r\n      }\r\n    }\r\n\r\n    keys = orderedKeys;\r\n  } else {\r\n    keys = keys.sort(function (a, b) {\r\n      if (order.indexOf(a) === -1) {\r\n        if (unknown.indexOf(a) === -1) {\r\n          unknown.push(a);\r\n        }\r\n      }\r\n      if (order.indexOf(b) === -1) {\r\n        if (unknown.indexOf(b) === -1) {\r\n          unknown.push(b);\r\n        }\r\n      }\r\n\r\n      if (order.indexOf(a) > order.indexOf(b)) {\r\n        return 1;\r\n      }\r\n      if (order.indexOf(a) < order.indexOf(b)) {\r\n        return -1;\r\n      }\r\n      return 0;\r\n    });\r\n  }\r\n\r\n  for (i = 0; i < unknown.length; i++) {\r\n    if (keys.indexOf(unknown[i]) !== -1) {\r\n      keys.splice(keys.indexOf(unknown[i]), 1);\r\n    }\r\n  }\r\n\r\n  keys = keys.concat(unknown.sort());\r\n\r\n  for (i = 0; i < keys.length; i++) {\r\n    sorted[keys[i]] = obj[keys[i]];\r\n  }\r\n\r\n  return sorted;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'property-sort-order',\r\n  'defaults': {\r\n    'order': 'alphabetical',\r\n    'ignore-custom-properties': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        order = getOrderConfig(parser.options.order) || parser.options.order;\r\n\r\n    ast.traverseByType('block', function (block) {\r\n      var properties = {},\r\n          sorted,\r\n          pKeys,\r\n          sKeys;\r\n\r\n      if (block) {\r\n        block.forEach('declaration', function (dec) {\r\n          var prop = dec.first('property'),\r\n              name = prop.first('ident');\r\n\r\n          if (name) {\r\n            if (parser.options['ignore-custom-properties']) {\r\n              if (propertyCheckList.indexOf(name.content) !== -1) {\r\n                properties[name.content] = prop;\r\n              }\r\n            } else {\r\n              properties[name.content] = prop;\r\n            }\r\n          }\r\n        });\r\n\r\n        sorted = sortProperties(properties, order);\r\n\r\n        pKeys = Object.keys(properties);\r\n        sKeys = Object.keys(sorted);\r\n\r\n        sKeys.every(function (e, i) {\r\n          var pKey = pKeys[i],\r\n              prop = properties[pKey];\r\n\r\n          if (e !== pKey) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': prop.start.line,\r\n              'column': prop.start.column,\r\n              'message': 'Expected `' + e + '`, found `' + pKey + '`',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n          return true;\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 69 */\r\n/***/ (function(module, exports, __nested_webpack_require_672947__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_672947__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'property-units',\r\n  'defaults': {\r\n    'per-property': {},\r\n    'global': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        unitsAllowedGlobally = parser.options.global,\r\n        unitsAllowedPerProperty = parser.options['per-property'];\r\n\r\n    ast.traverseByType('declaration', function (declaration) {\r\n      var property = declaration.first('property'),\r\n          ident = property ? property.first('ident') : null,\r\n          propertyName = ident ? ident.content : null,\r\n          valueNode = declaration.first('value'),\r\n          hasDimension = valueNode ? !!valueNode.first('dimension') : null;\r\n      if (propertyName && hasDimension) {\r\n        // properties such as box-shadow may have multiple dimensions defined so enumerate through them\r\n        valueNode.forEach('dimension', function (dimension) {\r\n          var dimensionIdent = dimension ? dimension.first('ident') : null,\r\n              unitType = dimensionIdent ? dimensionIdent.content : null,\r\n              unitsAllowed = unitsAllowedPerProperty[propertyName];\r\n          // If a property is defined in unitsAllowed, then it will only validate those unit types\r\n          if (unitType && unitsAllowed) {\r\n            if (unitsAllowed.indexOf(unitType) === -1) {\r\n              result = helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'severity': parser.severity,\r\n                'line': dimension.start.line,\r\n                'column': dimension.start.column,\r\n                'message': 'Values for property \\'' + propertyName + '\\' may not use ' + unitType + ' units'\r\n              });\r\n            }\r\n          }\r\n          // If no units are defined in unitsAllowedGlobally, then allow all of them\r\n          // Otherwise, verify the given unit is in the unitsAllowedGlobally list.\r\n          else if (unitType && unitsAllowedGlobally.length && unitsAllowedGlobally.indexOf(unitType) === -1) {\r\n              result = helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'severity': parser.severity,\r\n                'line': dimension.start.line,\r\n                'column': dimension.start.column,\r\n                'message': 'Values for property \\'' + propertyName + '\\' may not use ' + unitType + ' units'\r\n              });\r\n            }\r\n        });\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 70 */\r\n/***/ (function(module, exports, __nested_webpack_require_675514__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_675514__(0);\r\n\r\nvar pseudoElements = __nested_webpack_require_675514__(97),\r\n    pseudoClasses = __nested_webpack_require_675514__(96);\r\n\r\n/**\r\n * Check if the given argument is a prefixed string. If it is we return an unprefixed\r\n * version, else return it unmodified\r\n *\r\n * @param {Object|string} name - The value to test\r\n * @returns {string} A prefix free version of the string\r\n */\r\nvar prefixFree = function prefixFree(name) {\r\n  return typeof name === 'string' && name.charAt(0) === '-' ? helpers.stripPrefix(name) : name;\r\n};\r\n\r\n/**\r\n * Determine if the given string matches a pseudo-element\r\n *\r\n * @param {string} name - The name to check\r\n * @returns {Boolean} Whether or not name is pseudo-element\r\n */\r\nvar isPseudoElement = function isPseudoElement(name) {\r\n  return pseudoElements.indexOf(prefixFree(name)) !== -1;\r\n};\r\n\r\n/**\r\n * Determine if the given string matches a pseudo-class\r\n *\r\n * @param {string} name - The name to check\r\n * @returns {Boolean} Whether or not name is pseudo-class\r\n */\r\nvar isPseudoClass = function isPseudoClass(name) {\r\n  return pseudoClasses.indexOf(prefixFree(name)) !== -1;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'pseudo-element',\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('pseudoClass', function (node) {\r\n      if (isPseudoElement(node.content[0].content)) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': node.start.line,\r\n          'column': node.start.column,\r\n          'message': 'Pseudo-elements must start with double colons',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n\r\n    ast.traverseByType('pseudoElement', function (node) {\r\n      if (isPseudoClass(node.content[0].content)) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': node.start.line,\r\n          'column': node.start.column,\r\n          'message': 'Pseudo-classes must start with a single colon',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 71 */\r\n/***/ (function(module, exports, __nested_webpack_require_677719__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_677719__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'quotes',\r\n  'defaults': {\r\n    'style': 'single'\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('string', function (node) {\r\n      var firstQuote = node.content.charAt(0),\r\n          lastQuote = node.content.charAt(node.content.length - 1);\r\n\r\n      if (firstQuote !== lastQuote) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': node.start.line,\r\n          'column': node.start.column,\r\n          'message': 'Mixed quote styles',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n\r\n      if (parser.options.style === 'single' && firstQuote !== '\\'') {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': node.start.line,\r\n          'column': node.start.column,\r\n          'message': 'Strings must use single quotes',\r\n          'severity': parser.severity\r\n        });\r\n      } else if (parser.options.style === 'double' && firstQuote !== '\"') {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': node.start.line,\r\n          'column': node.start.column,\r\n          'message': 'Strings must use double quotes',\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 72 */\r\n/***/ (function(module, exports, __nested_webpack_require_679229__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_679229__(0);\r\n\r\nvar shortVals = ['border-color', 'border-radius', 'border-style', 'border-width', 'margin', 'padding'];\r\n\r\n/**\r\n * Checks to see if a series of values can be condensed down to a singular value\r\n *\r\n * @param {array} value - The array of values to check\r\n * @param {array} allowed - The parser options to specify the levels allowed to condense to\r\n * @returns {boolean} Whether the values can be condensed to a singular value\r\n */\r\nvar condenseToOne = function condenseToOne(value, allowed) {\r\n  if (allowed.indexOf(1) !== -1 && value.length > 1) {\r\n    for (var i = 1; i < value.length; i++) {\r\n      if (value[i] !== value[0]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Checks to see if a series of values can be condensed down to two values\r\n *\r\n * @param {array} value - The array of values to check\r\n * @param {array} allowed - The parser options to specify the levels allowed to condense to\r\n * @returns {boolean} Whether the values can be condensed to two values\r\n */\r\nvar condenseToTwo = function condenseToTwo(value, allowed) {\r\n  if (allowed.indexOf(2) !== -1 && value.length > 2) {\r\n    if (value[0] === value[2] && value[1] === value[3] || value[0] === value[2] && !value[3] && value[0] !== value[1]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Checks to see if a series of values can be condensed down to three values\r\n *\r\n * @param {array} value - The array of values to check\r\n * @param {array} allowed - The parser options to specify the levels allowed to condense to\r\n * @returns {boolean} Whether the values can be condensed to three values\r\n */\r\nvar condenseToThree = function condenseToThree(value, allowed) {\r\n  if (allowed.indexOf(3) !== -1 && value.length > 3) {\r\n    if (value[1] === value[3]) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Used to scan property values and create a string representation of the values to display\r\n *\r\n * @param {Object} node - The current node\r\n * @returns {string} A string reconstruction of the current properties value\r\n */\r\nvar scanValue = function scanValue(node) {\r\n  var curValue = [];\r\n  var fullVal = '';\r\n  node.forEach(function (val) {\r\n    // add to our value string depending on node type\r\n    if (val.is('dimension')) {\r\n      val.forEach(function (el) {\r\n        fullVal += el.content;\r\n      });\r\n    } else if (val.is('percentage')) {\r\n      val.forEach(function (el) {\r\n        fullVal += el.content + '%';\r\n      });\r\n    } else if (val.is('interpolation')) {\r\n      fullVal += '#{' + scanValue(val.content) + '}';\r\n    } else if (val.is('color')) {\r\n      fullVal += '#' + val.content + '';\r\n    } else if (val.is('operator') || val.is('ident') || val.is('number') || val.is('unaryOperator') || val.is('string')) {\r\n      fullVal += val.content;\r\n    } else if (val.is('variable')) {\r\n      val.forEach(function (el) {\r\n        fullVal += '$' + el.content;\r\n      });\r\n    } else if (val.is('function')) {\r\n\r\n      var func = val.first('ident'),\r\n          args = '';\r\n\r\n      val.forEach('arguments', function (arg) {\r\n        args = scanValue(arg).join(' ');\r\n      });\r\n\r\n      fullVal = func + '(' + args + ')';\r\n    } else if (val.is('parentheses')) {\r\n      fullVal += '(' + scanValue(val).join(' ') + ')';\r\n    } else if (val.is('space')) {\r\n      // This is a non value character such as a space\r\n      // We want to start another value here\r\n      curValue.push(fullVal);\r\n\r\n      // reset the value string for the next iteration\r\n      fullVal = '';\r\n    }\r\n  });\r\n\r\n  if (fullVal !== '') {\r\n    // The last dimension in a value will not be followed by a character so we push here\r\n    curValue.push(fullVal);\r\n  }\r\n  return curValue;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'shorthand-values',\r\n  'defaults': {\r\n    'allowed-shorthands': [1, 2, 3]\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('declaration', function (declaration) {\r\n      var isShorthandProperty = false,\r\n          property;\r\n\r\n      declaration.traverse(function (item) {\r\n\r\n        if (item.is('property')) {\r\n          item.traverse(function (child) {\r\n            // check if the property is a possible shorthand property\r\n            if (shortVals.indexOf(child.content) !== -1) {\r\n              isShorthandProperty = true;\r\n\r\n              // store a reference to the property for our error\r\n              property = shortVals[shortVals.indexOf(child.content)];\r\n            }\r\n          });\r\n        }\r\n\r\n        if (isShorthandProperty) {\r\n          var value = [];\r\n\r\n          if (item.is('value')) {\r\n            var node = item.content;\r\n\r\n            // Build each value into an array of strings with value and type\r\n            value = scanValue(node);\r\n\r\n            if (value.length <= 4 && value.length >= 1) {\r\n              var output = [];\r\n\r\n              // check which values can condense\r\n              if (condenseToOne(value, parser.options['allowed-shorthands'])) {\r\n                output = [value[0]];\r\n              } else if (condenseToTwo(value, parser.options['allowed-shorthands'])) {\r\n                output = [value[0], value[1]];\r\n              } else if (condenseToThree(value, parser.options['allowed-shorthands'])) {\r\n                output = [value[0], value[1], value[2]];\r\n              }\r\n\r\n              if (output.length) {\r\n                result = helpers.addUnique(result, {\r\n                  'ruleId': parser.rule.name,\r\n                  'line': item.start.line,\r\n                  'column': item.start.column,\r\n                  'message': 'Property `' + property + '` should be written more concisely as `' + output.join(' ') + '` instead of `' + value.join(' ') + '`',\r\n                  'severity': parser.severity\r\n                });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 73 */\r\n/***/ (function(module, exports, __nested_webpack_require_685270__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_685270__(0);\r\n\r\n/**\r\n * Checks a ruleset for selectors or EOL characters. If a selector is found before an EOL\r\n * then it returns the selector node for reporting or returns false\r\n *\r\n * @param {Object} ruleset - The ruleset node\r\n * @param {number} index - The current index of the delimiter\r\n * @returns {Object|boolean} Either the selector node or false\r\n */\r\nvar checkLineForSelector = function checkLineForSelector(ruleset, index) {\r\n  var curIndex = index += 1;\r\n  if (ruleset.content[curIndex]) {\r\n    for (; curIndex < ruleset.content.length; curIndex++) {\r\n      var curType = ruleset.content[curIndex].type;\r\n      if (curType === 'space' && helpers.hasEOL(ruleset.content[curIndex])) {\r\n        return false;\r\n      }\r\n      if (curType === 'selector' || curType === 'typeSelector') {\r\n        return ruleset.content[curIndex];\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'single-line-per-selector',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('ruleset', function (ruleset) {\r\n      ruleset.forEach('delimiter', function (delimiter, j) {\r\n        var next = checkLineForSelector(ruleset, j);\r\n\r\n        if (next) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': next.start.line,\r\n            'column': next.start.column,\r\n            'message': 'Selectors must be placed on new lines',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 74 */\r\n/***/ (function(module, exports, __nested_webpack_require_686976__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_686976__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'space-after-bang',\r\n  'defaults': {\r\n    'include': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [],\r\n        regex = /!\\s/;\r\n\r\n    ast.traverseByTypes(['important', 'default', 'global', 'optional'], function (block) {\r\n      if (block.content.match(regex) !== null) {\r\n        if (parser.options.include) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': block.start.line,\r\n            'column': block.start.column + 1,\r\n            'message': 'Bangs (!) should be followed by a space',\r\n            'severity': parser.severity\r\n          });\r\n        } else {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': block.start.line,\r\n            'column': block.start.column,\r\n            'message': 'Bangs (!) should not be followed by a space',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 75 */\r\n/***/ (function(module, exports, __nested_webpack_require_688161__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_688161__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'space-after-colon',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['propertyDelimiter', 'operator'], function (delimiter, i, parent) {\r\n      if (delimiter.content === ':') {\r\n        var next = parent.content[i + 1];\r\n\r\n        if (next && next.is('space')) {\r\n          if (!parser.options.include) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': next.start.line,\r\n              'column': next.start.column,\r\n              'message': 'No space allowed after `:`',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        } else {\r\n          if (parser.options.include) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': delimiter.start.line,\r\n              'column': delimiter.start.column,\r\n              'message': 'Space expected after `:`',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 76 */\r\n/***/ (function(module, exports, __nested_webpack_require_689468__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_689468__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'space-after-comma',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['operator', 'delimiter'], function (operator, i, parent) {\r\n      var next, doubleNext;\r\n\r\n      if (operator.content === ',') {\r\n        next = parent.content[i + 1] || false;\r\n        doubleNext = parent.content[i + 2] || false;\r\n\r\n        if (next) {\r\n          if (operator.is('delimiter')) {\r\n            if (next.is('selector')) {\r\n              next = next.content[0];\r\n            }\r\n          }\r\n\r\n          if (next.is('space') && !helpers.hasEOL(next.content) && !parser.options.include) {\r\n            if (doubleNext && doubleNext.is('singlelineComment')) {\r\n              return false;\r\n            }\r\n\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': next.start.line,\r\n              'column': next.start.column,\r\n              'message': 'Commas should not be followed by a space',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n\r\n          if (!next.is('space') && parser.options.include) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': operator.start.line,\r\n              'column': operator.start.column,\r\n              'message': 'Commas should be followed by a space',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 77 */\r\n/***/ (function(module, exports, __nested_webpack_require_691204__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_691204__(0);\r\n\r\nvar operators = ['+', '-', '/', '*', '%', '<', '>', '==', '!=', '<=', '>='];\r\n\r\n/**\r\n * Determine a relational operator based on the operator node\r\n *\r\n * @param {Object} node - The operator node\r\n * @returns {string} Returns a relational operator\r\n */\r\nvar getRelationalOperator = function getRelationalOperator(node) {\r\n  if (node.content === '<') {\r\n    return '<=';\r\n  }\r\n\r\n  if (node.content === '>') {\r\n    return '>=';\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if operator is negative number\r\n *\r\n * @param {string} operator - The operator\r\n * @param {Object} next - The next node\r\n * @param {Object} previous - The previous node\r\n * @param {Object} doublePrevious - The double previous node (back two)\r\n * @returns {bool} true / false\r\n */\r\nvar isNegativeNumber = function isNegativeNumber(operator, next, previous, doublePrevious) {\r\n  if (operator === '-') {\r\n\r\n    // Catch the following:\r\n    // $foo: -20;\r\n    // $foo: -#{$foo}\r\n    // $foo: -($foo * 2)\r\n    // $foo: -$foo\r\n    if (next) {\r\n      if (!previous || previous.is('space') && doublePrevious && !doublePrevious.is('number')) {\r\n        if (next.is('number') || next.is('interpolation') || next.is('variable') || next.is('parentheses')) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Catch the following:\r\n    // .foo {\r\n    //   property: -16px;\r\n    // }\r\n    if (next && (next.is('dimension') || next.is('percentage'))) {\r\n      return true;\r\n    }\r\n\r\n    // Catch the following:\r\n    // .foo {\r\n    //   propery: 2 / -16;\r\n    // }\r\n    if (doublePrevious && doublePrevious.is('operator')) {\r\n      return true;\r\n    }\r\n\r\n    // Catch the following:\r\n    // .foo {\r\n    //   property: 2 /-16px;\r\n    // }\r\n    if (previous && previous.is('operator')) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if operator is divider\r\n *\r\n * @param {string} operator - The operator\r\n * @param {Object} next - The next node\r\n * @param {Object} previous - The previous node\r\n * @returns {bool} true / false\r\n */\r\nvar isDivider = function isDivider(operator, next, previous) {\r\n  if (operator === '/') {\r\n\r\n    // Catch the following:\r\n    // .foo {\r\n    //   property: calc(100% / 2);\r\n    // }\r\n    if (previous && next) {\r\n      if (previous.is('dimension') && (next.is('dimension') || next.is('number'))) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if operator is part of unicode\r\n *\r\n * @param {string} operator - The operator\r\n * @param {Object} previous - The previous node\r\n * @returns {bool} true / false\r\n */\r\nvar isUnicode = function isUnicode(operator, previous) {\r\n  if (operator === '+') {\r\n\r\n    // Catch the following:\r\n    // @font-face {\r\n    //   unicode-range: U+26;\r\n    // }\r\n    if (previous && previous.is('ident') && previous.content === 'U') {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if operator is part of import path\r\n *\r\n * @param {string} operator - The operator\r\n * @param {Object} parent - The parent node\r\n * @returns {bool} true / false\r\n */\r\nvar isImport = function isImport(operator, parent) {\r\n  if (operator === '/') {\r\n\r\n    if (parent && parent.is('atrule') && parent.contains('atkeyword')) {\r\n      var keyword = parent.first('atkeyword');\r\n\r\n      if (keyword.contains('ident')) {\r\n        var ident = keyword.first('ident');\r\n\r\n        if (ident.content === 'import') {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if operator is part an ident\r\n *\r\n * @param {string} operator - The operator\r\n * @param {Object} next - The next node\r\n * @param {Object} previous - The previous node\r\n * @returns {bool} true / false\r\n */\r\nvar isPartialIdent = function isPartialIdent(operator, next, previous) {\r\n  if (operator === '-') {\r\n    return next && previous && previous.is('interpolation');\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Determine if operator is exception\r\n *\r\n * @param {string} operator - The operator\r\n * @param {Object} parent - The parent node\r\n * @param {Object} i - The node index\r\n * @returns {bool} true / false\r\n */\r\nvar isException = function isException(operator, parent, i) {\r\n  var previous = parent.content[i - 1] || false,\r\n      doublePrevious = parent.content[i - 2] || false,\r\n      next = parent.content[i + 1] || false;\r\n\r\n  if (isNegativeNumber(operator, next, previous, doublePrevious)) {\r\n    return true;\r\n  }\r\n\r\n  if (isDivider(operator, next, previous)) {\r\n    return true;\r\n  }\r\n\r\n  if (isUnicode(operator, previous)) {\r\n    return true;\r\n  }\r\n\r\n  if (isImport(operator, parent)) {\r\n    return true;\r\n  }\r\n\r\n  if (isPartialIdent(operator, next, previous)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Check the spacing around an operator\r\n *\r\n * @param {Object} node - The node to check the spacing around\r\n * @param {int} i - The node's child index of it's parent\r\n * @param {Object} parent - The parent node\r\n * @param {Object} parser - The parser object\r\n * @param {Object} result - The result object\r\n * @returns {bool|null} false if exception\r\n */\r\nvar checkSpacing = function checkSpacing(node, i, parent, parser, result) {\r\n  if (node.is('operator') || node.is('unaryOperator')) {\r\n    var previous = parent.content[i - 1] || false,\r\n        next = parent.content[i + 1] || false,\r\n        operator = node.content;\r\n\r\n    //////////////////////////\r\n    // Multi-part operators\r\n    //////////////////////////\r\n\r\n    // If second part of relational operator move on\r\n    if (node.content === '=' && previous) {\r\n      if (previous.content === '<' || previous.content === '>') {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // If first part of relational operator, carry on and build it\r\n    if ((node.content === '<' || node.content === '>') && next) {\r\n      if (next.content === '=') {\r\n        operator = getRelationalOperator(node);\r\n        next = parent.content[i + 2] || false;\r\n      }\r\n    }\r\n\r\n    //////////////////////////\r\n    // Exceptions\r\n    //////////////////////////\r\n\r\n    if (isException(operator, parent, i)) {\r\n      return false;\r\n    }\r\n\r\n    // If the operator checks out in our valid operator list\r\n    if (operators.indexOf(operator) !== -1) {\r\n\r\n      if (parser.options.include) {\r\n        if (previous && !previous.is('space') || next && !next.is('space')) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': 'Space expected around operator',\r\n            'severity': parser.severity\r\n          });\r\n        } else {\r\n          if (previous && previous.end.line >= previous.start.line && previous.end.column > previous.start.column || next && next.end.line >= next.start.line && next.end.column > next.start.column) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': node.start.line,\r\n              'column': node.start.column,\r\n              'message': 'Multiple spaces not allowed around operator',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      } else {\r\n        if (previous && previous.is('space') || next && next.is('space')) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': node.start.line,\r\n            'column': node.start.column,\r\n            'message': 'No spaces allowed around operator',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'space-around-operator',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['condition', 'atrule', 'value'], function (node) {\r\n      node.forEach(function (item, i, parent) {\r\n        // Perform another loop of the children if we come across a parenthesis\r\n        // parent node\r\n        if (item.is('parentheses')) {\r\n          item.forEach(function (child, j, childParent) {\r\n            // Do the spacing checks\r\n            checkSpacing(child, j, childParent, parser, result);\r\n          });\r\n        } else {\r\n          // Do the spacing checks\r\n          checkSpacing(item, i, parent, parser, result);\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 78 */\r\n/***/ (function(module, exports, __nested_webpack_require_699741__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_699741__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'space-before-bang',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['important', 'default'], function (block, i, parent) {\r\n      var previous = parent.content[i - 1];\r\n\r\n      if (!previous.is('space')) {\r\n        if (parser.options.include) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': block.start.line,\r\n            'column': block.start.column,\r\n            'message': 'Whitespace required before !important',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      } else {\r\n        if (!parser.options.include) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': previous.start.line,\r\n            'column': previous.start.column,\r\n            'message': 'Whitespace not allowed before !important',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 79 */\r\n/***/ (function(module, exports, __nested_webpack_require_700970__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_700970__(0);\r\n\r\nvar getLastWhitespace = function getLastWhitespace(node) {\r\n  if (node === false) {\r\n    return null;\r\n  }\r\n\r\n  if (!node) {\r\n    return false;\r\n  }\r\n  if (node.is('space')) {\r\n    return node;\r\n  }\r\n\r\n  return getLastWhitespace(node.last());\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'space-before-brace',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n    if (ast.syntax === 'scss') {\r\n      ast.traverseByTypes(['block', 'atrulers', 'declaration'], function (block, i, parent) {\r\n        var previous = false,\r\n            whitespace,\r\n            warn = {};\r\n\r\n        if ((block.is('block') || block.is('atrulers')) && !parent.is('value')) {\r\n          previous = parent.get(i - 1);\r\n        } else if (block.is('declaration')) {\r\n          if (block.contains('value')) {\r\n            for (var j = 0; j < block.content.length; j++) {\r\n              if (block.content[j].is('value') && block.content[j].content[0].is('block')) {\r\n                previous = block.content[j - 1];\r\n                warn.line = block.content[j].content[0].start.line;\r\n                warn.col = block.content[j].content[0].start.column;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        whitespace = getLastWhitespace(previous);\r\n        if (whitespace === false) {\r\n          if (parser.options.include) {\r\n            if (!warn.hasOwnProperty('line')) {\r\n              warn.line = block.start.line;\r\n              warn.col = block.start.column;\r\n            }\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': warn.line,\r\n              'column': warn.col - 1,\r\n              'message': 'Whitespace required before {',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        } else {\r\n          if (!parser.options.include && whitespace !== null) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': whitespace.start.line,\r\n              'column': whitespace.start.column,\r\n              'message': 'Whitespace not allowed before {',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 80 */\r\n/***/ (function(module, exports, __nested_webpack_require_703395__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_703395__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'space-before-colon',\r\n  'defaults': {\r\n    'include': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByTypes(['propertyDelimiter', 'operator'], function (delimiter, i, parent) {\r\n      if (delimiter.content === ':') {\r\n        var previous = parent.content[i - 1];\r\n\r\n        if (previous && previous.is('space')) {\r\n          if (!parser.options.include) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': previous.start.line,\r\n              'column': previous.start.column,\r\n              'message': 'No space allowed before `:`',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        } else {\r\n          if (parser.options.include) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': delimiter.start.line,\r\n              'column': delimiter.start.column - 1,\r\n              'message': 'Space expected before `:`',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 81 */\r\n/***/ (function(module, exports, __nested_webpack_require_704730__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_704730__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'space-between-parens',\r\n  'defaults': {\r\n    'include': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('arguments', function (args) {\r\n      var first = args.first(),\r\n          last = args.last();\r\n\r\n      if (args.length === 0) {\r\n        return;\r\n      }\r\n\r\n      if (parser.options.include) {\r\n        if (!first.is('space')) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': first.start.line,\r\n            'column': first.start.column - 1,\r\n            'message': 'Space expected at beginning of parenthesis',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n        if (!last.is('space')) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': last.end.line,\r\n            'column': last.end.column,\r\n            'message': 'Space expected at end of parenthesis',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n      } else {\r\n        // Ignore if arguments are multi-line\r\n        if (first.is('space') && !helpers.hasEOL(first.content)) {\r\n          result = helpers.addUnique(result, {\r\n            'ruleId': parser.rule.name,\r\n            'line': first.start.line,\r\n            'column': first.start.column,\r\n            'message': 'No space allowed at beginning of parenthesis',\r\n            'severity': parser.severity\r\n          });\r\n        }\r\n        if (last.is('space')) {\r\n          // Proceed if arguments aren't multi-line.\r\n          // With Sass we have one extra check for nested nodes where we must\r\n          // check doublePrevious as the last node will be the indentation\r\n          if (ast.syntax === 'scss' && !helpers.hasEOL(last.content) || ast.syntax === 'sass' && !helpers.hasEOL(last.content) && !helpers.hasEOL(args.content[args.content.length - 2].content)) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'line': last.start.line,\r\n              'column': last.start.column,\r\n              'message': 'No space allowed at end of parenthesis',\r\n              'severity': parser.severity\r\n            });\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 82 */\r\n/***/ (function(module, exports, __nested_webpack_require_707193__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_707193__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'trailing-semicolon',\r\n  'defaults': {\r\n    'include': true\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    if (ast.syntax !== 'sass') {\r\n      ast.traverseByType('block', function (block) {\r\n        var last, next;\r\n\r\n        try {\r\n          last = block.last('declaration');\r\n        } catch (e) {\r\n          return;\r\n        }\r\n\r\n        block.forEach('declaration', function (item, i, parent) {\r\n          if (item.contains('value')) {\r\n            var valueNode = item.last('value').content[0];\r\n\r\n            if (!valueNode.is('block')) {\r\n              if (helpers.isEqual(last, item)) {\r\n                if (parent.content[i + 1]) {\r\n                  next = parent.content[i + 1];\r\n\r\n                  if (next.is('declarationDelimiter')) {\r\n                    if (!parser.options.include) {\r\n                      result = helpers.addUnique(result, {\r\n                        'ruleId': parser.rule.name,\r\n                        'severity': parser.severity,\r\n                        'line': item.end.line,\r\n                        'column': item.end.column,\r\n                        'message': 'No trailing semicolons allowed'\r\n                      });\r\n                    }\r\n                  } else {\r\n                    if (parser.options.include) {\r\n                      result = helpers.addUnique(result, {\r\n                        'ruleId': parser.rule.name,\r\n                        'severity': parser.severity,\r\n                        'line': item.last('value').start.line,\r\n                        'column': item.last('value').start.column,\r\n                        'message': 'Trailing semicolons required'\r\n                      });\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 83 */\r\n/***/ (function(module, exports, __nested_webpack_require_709228__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_709228__(0);\r\n\r\nvar isVarRegex = /^[\\$]/;\r\n\r\nmodule.exports = {\r\n  'name': 'url-quotes',\r\n  'defaults': {},\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('uri', function (node) {\r\n      node.traverse(function (item) {\r\n        if (item.is('raw')) {\r\n          if (!item.content.match(isVarRegex)) {\r\n            result = helpers.addUnique(result, {\r\n              'ruleId': parser.rule.name,\r\n              'severity': parser.severity,\r\n              'line': item.start.line,\r\n              'column': item.start.column,\r\n              'message': 'Quotes around URLs are required'\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 84 */\r\n/***/ (function(module, exports, __nested_webpack_require_710073__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_710073__(0);\r\n\r\n// The whitelisted ident values\r\nvar whitelistedValues = ['inherit', 'initial', 'transparent', 'none', 'currentColor'],\r\n    ignoredValueTypes = ['important', 'space'];\r\n\r\n/**\r\n * Checks If the property is of a valid type, either its a variable or it's a whitelisted ident value\r\n *\r\n * @param {Object} propertyElem - The property element\r\n * @returns {boolean} Whether the property is valid or not\r\n */\r\nvar isValidProperty = function isValidProperty(propertyElem) {\r\n  if (propertyElem) {\r\n    if (propertyElem.type === 'variable') {\r\n      return true;\r\n    } else if (propertyElem.type === 'ident' && whitelistedValues.indexOf(propertyElem.content) !== -1) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Checks If the property type is an ignored value type\r\n *\r\n * @param {Object} propertyElem - The property element\r\n * @returns {boolean} Whether the property is an ignored type or not\r\n */\r\nvar isIgnoredType = function isIgnoredType(propertyElem) {\r\n  if (propertyElem) {\r\n    return ignoredValueTypes.indexOf(propertyElem.type) !== -1;\r\n  }\r\n  return false;\r\n};\r\n\r\nmodule.exports = {\r\n  'name': 'variable-for-property',\r\n  'defaults': {\r\n    'properties': []\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    if (parser.options.properties.length) {\r\n      ast.traverseByType('value', function (node, i, parent) {\r\n        var declaration = parent.content[0].content[0],\r\n            declarationType = declaration.type,\r\n            declarationIdent = declaration.content;\r\n\r\n        if (declarationType === 'ident') {\r\n          if (parser.options.properties.indexOf(declarationIdent) !== -1) {\r\n            node.forEach(function (valElem) {\r\n              if (!isValidProperty(valElem) && !isIgnoredType(valElem)) {\r\n                result = helpers.addUnique(result, {\r\n                  'ruleId': parser.rule.name,\r\n                  'line': declaration.start.line,\r\n                  'column': declaration.start.column,\r\n                  'message': 'Values for properties of type \\'' + declarationIdent + '\\' may only be variables',\r\n                  'severity': parser.severity\r\n                });\r\n              }\r\n            });\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 85 */\r\n/***/ (function(module, exports, __nested_webpack_require_712483__) {\r\n\r\n\"use strict\";\r\n// Note that this file is nearly identical to function-name-format.js, mixin-name-format.js, and placeholder-name-format.js\r\n\r\n\r\nvar helpers = __nested_webpack_require_712483__(0);\r\n\r\nmodule.exports = {\r\n  'name': 'variable-name-format',\r\n  'defaults': {\r\n    'allow-leading-underscore': true,\r\n    'convention': 'hyphenatedlowercase',\r\n    'convention-explanation': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('variable', function (variable) {\r\n      var strippedName,\r\n          violationMessage = false,\r\n          name = variable.first().content;\r\n\r\n      strippedName = name;\r\n\r\n      if (parser.options['allow-leading-underscore'] && name[0] === '_') {\r\n        strippedName = strippedName.slice(1);\r\n      }\r\n\r\n      switch (parser.options.convention) {\r\n        case 'hyphenatedlowercase':\r\n          if (!helpers.isHyphenatedLowercase(strippedName)) {\r\n            violationMessage = 'Variable \\'' + name + '\\' should be written in lowercase with hyphens';\r\n          }\r\n          break;\r\n        case 'camelcase':\r\n          if (!helpers.isCamelCase(strippedName)) {\r\n            violationMessage = 'Variable \\'' + name + '\\' should be written in camelCase';\r\n          }\r\n          break;\r\n        case 'pascalcase':\r\n          if (!helpers.isPascalCase(strippedName)) {\r\n            violationMessage = 'Variable \\'' + name + '\\' should be written in PascalCase';\r\n          }\r\n          break;\r\n        case 'snakecase':\r\n          if (!helpers.isSnakeCase(strippedName)) {\r\n            violationMessage = 'Variable \\'' + name + '\\' should be written in snake_case';\r\n          }\r\n          break;\r\n        case 'strictbem':\r\n          if (!helpers.isStrictBEM(strippedName)) {\r\n            violationMessage = 'Variable \\'' + name + '\\' should be written in BEM (Block Element Modifier) format';\r\n          }\r\n          break;\r\n        case 'hyphenatedbem':\r\n          if (!helpers.isHyphenatedBEM(strippedName)) {\r\n            violationMessage = 'Variable \\'' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\r\n          }\r\n          break;\r\n        default:\r\n          if (!new RegExp(parser.options.convention).test(strippedName)) {\r\n            violationMessage = 'Variable \\'' + name + '\\' should match regular expression /' + parser.options.convention + '/';\r\n\r\n            // convention-message overrides violationMessage\r\n            if (parser.options['convention-explanation']) {\r\n              violationMessage = parser.options['convention-explanation'];\r\n            }\r\n          }\r\n      }\r\n\r\n      if (violationMessage) {\r\n        result = helpers.addUnique(result, {\r\n          'ruleId': parser.rule.name,\r\n          'line': variable.start.line,\r\n          'column': variable.start.column,\r\n          'message': violationMessage,\r\n          'severity': parser.severity\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 86 */\r\n/***/ (function(module, exports, __nested_webpack_require_715518__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar helpers = __nested_webpack_require_715518__(0);\r\n\r\nvar units = ['em', 'ex', 'ch', 'rem', 'vh', 'vw', 'vmin', 'vmax', 'px', 'mm', 'cm', 'in', 'pt', 'pc'];\r\n\r\nmodule.exports = {\r\n  'name': 'zero-unit',\r\n  'defaults': {\r\n    'include': false\r\n  },\r\n  'detect': function detect(ast, parser) {\r\n    var result = [];\r\n\r\n    ast.traverseByType('number', function (item, i, parent) {\r\n\r\n      if (item.content === '0') {\r\n        if (parent.type === 'dimension') {\r\n          var next = parent.content[i + 1] || false;\r\n\r\n          if (units.indexOf(next.content) !== -1) {\r\n            if (!parser.options.include) {\r\n              result = helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'severity': parser.severity,\r\n                'line': item.end.line,\r\n                'column': item.end.column,\r\n                'message': 'No unit allowed for values of 0'\r\n              });\r\n            }\r\n          }\r\n        } else {\r\n          if (parent.type === 'value') {\r\n            if (parser.options.include) {\r\n              result = helpers.addUnique(result, {\r\n                'ruleId': parser.rule.name,\r\n                'severity': parser.severity,\r\n                'line': item.end.line,\r\n                'column': item.end.column,\r\n                'message': 'Unit required for values of 0'\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 87 */\r\n/***/ (function(module, exports, __nested_webpack_require_717053__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes, empty elements, or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  // if the path tries to go above the root, `up` ends up > 0\r\n  var up = 0;\r\n  for (var i = parts.length - 1; i >= 0; i--) {\r\n    var last = parts[i];\r\n    if (last === '.') {\r\n      parts.splice(i, 1);\r\n    } else if (last === '..') {\r\n      parts.splice(i, 1);\r\n      up++;\r\n    } else if (up) {\r\n      parts.splice(i, 1);\r\n      up--;\r\n    }\r\n  }\r\n\r\n  // if the path is allowed to go above the root, restore leading ..s\r\n  if (allowAboveRoot) {\r\n    for (; up--; up) {\r\n      parts.unshift('..');\r\n    }\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar splitPath = function(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n};\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nexports.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (typeof path !== 'string') {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path.charAt(0) === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\r\n    return !!p;\r\n  }), !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nexports.normalize = function(path) {\r\n  var isAbsolute = exports.isAbsolute(path),\r\n      trailingSlash = substr(path, -1) === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(filter(path.split('/'), function(p) {\r\n    return !!p;\r\n  }), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nexports.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nexports.join = function() {\r\n  var paths = Array.prototype.slice.call(arguments, 0);\r\n  return exports.normalize(filter(paths, function(p, index) {\r\n    if (typeof p !== 'string') {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    return p;\r\n  }).join('/'));\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nexports.relative = function(from, to) {\r\n  from = exports.resolve(from).substr(1);\r\n  to = exports.resolve(to).substr(1);\r\n\r\n  function trim(arr) {\r\n    var start = 0;\r\n    for (; start < arr.length; start++) {\r\n      if (arr[start] !== '') break;\r\n    }\r\n\r\n    var end = arr.length - 1;\r\n    for (; end >= 0; end--) {\r\n      if (arr[end] !== '') break;\r\n    }\r\n\r\n    if (start > end) return [];\r\n    return arr.slice(start, end - start + 1);\r\n  }\r\n\r\n  var fromParts = trim(from.split('/'));\r\n  var toParts = trim(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\nexports.sep = '/';\r\nexports.delimiter = ':';\r\n\r\nexports.dirname = function(path) {\r\n  var result = splitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nexports.basename = function(path, ext) {\r\n  var f = splitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nexports.extname = function(path) {\r\n  return splitPath(path)[3];\r\n};\r\n\r\nfunction filter (xs, f) {\r\n    if (xs.filter) return xs.filter(f);\r\n    var res = [];\r\n    for (var i = 0; i < xs.length; i++) {\r\n        if (f(xs[i], i, xs)) res.push(xs[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\n// String.prototype.substr - negative index don't work in IE8\r\nvar substr =  true\r\n    ? function (str, start, len) { return str.substr(start, len) }\r\n    : 0\r\n;\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_717053__(88)))\r\n\r\n/***/ }),\r\n/* 88 */\r\n/***/ (function(module, exports) {\r\n\r\n// shim for using process in browser\r\nvar process = module.exports = {};\r\n\r\n// cached from whatever global is present so that test runners that stub it\r\n// don't break things.  But we need to wrap it in a try catch in case it is\r\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\r\n// function because try/catches deoptimize in certain engines.\r\n\r\nvar cachedSetTimeout;\r\nvar cachedClearTimeout;\r\n\r\nfunction defaultSetTimout() {\r\n    throw new Error('setTimeout has not been defined');\r\n}\r\nfunction defaultClearTimeout () {\r\n    throw new Error('clearTimeout has not been defined');\r\n}\r\n(function () {\r\n    try {\r\n        if (typeof setTimeout === 'function') {\r\n            cachedSetTimeout = setTimeout;\r\n        } else {\r\n            cachedSetTimeout = defaultSetTimout;\r\n        }\r\n    } catch (e) {\r\n        cachedSetTimeout = defaultSetTimout;\r\n    }\r\n    try {\r\n        if (typeof clearTimeout === 'function') {\r\n            cachedClearTimeout = clearTimeout;\r\n        } else {\r\n            cachedClearTimeout = defaultClearTimeout;\r\n        }\r\n    } catch (e) {\r\n        cachedClearTimeout = defaultClearTimeout;\r\n    }\r\n} ())\r\nfunction runTimeout(fun) {\r\n    if (cachedSetTimeout === setTimeout) {\r\n        //normal enviroments in sane situations\r\n        return setTimeout(fun, 0);\r\n    }\r\n    // if setTimeout wasn't available but was latter defined\r\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\r\n        cachedSetTimeout = setTimeout;\r\n        return setTimeout(fun, 0);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedSetTimeout(fun, 0);\r\n    } catch(e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\r\n            return cachedSetTimeout.call(null, fun, 0);\r\n        } catch(e){\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\r\n            return cachedSetTimeout.call(this, fun, 0);\r\n        }\r\n    }\r\n\r\n\r\n}\r\nfunction runClearTimeout(marker) {\r\n    if (cachedClearTimeout === clearTimeout) {\r\n        //normal enviroments in sane situations\r\n        return clearTimeout(marker);\r\n    }\r\n    // if clearTimeout wasn't available but was latter defined\r\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\r\n        cachedClearTimeout = clearTimeout;\r\n        return clearTimeout(marker);\r\n    }\r\n    try {\r\n        // when when somebody has screwed with setTimeout but no I.E. maddness\r\n        return cachedClearTimeout(marker);\r\n    } catch (e){\r\n        try {\r\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\r\n            return cachedClearTimeout.call(null, marker);\r\n        } catch (e){\r\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\r\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\r\n            return cachedClearTimeout.call(this, marker);\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\nvar queue = [];\r\nvar draining = false;\r\nvar currentQueue;\r\nvar queueIndex = -1;\r\n\r\nfunction cleanUpNextTick() {\r\n    if (!draining || !currentQueue) {\r\n        return;\r\n    }\r\n    draining = false;\r\n    if (currentQueue.length) {\r\n        queue = currentQueue.concat(queue);\r\n    } else {\r\n        queueIndex = -1;\r\n    }\r\n    if (queue.length) {\r\n        drainQueue();\r\n    }\r\n}\r\n\r\nfunction drainQueue() {\r\n    if (draining) {\r\n        return;\r\n    }\r\n    var timeout = runTimeout(cleanUpNextTick);\r\n    draining = true;\r\n\r\n    var len = queue.length;\r\n    while(len) {\r\n        currentQueue = queue;\r\n        queue = [];\r\n        while (++queueIndex < len) {\r\n            if (currentQueue) {\r\n                currentQueue[queueIndex].run();\r\n            }\r\n        }\r\n        queueIndex = -1;\r\n        len = queue.length;\r\n    }\r\n    currentQueue = null;\r\n    draining = false;\r\n    runClearTimeout(timeout);\r\n}\r\n\r\nprocess.nextTick = function (fun) {\r\n    var args = new Array(arguments.length - 1);\r\n    if (arguments.length > 1) {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            args[i - 1] = arguments[i];\r\n        }\r\n    }\r\n    queue.push(new Item(fun, args));\r\n    if (queue.length === 1 && !draining) {\r\n        runTimeout(drainQueue);\r\n    }\r\n};\r\n\r\n// v8 likes predictible objects\r\nfunction Item(fun, array) {\r\n    this.fun = fun;\r\n    this.array = array;\r\n}\r\nItem.prototype.run = function () {\r\n    this.fun.apply(null, this.array);\r\n};\r\nprocess.title = 'browser';\r\nprocess.browser = true;\r\nprocess.env = {};\r\nprocess.argv = [];\r\nprocess.version = ''; // empty string to avoid regexp issues\r\nprocess.versions = {};\r\n\r\nfunction noop() {}\r\n\r\nprocess.on = noop;\r\nprocess.addListener = noop;\r\nprocess.once = noop;\r\nprocess.off = noop;\r\nprocess.removeListener = noop;\r\nprocess.removeAllListeners = noop;\r\nprocess.emit = noop;\r\n\r\nprocess.binding = function (name) {\r\n    throw new Error('process.binding is not supported');\r\n};\r\n\r\nprocess.cwd = function () { return '/' };\r\nprocess.chdir = function (dir) {\r\n    throw new Error('process.chdir is not supported');\r\n};\r\nprocess.umask = function() { return 0; };\r\n\r\n\r\n/***/ }),\r\n/* 89 */\r\n/***/ (function(module, exports, __nested_webpack_require_729205__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\r\n;(function(root) {\r\n\r\n\t/** Detect free variables */\r\n\tvar freeExports = typeof exports == 'object' && exports &&\r\n\t\t!exports.nodeType && exports;\r\n\tvar freeModule = typeof module == 'object' && module &&\r\n\t\t!module.nodeType && module;\r\n\tvar freeGlobal = typeof global == 'object' && global;\r\n\tif (\r\n\t\tfreeGlobal.global === freeGlobal ||\r\n\t\tfreeGlobal.window === freeGlobal ||\r\n\t\tfreeGlobal.self === freeGlobal\r\n\t) {\r\n\t\troot = freeGlobal;\r\n\t}\r\n\r\n\t/**\r\n\t * The `punycode` object.\r\n\t * @name punycode\r\n\t * @type Object\r\n\t */\r\n\tvar punycode,\r\n\r\n\t/** Highest positive signed 32-bit float value */\r\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n\t/** Bootstring parameters */\r\n\tbase = 36,\r\n\ttMin = 1,\r\n\ttMax = 26,\r\n\tskew = 38,\r\n\tdamp = 700,\r\n\tinitialBias = 72,\r\n\tinitialN = 128, // 0x80\r\n\tdelimiter = '-', // '\\x2D'\r\n\r\n\t/** Regular expressions */\r\n\tregexPunycode = /^xn--/,\r\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\r\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\r\n\r\n\t/** Error messages */\r\n\terrors = {\r\n\t\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t\t'invalid-input': 'Invalid input'\r\n\t},\r\n\r\n\t/** Convenience shortcuts */\r\n\tbaseMinusTMin = base - tMin,\r\n\tfloor = Math.floor,\r\n\tstringFromCharCode = String.fromCharCode,\r\n\r\n\t/** Temporary variable */\r\n\tkey;\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/**\r\n\t * A generic error utility function.\r\n\t * @private\r\n\t * @param {String} type The error type.\r\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n\t */\r\n\tfunction error(type) {\r\n\t\tthrow new RangeError(errors[type]);\r\n\t}\r\n\r\n\t/**\r\n\t * A generic `Array#map` utility function.\r\n\t * @private\r\n\t * @param {Array} array The array to iterate over.\r\n\t * @param {Function} callback The function that gets called for every array\r\n\t * item.\r\n\t * @returns {Array} A new array of values returned by the callback function.\r\n\t */\r\n\tfunction map(array, fn) {\r\n\t\tvar length = array.length;\r\n\t\tvar result = [];\r\n\t\twhile (length--) {\r\n\t\t\tresult[length] = fn(array[length]);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n\t * addresses.\r\n\t * @private\r\n\t * @param {String} domain The domain name or email address.\r\n\t * @param {Function} callback The function that gets called for every\r\n\t * character.\r\n\t * @returns {Array} A new string of characters returned by the callback\r\n\t * function.\r\n\t */\r\n\tfunction mapDomain(string, fn) {\r\n\t\tvar parts = string.split('@');\r\n\t\tvar result = '';\r\n\t\tif (parts.length > 1) {\r\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\t\tresult = parts[0] + '@';\r\n\t\t\tstring = parts[1];\r\n\t\t}\r\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\t\tstring = string.replace(regexSeparators, '\\x2E');\r\n\t\tvar labels = string.split('.');\r\n\t\tvar encoded = map(labels, fn).join('.');\r\n\t\treturn result + encoded;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an array containing the numeric code points of each Unicode\r\n\t * character in the string. While JavaScript uses UCS-2 internally,\r\n\t * this function will convert a pair of surrogate halves (each of which\r\n\t * UCS-2 exposes as separate characters) into a single code point,\r\n\t * matching UTF-16.\r\n\t * @see `punycode.ucs2.encode`\r\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t * @memberOf punycode.ucs2\r\n\t * @name decode\r\n\t * @param {String} string The Unicode input string (UCS-2).\r\n\t * @returns {Array} The new array of code points.\r\n\t */\r\n\tfunction ucs2decode(string) {\r\n\t\tvar output = [],\r\n\t\t    counter = 0,\r\n\t\t    length = string.length,\r\n\t\t    value,\r\n\t\t    extra;\r\n\t\twhile (counter < length) {\r\n\t\t\tvalue = string.charCodeAt(counter++);\r\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t\t// high surrogate, and there is a next character\r\n\t\t\t\textra = string.charCodeAt(counter++);\r\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\r\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\r\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\r\n\t\t\t\t\toutput.push(value);\r\n\t\t\t\t\tcounter--;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\toutput.push(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a string based on an array of numeric code points.\r\n\t * @see `punycode.ucs2.decode`\r\n\t * @memberOf punycode.ucs2\r\n\t * @name encode\r\n\t * @param {Array} codePoints The array of numeric code points.\r\n\t * @returns {String} The new Unicode string (UCS-2).\r\n\t */\r\n\tfunction ucs2encode(array) {\r\n\t\treturn map(array, function(value) {\r\n\t\t\tvar output = '';\r\n\t\t\tif (value > 0xFFFF) {\r\n\t\t\t\tvalue -= 0x10000;\r\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\r\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\r\n\t\t\t}\r\n\t\t\toutput += stringFromCharCode(value);\r\n\t\t\treturn output;\r\n\t\t}).join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a basic code point into a digit/integer.\r\n\t * @see `digitToBasic()`\r\n\t * @private\r\n\t * @param {Number} codePoint The basic numeric code point value.\r\n\t * @returns {Number} The numeric value of a basic code point (for use in\r\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\r\n\t * the code point does not represent a value.\r\n\t */\r\n\tfunction basicToDigit(codePoint) {\r\n\t\tif (codePoint - 48 < 10) {\r\n\t\t\treturn codePoint - 22;\r\n\t\t}\r\n\t\tif (codePoint - 65 < 26) {\r\n\t\t\treturn codePoint - 65;\r\n\t\t}\r\n\t\tif (codePoint - 97 < 26) {\r\n\t\t\treturn codePoint - 97;\r\n\t\t}\r\n\t\treturn base;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a digit/integer into a basic code point.\r\n\t * @see `basicToDigit()`\r\n\t * @private\r\n\t * @param {Number} digit The numeric value of a basic code point.\r\n\t * @returns {Number} The basic code point whose value (when used for\r\n\t * representing integers) is `digit`, which needs to be in the range\r\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n\t * used; else, the lowercase form is used. The behavior is undefined\r\n\t * if `flag` is non-zero and `digit` has no uppercase form.\r\n\t */\r\n\tfunction digitToBasic(digit, flag) {\r\n\t\t//  0..25 map to ASCII a..z or A..Z\r\n\t\t// 26..35 map to ASCII 0..9\r\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\r\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\r\n\t * @private\r\n\t */\r\n\tfunction adapt(delta, numPoints, firstTime) {\r\n\t\tvar k = 0;\r\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\t\tdelta += floor(delta / numPoints);\r\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\t\tdelta = floor(delta / baseMinusTMin);\r\n\t\t}\r\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n\t * symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycode string of ASCII-only symbols.\r\n\t * @returns {String} The resulting string of Unicode symbols.\r\n\t */\r\n\tfunction decode(input) {\r\n\t\t// Don't use UCS-2\r\n\t\tvar output = [],\r\n\t\t    inputLength = input.length,\r\n\t\t    out,\r\n\t\t    i = 0,\r\n\t\t    n = initialN,\r\n\t\t    bias = initialBias,\r\n\t\t    basic,\r\n\t\t    j,\r\n\t\t    index,\r\n\t\t    oldi,\r\n\t\t    w,\r\n\t\t    k,\r\n\t\t    digit,\r\n\t\t    t,\r\n\t\t    /** Cached calculation results */\r\n\t\t    baseMinusT;\r\n\r\n\t\t// Handle the basic code points: let `basic` be the number of input code\r\n\t\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t\t// the first basic code points to the output.\r\n\r\n\t\tbasic = input.lastIndexOf(delimiter);\r\n\t\tif (basic < 0) {\r\n\t\t\tbasic = 0;\r\n\t\t}\r\n\r\n\t\tfor (j = 0; j < basic; ++j) {\r\n\t\t\t// if it's not a basic code point\r\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\t\terror('not-basic');\r\n\t\t\t}\r\n\t\t\toutput.push(input.charCodeAt(j));\r\n\t\t}\r\n\r\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t\t// points were copied; start at the beginning otherwise.\r\n\r\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n\t\t\t// `index` is the index of the next character to be consumed.\r\n\t\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t\t// value at the end to obtain `delta`.\r\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\r\n\r\n\t\t\t\tif (index >= inputLength) {\r\n\t\t\t\t\terror('invalid-input');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti += digit * w;\r\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n\t\t\t\tif (digit < t) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tw *= baseMinusT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tout = output.length + 1;\r\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tn += floor(i / out);\r\n\t\t\ti %= out;\r\n\r\n\t\t\t// Insert `n` at position `i` of the output\r\n\t\t\toutput.splice(i++, 0, n);\r\n\r\n\t\t}\r\n\r\n\t\treturn ucs2encode(output);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n\t * Punycode string of ASCII-only symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The string of Unicode symbols.\r\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n\t */\r\n\tfunction encode(input) {\r\n\t\tvar n,\r\n\t\t    delta,\r\n\t\t    handledCPCount,\r\n\t\t    basicLength,\r\n\t\t    bias,\r\n\t\t    j,\r\n\t\t    m,\r\n\t\t    q,\r\n\t\t    k,\r\n\t\t    t,\r\n\t\t    currentValue,\r\n\t\t    output = [],\r\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\r\n\t\t    inputLength,\r\n\t\t    /** Cached calculation results */\r\n\t\t    handledCPCountPlusOne,\r\n\t\t    baseMinusT,\r\n\t\t    qMinusT;\r\n\r\n\t\t// Convert the input in UCS-2 to Unicode\r\n\t\tinput = ucs2decode(input);\r\n\r\n\t\t// Cache the length\r\n\t\tinputLength = input.length;\r\n\r\n\t\t// Initialize the state\r\n\t\tn = initialN;\r\n\t\tdelta = 0;\r\n\t\tbias = initialBias;\r\n\r\n\t\t// Handle the basic code points\r\n\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\tcurrentValue = input[j];\r\n\t\t\tif (currentValue < 0x80) {\r\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thandledCPCount = basicLength = output.length;\r\n\r\n\t\t// `handledCPCount` is the number of code points that have been handled;\r\n\t\t// `basicLength` is the number of basic code points.\r\n\r\n\t\t// Finish the basic string - if it is not empty - with a delimiter\r\n\t\tif (basicLength) {\r\n\t\t\toutput.push(delimiter);\r\n\t\t}\r\n\r\n\t\t// Main encoding loop:\r\n\t\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t\t// larger one:\r\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\t\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\t\tm = currentValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t\t// but guard against overflow\r\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\r\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\t\tn = m;\r\n\r\n\t\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\r\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (currentValue == n) {\r\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\r\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\r\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\t\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tqMinusT = q - t;\r\n\t\t\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\t\tdelta = 0;\r\n\t\t\t\t\t++handledCPCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t++delta;\r\n\t\t\t++n;\r\n\r\n\t\t}\r\n\t\treturn output.join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string representing a domain name or an email address\r\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n\t * it doesn't matter if you call it on a string that has already been\r\n\t * converted to Unicode.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycoded domain name or email address to\r\n\t * convert to Unicode.\r\n\t * @returns {String} The Unicode representation of the given Punycode\r\n\t * string.\r\n\t */\r\n\tfunction toUnicode(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexPunycode.test(string)\r\n\t\t\t\t? decode(string.slice(4).toLowerCase())\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Unicode string representing a domain name or an email address to\r\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n\t * i.e. it doesn't matter if you call it with a domain that's already in\r\n\t * ASCII.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The domain name or email address to convert, as a\r\n\t * Unicode string.\r\n\t * @returns {String} The Punycode representation of the given domain name or\r\n\t * email address.\r\n\t */\r\n\tfunction toASCII(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexNonASCII.test(string)\r\n\t\t\t\t? 'xn--' + encode(string)\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/** Define the public API */\r\n\tpunycode = {\r\n\t\t/**\r\n\t\t * A string representing the current Punycode.js version number.\r\n\t\t * @memberOf punycode\r\n\t\t * @type String\r\n\t\t */\r\n\t\t'version': '1.4.1',\r\n\t\t/**\r\n\t\t * An object of methods to convert from JavaScript's internal character\r\n\t\t * representation (UCS-2) to Unicode code points, and back.\r\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t\t * @memberOf punycode\r\n\t\t * @type Object\r\n\t\t */\r\n\t\t'ucs2': {\r\n\t\t\t'decode': ucs2decode,\r\n\t\t\t'encode': ucs2encode\r\n\t\t},\r\n\t\t'decode': decode,\r\n\t\t'encode': encode,\r\n\t\t'toASCII': toASCII,\r\n\t\t'toUnicode': toUnicode\r\n\t};\r\n\r\n\t/** Expose `punycode` */\r\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\r\n\t// like the following:\r\n\tif (\r\n\t\ttrue\r\n\t) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\r\n\t\t\treturn punycode;\r\n\t\t}.call(exports, __nested_webpack_require_729205__, exports, module),\r\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else {}\r\n\r\n}(this));\r\n\r\n/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_729205__(6)(module), __nested_webpack_require_729205__(2)))\r\n\r\n/***/ }),\r\n/* 90 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n// If obj.hasOwnProperty has been overridden, then calling\r\n// obj.hasOwnProperty(prop) will break.\r\n// See: https://github.com/joyent/node/issues/1707\r\nfunction hasOwnProperty(obj, prop) {\r\n  return Object.prototype.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nmodule.exports = function(qs, sep, eq, options) {\r\n  sep = sep || '&';\r\n  eq = eq || '=';\r\n  var obj = {};\r\n\r\n  if (typeof qs !== 'string' || qs.length === 0) {\r\n    return obj;\r\n  }\r\n\r\n  var regexp = /\\+/g;\r\n  qs = qs.split(sep);\r\n\r\n  var maxKeys = 1000;\r\n  if (options && typeof options.maxKeys === 'number') {\r\n    maxKeys = options.maxKeys;\r\n  }\r\n\r\n  var len = qs.length;\r\n  // maxKeys <= 0 means that we should not limit keys count\r\n  if (maxKeys > 0 && len > maxKeys) {\r\n    len = maxKeys;\r\n  }\r\n\r\n  for (var i = 0; i < len; ++i) {\r\n    var x = qs[i].replace(regexp, '%20'),\r\n        idx = x.indexOf(eq),\r\n        kstr, vstr, k, v;\r\n\r\n    if (idx >= 0) {\r\n      kstr = x.substr(0, idx);\r\n      vstr = x.substr(idx + 1);\r\n    } else {\r\n      kstr = x;\r\n      vstr = '';\r\n    }\r\n\r\n    k = decodeURIComponent(kstr);\r\n    v = decodeURIComponent(vstr);\r\n\r\n    if (!hasOwnProperty(obj, k)) {\r\n      obj[k] = v;\r\n    } else if (isArray(obj[k])) {\r\n      obj[k].push(v);\r\n    } else {\r\n      obj[k] = [obj[k], v];\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\nvar isArray = Array.isArray || function (xs) {\r\n  return Object.prototype.toString.call(xs) === '[object Array]';\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 91 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\nvar stringifyPrimitive = function(v) {\r\n  switch (typeof v) {\r\n    case 'string':\r\n      return v;\r\n\r\n    case 'boolean':\r\n      return v ? 'true' : 'false';\r\n\r\n    case 'number':\r\n      return isFinite(v) ? v : '';\r\n\r\n    default:\r\n      return '';\r\n  }\r\n};\r\n\r\nmodule.exports = function(obj, sep, eq, name) {\r\n  sep = sep || '&';\r\n  eq = eq || '=';\r\n  if (obj === null) {\r\n    obj = undefined;\r\n  }\r\n\r\n  if (typeof obj === 'object') {\r\n    return map(objectKeys(obj), function(k) {\r\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\r\n      if (isArray(obj[k])) {\r\n        return map(obj[k], function(v) {\r\n          return ks + encodeURIComponent(stringifyPrimitive(v));\r\n        }).join(sep);\r\n      } else {\r\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\r\n      }\r\n    }).join(sep);\r\n\r\n  }\r\n\r\n  if (!name) return '';\r\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\r\n         encodeURIComponent(stringifyPrimitive(obj));\r\n};\r\n\r\nvar isArray = Array.isArray || function (xs) {\r\n  return Object.prototype.toString.call(xs) === '[object Array]';\r\n};\r\n\r\nfunction map (xs, f) {\r\n  if (xs.map) return xs.map(f);\r\n  var res = [];\r\n  for (var i = 0; i < xs.length; i++) {\r\n    res.push(f(xs[i], i));\r\n  }\r\n  return res;\r\n}\r\n\r\nvar objectKeys = Object.keys || function (obj) {\r\n  var res = [];\r\n  for (var key in obj) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\r\n  }\r\n  return res;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 92 */\r\n/***/ (function(module, exports, __nested_webpack_require_750169__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nexports.decode = exports.parse = __nested_webpack_require_750169__(90);\r\nexports.encode = exports.stringify = __nested_webpack_require_750169__(91);\r\n\r\n\r\n/***/ }),\r\n/* 93 */\r\n/***/ (function(module, exports, __nested_webpack_require_750394__) {\r\n\r\n\"use strict\";\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\nvar punycode = __nested_webpack_require_750394__(89);\r\nvar util = __nested_webpack_require_750394__(94);\r\n\r\nexports.parse = urlParse;\r\nexports.resolve = urlResolve;\r\nexports.resolveObject = urlResolveObject;\r\nexports.format = urlFormat;\r\n\r\nexports.Url = Url;\r\n\r\nfunction Url() {\r\n  this.protocol = null;\r\n  this.slashes = null;\r\n  this.auth = null;\r\n  this.host = null;\r\n  this.port = null;\r\n  this.hostname = null;\r\n  this.hash = null;\r\n  this.search = null;\r\n  this.query = null;\r\n  this.pathname = null;\r\n  this.path = null;\r\n  this.href = null;\r\n}\r\n\r\n// Reference: RFC 3986, RFC 1808, RFC 2396\r\n\r\n// define these here so at least they only have to be\r\n// compiled once on the first module load.\r\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\r\n    portPattern = /:[0-9]*$/,\r\n\r\n    // Special case for a simple path URL\r\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\r\n\r\n    // RFC 2396: characters reserved for delimiting URLs.\r\n    // We actually just auto-escape these.\r\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\r\n\r\n    // RFC 2396: characters not allowed for various reasons.\r\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\r\n\r\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\r\n    autoEscape = ['\\''].concat(unwise),\r\n    // Characters that are never ever allowed in a hostname.\r\n    // Note that any invalid chars are also handled, but these\r\n    // are the ones that are *expected* to be seen, so we fast-path\r\n    // them.\r\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\r\n    hostEndingChars = ['/', '?', '#'],\r\n    hostnameMaxLen = 255,\r\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\r\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\r\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\r\n    unsafeProtocol = {\r\n      'javascript': true,\r\n      'javascript:': true\r\n    },\r\n    // protocols that never have a hostname.\r\n    hostlessProtocol = {\r\n      'javascript': true,\r\n      'javascript:': true\r\n    },\r\n    // protocols that always contain a // bit.\r\n    slashedProtocol = {\r\n      'http': true,\r\n      'https': true,\r\n      'ftp': true,\r\n      'gopher': true,\r\n      'file': true,\r\n      'http:': true,\r\n      'https:': true,\r\n      'ftp:': true,\r\n      'gopher:': true,\r\n      'file:': true\r\n    },\r\n    querystring = __nested_webpack_require_750394__(92);\r\n\r\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\r\n  if (url && util.isObject(url) && url instanceof Url) return url;\r\n\r\n  var u = new Url;\r\n  u.parse(url, parseQueryString, slashesDenoteHost);\r\n  return u;\r\n}\r\n\r\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\r\n  if (!util.isString(url)) {\r\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\r\n  }\r\n\r\n  // Copy chrome, IE, opera backslash-handling behavior.\r\n  // Back slashes before the query string get converted to forward slashes\r\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\r\n  var queryIndex = url.indexOf('?'),\r\n      splitter =\r\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\r\n      uSplit = url.split(splitter),\r\n      slashRegex = /\\\\/g;\r\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\r\n  url = uSplit.join(splitter);\r\n\r\n  var rest = url;\r\n\r\n  // trim before proceeding.\r\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\r\n  rest = rest.trim();\r\n\r\n  if (!slashesDenoteHost && url.split('#').length === 1) {\r\n    // Try fast path regexp\r\n    var simplePath = simplePathPattern.exec(rest);\r\n    if (simplePath) {\r\n      this.path = rest;\r\n      this.href = rest;\r\n      this.pathname = simplePath[1];\r\n      if (simplePath[2]) {\r\n        this.search = simplePath[2];\r\n        if (parseQueryString) {\r\n          this.query = querystring.parse(this.search.substr(1));\r\n        } else {\r\n          this.query = this.search.substr(1);\r\n        }\r\n      } else if (parseQueryString) {\r\n        this.search = '';\r\n        this.query = {};\r\n      }\r\n      return this;\r\n    }\r\n  }\r\n\r\n  var proto = protocolPattern.exec(rest);\r\n  if (proto) {\r\n    proto = proto[0];\r\n    var lowerProto = proto.toLowerCase();\r\n    this.protocol = lowerProto;\r\n    rest = rest.substr(proto.length);\r\n  }\r\n\r\n  // figure out if it's got a host\r\n  // user@server is *always* interpreted as a hostname, and url\r\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\r\n  // how the browser resolves relative URLs.\r\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\r\n    var slashes = rest.substr(0, 2) === '//';\r\n    if (slashes && !(proto && hostlessProtocol[proto])) {\r\n      rest = rest.substr(2);\r\n      this.slashes = true;\r\n    }\r\n  }\r\n\r\n  if (!hostlessProtocol[proto] &&\r\n      (slashes || (proto && !slashedProtocol[proto]))) {\r\n\r\n    // there's a hostname.\r\n    // the first instance of /, ?, ;, or # ends the host.\r\n    //\r\n    // If there is an @ in the hostname, then non-host chars *are* allowed\r\n    // to the left of the last @ sign, unless some host-ending character\r\n    // comes *before* the @-sign.\r\n    // URLs are obnoxious.\r\n    //\r\n    // ex:\r\n    // http://a@b@c/ => user:a@b host:c\r\n    // http://a@b?@c => user:a host:c path:/?@c\r\n\r\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\r\n    // Review our test case against browsers more comprehensively.\r\n\r\n    // find the first instance of any hostEndingChars\r\n    var hostEnd = -1;\r\n    for (var i = 0; i < hostEndingChars.length; i++) {\r\n      var hec = rest.indexOf(hostEndingChars[i]);\r\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\r\n        hostEnd = hec;\r\n    }\r\n\r\n    // at this point, either we have an explicit point where the\r\n    // auth portion cannot go past, or the last @ char is the decider.\r\n    var auth, atSign;\r\n    if (hostEnd === -1) {\r\n      // atSign can be anywhere.\r\n      atSign = rest.lastIndexOf('@');\r\n    } else {\r\n      // atSign must be in auth portion.\r\n      // http://a@b/c@d => host:b auth:a path:/c@d\r\n      atSign = rest.lastIndexOf('@', hostEnd);\r\n    }\r\n\r\n    // Now we have a portion which is definitely the auth.\r\n    // Pull that off.\r\n    if (atSign !== -1) {\r\n      auth = rest.slice(0, atSign);\r\n      rest = rest.slice(atSign + 1);\r\n      this.auth = decodeURIComponent(auth);\r\n    }\r\n\r\n    // the host is the remaining to the left of the first non-host char\r\n    hostEnd = -1;\r\n    for (var i = 0; i < nonHostChars.length; i++) {\r\n      var hec = rest.indexOf(nonHostChars[i]);\r\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\r\n        hostEnd = hec;\r\n    }\r\n    // if we still have not hit it, then the entire thing is a host.\r\n    if (hostEnd === -1)\r\n      hostEnd = rest.length;\r\n\r\n    this.host = rest.slice(0, hostEnd);\r\n    rest = rest.slice(hostEnd);\r\n\r\n    // pull out port.\r\n    this.parseHost();\r\n\r\n    // we've indicated that there is a hostname,\r\n    // so even if it's empty, it has to be present.\r\n    this.hostname = this.hostname || '';\r\n\r\n    // if hostname begins with [ and ends with ]\r\n    // assume that it's an IPv6 address.\r\n    var ipv6Hostname = this.hostname[0] === '[' &&\r\n        this.hostname[this.hostname.length - 1] === ']';\r\n\r\n    // validate a little.\r\n    if (!ipv6Hostname) {\r\n      var hostparts = this.hostname.split(/\\./);\r\n      for (var i = 0, l = hostparts.length; i < l; i++) {\r\n        var part = hostparts[i];\r\n        if (!part) continue;\r\n        if (!part.match(hostnamePartPattern)) {\r\n          var newpart = '';\r\n          for (var j = 0, k = part.length; j < k; j++) {\r\n            if (part.charCodeAt(j) > 127) {\r\n              // we replace non-ASCII char with a temporary placeholder\r\n              // we need this to make sure size of hostname is not\r\n              // broken by replacing non-ASCII by nothing\r\n              newpart += 'x';\r\n            } else {\r\n              newpart += part[j];\r\n            }\r\n          }\r\n          // we test again with ASCII char only\r\n          if (!newpart.match(hostnamePartPattern)) {\r\n            var validParts = hostparts.slice(0, i);\r\n            var notHost = hostparts.slice(i + 1);\r\n            var bit = part.match(hostnamePartStart);\r\n            if (bit) {\r\n              validParts.push(bit[1]);\r\n              notHost.unshift(bit[2]);\r\n            }\r\n            if (notHost.length) {\r\n              rest = '/' + notHost.join('.') + rest;\r\n            }\r\n            this.hostname = validParts.join('.');\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.hostname.length > hostnameMaxLen) {\r\n      this.hostname = '';\r\n    } else {\r\n      // hostnames are always lower case.\r\n      this.hostname = this.hostname.toLowerCase();\r\n    }\r\n\r\n    if (!ipv6Hostname) {\r\n      // IDNA Support: Returns a punycoded representation of \"domain\".\r\n      // It only converts parts of the domain name that\r\n      // have non-ASCII characters, i.e. it doesn't matter if\r\n      // you call it with a domain that already is ASCII-only.\r\n      this.hostname = punycode.toASCII(this.hostname);\r\n    }\r\n\r\n    var p = this.port ? ':' + this.port : '';\r\n    var h = this.hostname || '';\r\n    this.host = h + p;\r\n    this.href += this.host;\r\n\r\n    // strip [ and ] from the hostname\r\n    // the host field still retains them, though\r\n    if (ipv6Hostname) {\r\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\r\n      if (rest[0] !== '/') {\r\n        rest = '/' + rest;\r\n      }\r\n    }\r\n  }\r\n\r\n  // now rest is set to the post-host stuff.\r\n  // chop off any delim chars.\r\n  if (!unsafeProtocol[lowerProto]) {\r\n\r\n    // First, make 100% sure that any \"autoEscape\" chars get\r\n    // escaped, even if encodeURIComponent doesn't think they\r\n    // need to be.\r\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\r\n      var ae = autoEscape[i];\r\n      if (rest.indexOf(ae) === -1)\r\n        continue;\r\n      var esc = encodeURIComponent(ae);\r\n      if (esc === ae) {\r\n        esc = escape(ae);\r\n      }\r\n      rest = rest.split(ae).join(esc);\r\n    }\r\n  }\r\n\r\n\r\n  // chop off from the tail first.\r\n  var hash = rest.indexOf('#');\r\n  if (hash !== -1) {\r\n    // got a fragment string.\r\n    this.hash = rest.substr(hash);\r\n    rest = rest.slice(0, hash);\r\n  }\r\n  var qm = rest.indexOf('?');\r\n  if (qm !== -1) {\r\n    this.search = rest.substr(qm);\r\n    this.query = rest.substr(qm + 1);\r\n    if (parseQueryString) {\r\n      this.query = querystring.parse(this.query);\r\n    }\r\n    rest = rest.slice(0, qm);\r\n  } else if (parseQueryString) {\r\n    // no query string, but parseQueryString still requested\r\n    this.search = '';\r\n    this.query = {};\r\n  }\r\n  if (rest) this.pathname = rest;\r\n  if (slashedProtocol[lowerProto] &&\r\n      this.hostname && !this.pathname) {\r\n    this.pathname = '/';\r\n  }\r\n\r\n  //to support http.request\r\n  if (this.pathname || this.search) {\r\n    var p = this.pathname || '';\r\n    var s = this.search || '';\r\n    this.path = p + s;\r\n  }\r\n\r\n  // finally, reconstruct the href based on what has been validated.\r\n  this.href = this.format();\r\n  return this;\r\n};\r\n\r\n// format a parsed object into a url string\r\nfunction urlFormat(obj) {\r\n  // ensure it's an object, and not a string url.\r\n  // If it's an obj, this is a no-op.\r\n  // this way, you can call url_format() on strings\r\n  // to clean up potentially wonky urls.\r\n  if (util.isString(obj)) obj = urlParse(obj);\r\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\r\n  return obj.format();\r\n}\r\n\r\nUrl.prototype.format = function() {\r\n  var auth = this.auth || '';\r\n  if (auth) {\r\n    auth = encodeURIComponent(auth);\r\n    auth = auth.replace(/%3A/i, ':');\r\n    auth += '@';\r\n  }\r\n\r\n  var protocol = this.protocol || '',\r\n      pathname = this.pathname || '',\r\n      hash = this.hash || '',\r\n      host = false,\r\n      query = '';\r\n\r\n  if (this.host) {\r\n    host = auth + this.host;\r\n  } else if (this.hostname) {\r\n    host = auth + (this.hostname.indexOf(':') === -1 ?\r\n        this.hostname :\r\n        '[' + this.hostname + ']');\r\n    if (this.port) {\r\n      host += ':' + this.port;\r\n    }\r\n  }\r\n\r\n  if (this.query &&\r\n      util.isObject(this.query) &&\r\n      Object.keys(this.query).length) {\r\n    query = querystring.stringify(this.query);\r\n  }\r\n\r\n  var search = this.search || (query && ('?' + query)) || '';\r\n\r\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\r\n\r\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\r\n  // unless they had them to begin with.\r\n  if (this.slashes ||\r\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\r\n    host = '//' + (host || '');\r\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\r\n  } else if (!host) {\r\n    host = '';\r\n  }\r\n\r\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\r\n  if (search && search.charAt(0) !== '?') search = '?' + search;\r\n\r\n  pathname = pathname.replace(/[?#]/g, function(match) {\r\n    return encodeURIComponent(match);\r\n  });\r\n  search = search.replace('#', '%23');\r\n\r\n  return protocol + host + pathname + search + hash;\r\n};\r\n\r\nfunction urlResolve(source, relative) {\r\n  return urlParse(source, false, true).resolve(relative);\r\n}\r\n\r\nUrl.prototype.resolve = function(relative) {\r\n  return this.resolveObject(urlParse(relative, false, true)).format();\r\n};\r\n\r\nfunction urlResolveObject(source, relative) {\r\n  if (!source) return relative;\r\n  return urlParse(source, false, true).resolveObject(relative);\r\n}\r\n\r\nUrl.prototype.resolveObject = function(relative) {\r\n  if (util.isString(relative)) {\r\n    var rel = new Url();\r\n    rel.parse(relative, false, true);\r\n    relative = rel;\r\n  }\r\n\r\n  var result = new Url();\r\n  var tkeys = Object.keys(this);\r\n  for (var tk = 0; tk < tkeys.length; tk++) {\r\n    var tkey = tkeys[tk];\r\n    result[tkey] = this[tkey];\r\n  }\r\n\r\n  // hash is always overridden, no matter what.\r\n  // even href=\"\" will remove it.\r\n  result.hash = relative.hash;\r\n\r\n  // if the relative url is empty, then there's nothing left to do here.\r\n  if (relative.href === '') {\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  // hrefs like //foo/bar always cut to the protocol.\r\n  if (relative.slashes && !relative.protocol) {\r\n    // take everything except the protocol from relative\r\n    var rkeys = Object.keys(relative);\r\n    for (var rk = 0; rk < rkeys.length; rk++) {\r\n      var rkey = rkeys[rk];\r\n      if (rkey !== 'protocol')\r\n        result[rkey] = relative[rkey];\r\n    }\r\n\r\n    //urlParse appends trailing / to urls like http://www.example.com\r\n    if (slashedProtocol[result.protocol] &&\r\n        result.hostname && !result.pathname) {\r\n      result.path = result.pathname = '/';\r\n    }\r\n\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  if (relative.protocol && relative.protocol !== result.protocol) {\r\n    // if it's a known url protocol, then changing\r\n    // the protocol does weird things\r\n    // first, if it's not file:, then we MUST have a host,\r\n    // and if there was a path\r\n    // to begin with, then we MUST have a path.\r\n    // if it is file:, then the host is dropped,\r\n    // because that's known to be hostless.\r\n    // anything else is assumed to be absolute.\r\n    if (!slashedProtocol[relative.protocol]) {\r\n      var keys = Object.keys(relative);\r\n      for (var v = 0; v < keys.length; v++) {\r\n        var k = keys[v];\r\n        result[k] = relative[k];\r\n      }\r\n      result.href = result.format();\r\n      return result;\r\n    }\r\n\r\n    result.protocol = relative.protocol;\r\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\r\n      var relPath = (relative.pathname || '').split('/');\r\n      while (relPath.length && !(relative.host = relPath.shift()));\r\n      if (!relative.host) relative.host = '';\r\n      if (!relative.hostname) relative.hostname = '';\r\n      if (relPath[0] !== '') relPath.unshift('');\r\n      if (relPath.length < 2) relPath.unshift('');\r\n      result.pathname = relPath.join('/');\r\n    } else {\r\n      result.pathname = relative.pathname;\r\n    }\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n    result.host = relative.host || '';\r\n    result.auth = relative.auth;\r\n    result.hostname = relative.hostname || relative.host;\r\n    result.port = relative.port;\r\n    // to support http.request\r\n    if (result.pathname || result.search) {\r\n      var p = result.pathname || '';\r\n      var s = result.search || '';\r\n      result.path = p + s;\r\n    }\r\n    result.slashes = result.slashes || relative.slashes;\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\r\n      isRelAbs = (\r\n          relative.host ||\r\n          relative.pathname && relative.pathname.charAt(0) === '/'\r\n      ),\r\n      mustEndAbs = (isRelAbs || isSourceAbs ||\r\n                    (result.host && relative.pathname)),\r\n      removeAllDots = mustEndAbs,\r\n      srcPath = result.pathname && result.pathname.split('/') || [],\r\n      relPath = relative.pathname && relative.pathname.split('/') || [],\r\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\r\n\r\n  // if the url is a non-slashed url, then relative\r\n  // links like ../.. should be able\r\n  // to crawl up to the hostname, as well.  This is strange.\r\n  // result.protocol has already been set by now.\r\n  // Later on, put the first path part into the host field.\r\n  if (psychotic) {\r\n    result.hostname = '';\r\n    result.port = null;\r\n    if (result.host) {\r\n      if (srcPath[0] === '') srcPath[0] = result.host;\r\n      else srcPath.unshift(result.host);\r\n    }\r\n    result.host = '';\r\n    if (relative.protocol) {\r\n      relative.hostname = null;\r\n      relative.port = null;\r\n      if (relative.host) {\r\n        if (relPath[0] === '') relPath[0] = relative.host;\r\n        else relPath.unshift(relative.host);\r\n      }\r\n      relative.host = null;\r\n    }\r\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\r\n  }\r\n\r\n  if (isRelAbs) {\r\n    // it's absolute.\r\n    result.host = (relative.host || relative.host === '') ?\r\n                  relative.host : result.host;\r\n    result.hostname = (relative.hostname || relative.hostname === '') ?\r\n                      relative.hostname : result.hostname;\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n    srcPath = relPath;\r\n    // fall through to the dot-handling below.\r\n  } else if (relPath.length) {\r\n    // it's relative\r\n    // throw away the existing file, and take the new path instead.\r\n    if (!srcPath) srcPath = [];\r\n    srcPath.pop();\r\n    srcPath = srcPath.concat(relPath);\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n  } else if (!util.isNullOrUndefined(relative.search)) {\r\n    // just pull out the search.\r\n    // like href='?foo'.\r\n    // Put this after the other two cases because it simplifies the booleans\r\n    if (psychotic) {\r\n      result.hostname = result.host = srcPath.shift();\r\n      //occationaly the auth can get stuck only in host\r\n      //this especially happens in cases like\r\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\r\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\r\n                       result.host.split('@') : false;\r\n      if (authInHost) {\r\n        result.auth = authInHost.shift();\r\n        result.host = result.hostname = authInHost.shift();\r\n      }\r\n    }\r\n    result.search = relative.search;\r\n    result.query = relative.query;\r\n    //to support http.request\r\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\r\n      result.path = (result.pathname ? result.pathname : '') +\r\n                    (result.search ? result.search : '');\r\n    }\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  if (!srcPath.length) {\r\n    // no path at all.  easy.\r\n    // we've already handled the other stuff above.\r\n    result.pathname = null;\r\n    //to support http.request\r\n    if (result.search) {\r\n      result.path = '/' + result.search;\r\n    } else {\r\n      result.path = null;\r\n    }\r\n    result.href = result.format();\r\n    return result;\r\n  }\r\n\r\n  // if a url ENDs in . or .., then it must get a trailing slash.\r\n  // however, if it ends in anything else non-slashy,\r\n  // then it must NOT get a trailing slash.\r\n  var last = srcPath.slice(-1)[0];\r\n  var hasTrailingSlash = (\r\n      (result.host || relative.host || srcPath.length > 1) &&\r\n      (last === '.' || last === '..') || last === '');\r\n\r\n  // strip single dots, resolve double dots to parent dir\r\n  // if the path tries to go above the root, `up` ends up > 0\r\n  var up = 0;\r\n  for (var i = srcPath.length; i >= 0; i--) {\r\n    last = srcPath[i];\r\n    if (last === '.') {\r\n      srcPath.splice(i, 1);\r\n    } else if (last === '..') {\r\n      srcPath.splice(i, 1);\r\n      up++;\r\n    } else if (up) {\r\n      srcPath.splice(i, 1);\r\n      up--;\r\n    }\r\n  }\r\n\r\n  // if the path is allowed to go above the root, restore leading ..s\r\n  if (!mustEndAbs && !removeAllDots) {\r\n    for (; up--; up) {\r\n      srcPath.unshift('..');\r\n    }\r\n  }\r\n\r\n  if (mustEndAbs && srcPath[0] !== '' &&\r\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\r\n    srcPath.unshift('');\r\n  }\r\n\r\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\r\n    srcPath.push('');\r\n  }\r\n\r\n  var isAbsolute = srcPath[0] === '' ||\r\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\r\n\r\n  // put the host back\r\n  if (psychotic) {\r\n    result.hostname = result.host = isAbsolute ? '' :\r\n                                    srcPath.length ? srcPath.shift() : '';\r\n    //occationaly the auth can get stuck only in host\r\n    //this especially happens in cases like\r\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\r\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\r\n                     result.host.split('@') : false;\r\n    if (authInHost) {\r\n      result.auth = authInHost.shift();\r\n      result.host = result.hostname = authInHost.shift();\r\n    }\r\n  }\r\n\r\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\r\n\r\n  if (mustEndAbs && !isAbsolute) {\r\n    srcPath.unshift('');\r\n  }\r\n\r\n  if (!srcPath.length) {\r\n    result.pathname = null;\r\n    result.path = null;\r\n  } else {\r\n    result.pathname = srcPath.join('/');\r\n  }\r\n\r\n  //to support request.http\r\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\r\n    result.path = (result.pathname ? result.pathname : '') +\r\n                  (result.search ? result.search : '');\r\n  }\r\n  result.auth = relative.auth || result.auth;\r\n  result.slashes = result.slashes || relative.slashes;\r\n  result.href = result.format();\r\n  return result;\r\n};\r\n\r\nUrl.prototype.parseHost = function() {\r\n  var host = this.host;\r\n  var port = portPattern.exec(host);\r\n  if (port) {\r\n    port = port[0];\r\n    if (port !== ':') {\r\n      this.port = port.substr(1);\r\n    }\r\n    host = host.substr(0, host.length - port.length);\r\n  }\r\n  if (host) this.hostname = host;\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 94 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = {\r\n  isString: function(arg) {\r\n    return typeof(arg) === 'string';\r\n  },\r\n  isObject: function(arg) {\r\n    return typeof(arg) === 'object' && arg !== null;\r\n  },\r\n  isNull: function(arg) {\r\n    return arg === null;\r\n  },\r\n  isNullOrUndefined: function(arg) {\r\n    return arg == null;\r\n  }\r\n};\r\n\r\n\r\n/***/ }),\r\n/* 95 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = [\r\n\t\"abs\",\r\n\t\"adjust-color\",\r\n\t\"adjust-hue\",\r\n\t\"alpha\",\r\n\t\"annotation\",\r\n\t\"append\",\r\n\t\"blue\",\r\n\t\"blur\",\r\n\t\"brightness\",\r\n\t\"calc\",\r\n\t\"call\",\r\n\t\"ceil\",\r\n\t\"change-color\",\r\n\t\"character-variant\",\r\n\t\"circle\",\r\n\t\"comparable\",\r\n\t\"complement\",\r\n\t\"contrast\",\r\n\t\"cubic-bezier\",\r\n\t\"custom\",\r\n\t\"darken\",\r\n\t\"desaturate\",\r\n\t\"drop-shadow\",\r\n\t\"element\",\r\n\t\"ellipse\",\r\n\t\"feature-exists\",\r\n\t\"floor\",\r\n\t\"function-exists\",\r\n\t\"global-variable-exists\",\r\n\t\"grayscale\",\r\n\t\"green\",\r\n\t\"hue\",\r\n\t\"hue-rotate\",\r\n\t\"hsl\",\r\n\t\"hsla\",\r\n\t\"if\",\r\n\t\"index\",\r\n\t\"inset\",\r\n\t\"inspect\",\r\n\t\"invert\",\r\n\t\"is-hex-str\",\r\n\t\"is-superselector\",\r\n\t\"join\",\r\n\t\"keywords\",\r\n\t\"length\",\r\n\t\"lighten\",\r\n\t\"lightness\",\r\n\t\"linear-gradient\",\r\n\t\"list-separator\",\r\n\t\"map-get\",\r\n\t\"map-has-key\",\r\n\t\"map-keys\",\r\n\t\"map-merge\",\r\n\t\"map-remove\",\r\n\t\"map-values\",\r\n\t\"matrix\",\r\n\t\"matrix3d\",\r\n\t\"min\",\r\n\t\"max\",\r\n\t\"mix\",\r\n\t\"mixin-exists\",\r\n\t\"nth\",\r\n\t\"ornaments\",\r\n\t\"opacify\",\r\n\t\"opacity\",\r\n\t\"percentage\",\r\n\t\"perspective\",\r\n\t\"polygon\",\r\n\t\"quote\",\r\n\t\"radial-gradient\",\r\n\t\"random\",\r\n\t\"rect\",\r\n\t\"red\",\r\n\t\"repeat\",\r\n\t\"repeating-linear-gradient\",\r\n\t\"repeating-radial-gradient\",\r\n\t\"rgb\",\r\n\t\"rgba\",\r\n\t\"rotate\",\r\n\t\"rotateX\",\r\n\t\"rotateY\",\r\n\t\"rotateZ\",\r\n\t\"rotate3d\",\r\n\t\"round\",\r\n\t\"saturate\",\r\n\t\"saturation\",\r\n\t\"scale\",\r\n\t\"scale-color\",\r\n\t\"scaleX\",\r\n\t\"scaleY\",\r\n\t\"scaleZ\",\r\n\t\"scale3d\",\r\n\t\"selector-nest\",\r\n\t\"selector-append\",\r\n\t\"selector-extend\",\r\n\t\"selector-replace\",\r\n\t\"selector-unify\",\r\n\t\"simple-selectors\",\r\n\t\"selector-parse\",\r\n\t\"set-nth\",\r\n\t\"sepia\",\r\n\t\"skewX\",\r\n\t\"skewY\",\r\n\t\"steps\",\r\n\t\"str-index\",\r\n\t\"str-insert\",\r\n\t\"str-length\",\r\n\t\"str-slice\",\r\n\t\"styleset\",\r\n\t\"stylistic\",\r\n\t\"swash\",\r\n\t\"symbols\",\r\n\t\"to-lower-case\",\r\n\t\"to-upper-case\",\r\n\t\"translate\",\r\n\t\"translateX\",\r\n\t\"translateY\",\r\n\t\"translateZ\",\r\n\t\"translate3d\",\r\n\t\"transparentize\",\r\n\t\"type-of\",\r\n\t\"unique-id\",\r\n\t\"unit\",\r\n\t\"unitless\",\r\n\t\"unquote\",\r\n\t\"url\",\r\n\t\"var\",\r\n\t\"variable-exists\",\r\n\t\"zip\"\r\n];\r\n\r\n/***/ }),\r\n/* 96 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = [\r\n\t\"active\",\r\n\t\"checked\",\r\n\t\"default\",\r\n\t\"disabled\",\r\n\t\"empty\",\r\n\t\"enabled\",\r\n\t\"first\",\r\n\t\"first-child\",\r\n\t\"first-of-type\",\r\n\t\"focus\",\r\n\t\"hover\",\r\n\t\"indeterminate\",\r\n\t\"in-range\",\r\n\t\"invalid\",\r\n\t\"lang\",\r\n\t\"last-child\",\r\n\t\"last-of-type\",\r\n\t\"left\",\r\n\t\"link\",\r\n\t\"not\",\r\n\t\"nth-child\",\r\n\t\"nth-last-child\",\r\n\t\"nth-last-of-type\",\r\n\t\"nth-of-type\",\r\n\t\"only-child\",\r\n\t\"only-of-type\",\r\n\t\"optional\",\r\n\t\"out-of-range\",\r\n\t\"read-only\",\r\n\t\"read-write\",\r\n\t\"required\",\r\n\t\"right\",\r\n\t\"root\",\r\n\t\"target\",\r\n\t\"valid\",\r\n\t\"visited\"\r\n];\r\n\r\n/***/ }),\r\n/* 97 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = [\r\n\t\"after\",\r\n\t\"before\",\r\n\t\"first-letter\",\r\n\t\"first-line\",\r\n\t\"selection\",\r\n\t\"backdrop\"\r\n];\r\n\r\n/***/ }),\r\n/* 98 */\r\n/***/ (function(module, exports, __nested_webpack_require_777661__) {\r\n\r\nvar map = {\r\n\t\"./attribute-quotes.js\": 14,\r\n\t\"./bem-depth.js\": 15,\r\n\t\"./border-zero.js\": 16,\r\n\t\"./brace-style.js\": 17,\r\n\t\"./class-name-format.js\": 18,\r\n\t\"./clean-import-paths.js\": 19,\r\n\t\"./declarations-before-nesting.js\": 20,\r\n\t\"./empty-args.js\": 21,\r\n\t\"./empty-line-between-blocks.js\": 22,\r\n\t\"./extends-before-declarations.js\": 23,\r\n\t\"./extends-before-mixins.js\": 24,\r\n\t\"./final-newline.js\": 25,\r\n\t\"./force-attribute-nesting.js\": 26,\r\n\t\"./force-element-nesting.js\": 27,\r\n\t\"./force-pseudo-nesting.js\": 28,\r\n\t\"./function-name-format.js\": 29,\r\n\t\"./hex-length.js\": 30,\r\n\t\"./hex-notation.js\": 31,\r\n\t\"./id-name-format.js\": 32,\r\n\t\"./indentation.js\": 33,\r\n\t\"./leading-zero.js\": 34,\r\n\t\"./max-file-line-count.js\": 35,\r\n\t\"./max-line-length.js\": 36,\r\n\t\"./mixin-name-format.js\": 37,\r\n\t\"./mixins-before-declarations.js\": 38,\r\n\t\"./nesting-depth.js\": 39,\r\n\t\"./no-attribute-selectors.js\": 40,\r\n\t\"./no-color-hex.js\": 41,\r\n\t\"./no-color-keywords.js\": 42,\r\n\t\"./no-color-literals.js\": 43,\r\n\t\"./no-combinators.js\": 44,\r\n\t\"./no-css-comments.js\": 45,\r\n\t\"./no-debug.js\": 46,\r\n\t\"./no-disallowed-properties.js\": 47,\r\n\t\"./no-duplicate-properties.js\": 48,\r\n\t\"./no-empty-rulesets.js\": 49,\r\n\t\"./no-extends.js\": 50,\r\n\t\"./no-ids.js\": 51,\r\n\t\"./no-important.js\": 52,\r\n\t\"./no-invalid-hex.js\": 53,\r\n\t\"./no-mergeable-selectors.js\": 54,\r\n\t\"./no-misspelled-properties.js\": 55,\r\n\t\"./no-qualifying-elements.js\": 56,\r\n\t\"./no-trailing-whitespace.js\": 57,\r\n\t\"./no-trailing-zero.js\": 58,\r\n\t\"./no-transition-all.js\": 59,\r\n\t\"./no-universal-selectors.js\": 60,\r\n\t\"./no-url-domains.js\": 61,\r\n\t\"./no-url-protocols.js\": 62,\r\n\t\"./no-vendor-prefixes.js\": 63,\r\n\t\"./no-warn.js\": 64,\r\n\t\"./one-declaration-per-line.js\": 65,\r\n\t\"./placeholder-in-extend.js\": 66,\r\n\t\"./placeholder-name-format.js\": 67,\r\n\t\"./property-sort-order.js\": 68,\r\n\t\"./property-units.js\": 69,\r\n\t\"./pseudo-element.js\": 70,\r\n\t\"./quotes.js\": 71,\r\n\t\"./shorthand-values.js\": 72,\r\n\t\"./single-line-per-selector.js\": 73,\r\n\t\"./space-after-bang.js\": 74,\r\n\t\"./space-after-colon.js\": 75,\r\n\t\"./space-after-comma.js\": 76,\r\n\t\"./space-around-operator.js\": 77,\r\n\t\"./space-before-bang.js\": 78,\r\n\t\"./space-before-brace.js\": 79,\r\n\t\"./space-before-colon.js\": 80,\r\n\t\"./space-between-parens.js\": 81,\r\n\t\"./trailing-semicolon.js\": 82,\r\n\t\"./url-quotes.js\": 83,\r\n\t\"./variable-for-property.js\": 84,\r\n\t\"./variable-name-format.js\": 85,\r\n\t\"./zero-unit.js\": 86\r\n};\r\nfunction webpackContext(req) {\r\n\treturn __nested_webpack_require_777661__(webpackContextResolve(req));\r\n};\r\nfunction webpackContextResolve(req) {\r\n\tvar id = map[req];\r\n\tif(!(id + 1)) // check for number or string\r\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\r\n\treturn id;\r\n};\r\nwebpackContext.keys = function webpackContextKeys() {\r\n\treturn Object.keys(map);\r\n};\r\nwebpackContext.resolve = webpackContextResolve;\r\nmodule.exports = webpackContext;\r\nwebpackContext.id = 98;\r\n\r\n/***/ }),\r\n/* 99 */\r\n/***/ (function(module, exports, __nested_webpack_require_780554__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(module) {/*!\r\n * @name JavaScript/NodeJS Merge v1.2.0\r\n * @author yeikos\r\n * @repository https://github.com/yeikos/js.merge\r\n\r\n * Copyright 2014 yeikos - MIT license\r\n * https://raw.github.com/yeikos/js.merge/master/LICENSE\r\n */\r\n\r\n;(function(isNode) {\r\n\r\n\t/**\r\n\t * Merge one or more objects \r\n\t * @param bool? clone\r\n\t * @param mixed,... arguments\r\n\t * @return object\r\n\t */\r\n\r\n\tvar Public = function(clone) {\r\n\r\n\t\treturn merge(clone === true, false, arguments);\r\n\r\n\t}, publicName = 'merge';\r\n\r\n\t/**\r\n\t * Merge two or more objects recursively \r\n\t * @param bool? clone\r\n\t * @param mixed,... arguments\r\n\t * @return object\r\n\t */\r\n\r\n\tPublic.recursive = function(clone) {\r\n\r\n\t\treturn merge(clone === true, true, arguments);\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Clone the input removing any reference\r\n\t * @param mixed input\r\n\t * @return mixed\r\n\t */\r\n\r\n\tPublic.clone = function(input) {\r\n\r\n\t\tvar output = input,\r\n\t\t\ttype = typeOf(input),\r\n\t\t\tindex, size;\r\n\r\n\t\tif (type === 'array') {\r\n\r\n\t\t\toutput = [];\r\n\t\t\tsize = input.length;\r\n\r\n\t\t\tfor (index=0;index<size;++index)\r\n\r\n\t\t\t\toutput[index] = Public.clone(input[index]);\r\n\r\n\t\t} else if (type === 'object') {\r\n\r\n\t\t\toutput = {};\r\n\r\n\t\t\tfor (index in input)\r\n\r\n\t\t\t\toutput[index] = Public.clone(input[index]);\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Merge two objects recursively\r\n\t * @param mixed input\r\n\t * @param mixed extend\r\n\t * @return mixed\r\n\t */\r\n\r\n\tfunction merge_recursive(base, extend) {\r\n\r\n\t\tif (typeOf(base) !== 'object')\r\n\r\n\t\t\treturn extend;\r\n\r\n\t\tfor (var key in extend) {\r\n\r\n\t\t\tif (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {\r\n\r\n\t\t\t\tbase[key] = merge_recursive(base[key], extend[key]);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbase[key] = extend[key];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn base;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Merge two or more objects\r\n\t * @param bool clone\r\n\t * @param bool recursive\r\n\t * @param array argv\r\n\t * @return object\r\n\t */\r\n\r\n\tfunction merge(clone, recursive, argv) {\r\n\r\n\t\tvar result = argv[0],\r\n\t\t\tsize = argv.length;\r\n\r\n\t\tif (clone || typeOf(result) !== 'object')\r\n\r\n\t\t\tresult = {};\r\n\r\n\t\tfor (var index=0;index<size;++index) {\r\n\r\n\t\t\tvar item = argv[index],\r\n\r\n\t\t\t\ttype = typeOf(item);\r\n\r\n\t\t\tif (type !== 'object') continue;\r\n\r\n\t\t\tfor (var key in item) {\r\n\r\n\t\t\t\tvar sitem = clone ? Public.clone(item[key]) : item[key];\r\n\r\n\t\t\t\tif (recursive) {\r\n\r\n\t\t\t\t\tresult[key] = merge_recursive(result[key], sitem);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tresult[key] = sitem;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Get type of variable\r\n\t * @param mixed input\r\n\t * @return string\r\n\t *\r\n\t * @see http://jsperf.com/typeofvar\r\n\t */\r\n\r\n\tfunction typeOf(input) {\r\n\r\n\t\treturn ({}).toString.call(input).slice(8, -1).toLowerCase();\r\n\r\n\t}\r\n\r\n\tif (isNode) {\r\n\r\n\t\tmodule.exports = Public;\r\n\r\n\t} else {\r\n\r\n\t\twindow[publicName] = Public;\r\n\r\n\t}\r\n\r\n})(typeof module === 'object' && module && typeof module.exports === 'object' && module.exports);\r\n/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_780554__(6)(module)))\r\n\r\n/***/ })\r\n/******/ ]);\n\n//# sourceURL=webpack:///../../Modules/Base/Scripts/codemirror/scsslint.js?");

/***/ })

}]);